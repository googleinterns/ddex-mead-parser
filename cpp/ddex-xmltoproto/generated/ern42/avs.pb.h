// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ddex-xmltoproto/generated/ern42/avs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);

  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[77]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
namespace ern411 {
namespace avs {
class AdditionalTitleType;
class AdditionalTitleTypeDefaultTypeInternal;
extern AdditionalTitleTypeDefaultTypeInternal _AdditionalTitleType_default_instance_;
class AdministratingRecordCompanyRole;
class AdministratingRecordCompanyRoleDefaultTypeInternal;
extern AdministratingRecordCompanyRoleDefaultTypeInternal _AdministratingRecordCompanyRole_default_instance_;
class AffiliationType;
class AffiliationTypeDefaultTypeInternal;
extern AffiliationTypeDefaultTypeInternal _AffiliationType_default_instance_;
class AllTerritoryCode;
class AllTerritoryCodeDefaultTypeInternal;
extern AllTerritoryCodeDefaultTypeInternal _AllTerritoryCode_default_instance_;
class AspectRatioType;
class AspectRatioTypeDefaultTypeInternal;
extern AspectRatioTypeDefaultTypeInternal _AspectRatioType_default_instance_;
class AudioCodecType;
class AudioCodecTypeDefaultTypeInternal;
extern AudioCodecTypeDefaultTypeInternal _AudioCodecType_default_instance_;
class BinaryDataType;
class BinaryDataTypeDefaultTypeInternal;
extern BinaryDataTypeDefaultTypeInternal _BinaryDataType_default_instance_;
class CarrierType;
class CarrierTypeDefaultTypeInternal;
extern CarrierTypeDefaultTypeInternal _CarrierType_default_instance_;
class CodingType;
class CodingTypeDefaultTypeInternal;
extern CodingTypeDefaultTypeInternal _CodingType_default_instance_;
class CommercialModelType;
class CommercialModelTypeDefaultTypeInternal;
extern CommercialModelTypeDefaultTypeInternal _CommercialModelType_default_instance_;
class CompositeMusicalWorkType;
class CompositeMusicalWorkTypeDefaultTypeInternal;
extern CompositeMusicalWorkTypeDefaultTypeInternal _CompositeMusicalWorkType_default_instance_;
class ContainerFormat;
class ContainerFormatDefaultTypeInternal;
extern ContainerFormatDefaultTypeInternal _ContainerFormat_default_instance_;
class ContributorRole;
class ContributorRoleDefaultTypeInternal;
extern ContributorRoleDefaultTypeInternal _ContributorRole_default_instance_;
class CueOrigin;
class CueOriginDefaultTypeInternal;
extern CueOriginDefaultTypeInternal _CueOrigin_default_instance_;
class CueSheetType;
class CueSheetTypeDefaultTypeInternal;
extern CueSheetTypeDefaultTypeInternal _CueSheetType_default_instance_;
class CueUseType;
class CueUseTypeDefaultTypeInternal;
extern CueUseTypeDefaultTypeInternal _CueUseType_default_instance_;
class CurrencyCode;
class CurrencyCodeDefaultTypeInternal;
extern CurrencyCodeDefaultTypeInternal _CurrencyCode_default_instance_;
class CurrentTerritoryCode;
class CurrentTerritoryCodeDefaultTypeInternal;
extern CurrentTerritoryCodeDefaultTypeInternal _CurrentTerritoryCode_default_instance_;
class DisplayArtistRole;
class DisplayArtistRoleDefaultTypeInternal;
extern DisplayArtistRoleDefaultTypeInternal _DisplayArtistRole_default_instance_;
class ExpressionType;
class ExpressionTypeDefaultTypeInternal;
extern ExpressionTypeDefaultTypeInternal _ExpressionType_default_instance_;
class ExternallyLinkedResourceType;
class ExternallyLinkedResourceTypeDefaultTypeInternal;
extern ExternallyLinkedResourceTypeDefaultTypeInternal _ExternallyLinkedResourceType_default_instance_;
class FingerprintAlgorithmType;
class FingerprintAlgorithmTypeDefaultTypeInternal;
extern FingerprintAlgorithmTypeDefaultTypeInternal _FingerprintAlgorithmType_default_instance_;
class FrameRate;
class FrameRateDefaultTypeInternal;
extern FrameRateDefaultTypeInternal _FrameRate_default_instance_;
class HashSumAlgorithmType;
class HashSumAlgorithmTypeDefaultTypeInternal;
extern HashSumAlgorithmTypeDefaultTypeInternal _HashSumAlgorithmType_default_instance_;
class ImageCodecType;
class ImageCodecTypeDefaultTypeInternal;
extern ImageCodecTypeDefaultTypeInternal _ImageCodecType_default_instance_;
class ImageType;
class ImageTypeDefaultTypeInternal;
extern ImageTypeDefaultTypeInternal _ImageType_default_instance_;
class InstrumentType;
class InstrumentTypeDefaultTypeInternal;
extern InstrumentTypeDefaultTypeInternal _InstrumentType_default_instance_;
class IsoLanguageCode;
class IsoLanguageCodeDefaultTypeInternal;
extern IsoLanguageCodeDefaultTypeInternal _IsoLanguageCode_default_instance_;
class LabelType;
class LabelTypeDefaultTypeInternal;
extern LabelTypeDefaultTypeInternal _LabelType_default_instance_;
class LinkDescription;
class LinkDescriptionDefaultTypeInternal;
extern LinkDescriptionDefaultTypeInternal _LinkDescription_default_instance_;
class MessageControlType;
class MessageControlTypeDefaultTypeInternal;
extern MessageControlTypeDefaultTypeInternal _MessageControlType_default_instance_;
class OperatingSystemType;
class OperatingSystemTypeDefaultTypeInternal;
extern OperatingSystemTypeDefaultTypeInternal _OperatingSystemType_default_instance_;
class PLineType;
class PLineTypeDefaultTypeInternal;
extern PLineTypeDefaultTypeInternal _PLineType_default_instance_;
class ParentalWarningType;
class ParentalWarningTypeDefaultTypeInternal;
extern ParentalWarningTypeDefaultTypeInternal _ParentalWarningType_default_instance_;
class PartyRelationshipType;
class PartyRelationshipTypeDefaultTypeInternal;
extern PartyRelationshipTypeDefaultTypeInternal _PartyRelationshipType_default_instance_;
class Period;
class PeriodDefaultTypeInternal;
extern PeriodDefaultTypeInternal _Period_default_instance_;
class PriceInformationType;
class PriceInformationTypeDefaultTypeInternal;
extern PriceInformationTypeDefaultTypeInternal _PriceInformationType_default_instance_;
class PriceType;
class PriceTypeDefaultTypeInternal;
extern PriceTypeDefaultTypeInternal _PriceType_default_instance_;
class Purpose;
class PurposeDefaultTypeInternal;
extern PurposeDefaultTypeInternal _Purpose_default_instance_;
class RatingAgency;
class RatingAgencyDefaultTypeInternal;
extern RatingAgencyDefaultTypeInternal _RatingAgency_default_instance_;
class RatingReason;
class RatingReasonDefaultTypeInternal;
extern RatingReasonDefaultTypeInternal _RatingReason_default_instance_;
class RecordingMode;
class RecordingModeDefaultTypeInternal;
extern RecordingModeDefaultTypeInternal _RecordingMode_default_instance_;
class ReferenceCreation;
class ReferenceCreationDefaultTypeInternal;
extern ReferenceCreationDefaultTypeInternal _ReferenceCreation_default_instance_;
class RelationalRelator;
class RelationalRelatorDefaultTypeInternal;
extern RelationalRelatorDefaultTypeInternal _RelationalRelator_default_instance_;
class ReleaseProfileVariantVersionId;
class ReleaseProfileVariantVersionIdDefaultTypeInternal;
extern ReleaseProfileVariantVersionIdDefaultTypeInternal _ReleaseProfileVariantVersionId_default_instance_;
class ReleaseProfileVersionId;
class ReleaseProfileVersionIdDefaultTypeInternal;
extern ReleaseProfileVersionIdDefaultTypeInternal _ReleaseProfileVersionId_default_instance_;
class ReleaseRelationshipType;
class ReleaseRelationshipTypeDefaultTypeInternal;
extern ReleaseRelationshipTypeDefaultTypeInternal _ReleaseRelationshipType_default_instance_;
class ReleaseType_ERN4;
class ReleaseType_ERN4DefaultTypeInternal;
extern ReleaseType_ERN4DefaultTypeInternal _ReleaseType_ERN4_default_instance_;
class ResourceGroupType;
class ResourceGroupTypeDefaultTypeInternal;
extern ResourceGroupTypeDefaultTypeInternal _ResourceGroupType_default_instance_;
class ResourceRelationshipType;
class ResourceRelationshipTypeDefaultTypeInternal;
extern ResourceRelationshipTypeDefaultTypeInternal _ResourceRelationshipType_default_instance_;
class RightsClaimPolicyType;
class RightsClaimPolicyTypeDefaultTypeInternal;
extern RightsClaimPolicyTypeDefaultTypeInternal _RightsClaimPolicyType_default_instance_;
class RightsControllerRole;
class RightsControllerRoleDefaultTypeInternal;
extern RightsControllerRoleDefaultTypeInternal _RightsControllerRole_default_instance_;
class RightsControllerType;
class RightsControllerTypeDefaultTypeInternal;
extern RightsControllerTypeDefaultTypeInternal _RightsControllerType_default_instance_;
class RightsCoverage;
class RightsCoverageDefaultTypeInternal;
extern RightsCoverageDefaultTypeInternal _RightsCoverage_default_instance_;
class SheetMusicCodecType;
class SheetMusicCodecTypeDefaultTypeInternal;
extern SheetMusicCodecTypeDefaultTypeInternal _SheetMusicCodecType_default_instance_;
class SheetMusicType;
class SheetMusicTypeDefaultTypeInternal;
extern SheetMusicTypeDefaultTypeInternal _SheetMusicType_default_instance_;
class SoftwareType;
class SoftwareTypeDefaultTypeInternal;
extern SoftwareTypeDefaultTypeInternal _SoftwareType_default_instance_;
class SoundRecordingType;
class SoundRecordingTypeDefaultTypeInternal;
extern SoundRecordingTypeDefaultTypeInternal _SoundRecordingType_default_instance_;
class SubTitleType;
class SubTitleTypeDefaultTypeInternal;
extern SubTitleTypeDefaultTypeInternal _SubTitleType_default_instance_;
class TerritoryCodeType;
class TerritoryCodeTypeDefaultTypeInternal;
extern TerritoryCodeTypeDefaultTypeInternal _TerritoryCodeType_default_instance_;
class TerritoryCodeTypeIncludingDeprecatedCodes;
class TerritoryCodeTypeIncludingDeprecatedCodesDefaultTypeInternal;
extern TerritoryCodeTypeIncludingDeprecatedCodesDefaultTypeInternal _TerritoryCodeTypeIncludingDeprecatedCodes_default_instance_;
class TextCodecType;
class TextCodecTypeDefaultTypeInternal;
extern TextCodecTypeDefaultTypeInternal _TextCodecType_default_instance_;
class TextType;
class TextTypeDefaultTypeInternal;
extern TextTypeDefaultTypeInternal _TextType_default_instance_;
class ThemeType;
class ThemeTypeDefaultTypeInternal;
extern ThemeTypeDefaultTypeInternal _ThemeType_default_instance_;
class TitleType;
class TitleTypeDefaultTypeInternal;
extern TitleTypeDefaultTypeInternal _TitleType_default_instance_;
class UnitOfBitRate;
class UnitOfBitRateDefaultTypeInternal;
extern UnitOfBitRateDefaultTypeInternal _UnitOfBitRate_default_instance_;
class UnitOfConditionValue;
class UnitOfConditionValueDefaultTypeInternal;
extern UnitOfConditionValueDefaultTypeInternal _UnitOfConditionValue_default_instance_;
class UnitOfExtent;
class UnitOfExtentDefaultTypeInternal;
extern UnitOfExtentDefaultTypeInternal _UnitOfExtent_default_instance_;
class UnitOfFrameRate;
class UnitOfFrameRateDefaultTypeInternal;
extern UnitOfFrameRateDefaultTypeInternal _UnitOfFrameRate_default_instance_;
class UnitOfFrequency;
class UnitOfFrequencyDefaultTypeInternal;
extern UnitOfFrequencyDefaultTypeInternal _UnitOfFrequency_default_instance_;
class UseType;
class UseTypeDefaultTypeInternal;
extern UseTypeDefaultTypeInternal _UseType_default_instance_;
class VersionType;
class VersionTypeDefaultTypeInternal;
extern VersionTypeDefaultTypeInternal _VersionType_default_instance_;
class VideoCodecType;
class VideoCodecTypeDefaultTypeInternal;
extern VideoCodecTypeDefaultTypeInternal _VideoCodecType_default_instance_;
class VideoDefinitionType;
class VideoDefinitionTypeDefaultTypeInternal;
extern VideoDefinitionTypeDefaultTypeInternal _VideoDefinitionType_default_instance_;
class VideoType;
class VideoTypeDefaultTypeInternal;
extern VideoTypeDefaultTypeInternal _VideoType_default_instance_;
class VisualPerceptionType;
class VisualPerceptionTypeDefaultTypeInternal;
extern VisualPerceptionTypeDefaultTypeInternal _VisualPerceptionType_default_instance_;
class VocalType;
class VocalTypeDefaultTypeInternal;
extern VocalTypeDefaultTypeInternal _VocalType_default_instance_;
}  // namespace avs
}  // namespace ern411
PROTOBUF_NAMESPACE_OPEN
template<> ::ern411::avs::AdditionalTitleType* Arena::CreateMaybeMessage<::ern411::avs::AdditionalTitleType>(Arena*);
template<> ::ern411::avs::AdministratingRecordCompanyRole* Arena::CreateMaybeMessage<::ern411::avs::AdministratingRecordCompanyRole>(Arena*);
template<> ::ern411::avs::AffiliationType* Arena::CreateMaybeMessage<::ern411::avs::AffiliationType>(Arena*);
template<> ::ern411::avs::AllTerritoryCode* Arena::CreateMaybeMessage<::ern411::avs::AllTerritoryCode>(Arena*);
template<> ::ern411::avs::AspectRatioType* Arena::CreateMaybeMessage<::ern411::avs::AspectRatioType>(Arena*);
template<> ::ern411::avs::AudioCodecType* Arena::CreateMaybeMessage<::ern411::avs::AudioCodecType>(Arena*);
template<> ::ern411::avs::BinaryDataType* Arena::CreateMaybeMessage<::ern411::avs::BinaryDataType>(Arena*);
template<> ::ern411::avs::CarrierType* Arena::CreateMaybeMessage<::ern411::avs::CarrierType>(Arena*);
template<> ::ern411::avs::CodingType* Arena::CreateMaybeMessage<::ern411::avs::CodingType>(Arena*);
template<> ::ern411::avs::CommercialModelType* Arena::CreateMaybeMessage<::ern411::avs::CommercialModelType>(Arena*);
template<> ::ern411::avs::CompositeMusicalWorkType* Arena::CreateMaybeMessage<::ern411::avs::CompositeMusicalWorkType>(Arena*);
template<> ::ern411::avs::ContainerFormat* Arena::CreateMaybeMessage<::ern411::avs::ContainerFormat>(Arena*);
template<> ::ern411::avs::ContributorRole* Arena::CreateMaybeMessage<::ern411::avs::ContributorRole>(Arena*);
template<> ::ern411::avs::CueOrigin* Arena::CreateMaybeMessage<::ern411::avs::CueOrigin>(Arena*);
template<> ::ern411::avs::CueSheetType* Arena::CreateMaybeMessage<::ern411::avs::CueSheetType>(Arena*);
template<> ::ern411::avs::CueUseType* Arena::CreateMaybeMessage<::ern411::avs::CueUseType>(Arena*);
template<> ::ern411::avs::CurrencyCode* Arena::CreateMaybeMessage<::ern411::avs::CurrencyCode>(Arena*);
template<> ::ern411::avs::CurrentTerritoryCode* Arena::CreateMaybeMessage<::ern411::avs::CurrentTerritoryCode>(Arena*);
template<> ::ern411::avs::DisplayArtistRole* Arena::CreateMaybeMessage<::ern411::avs::DisplayArtistRole>(Arena*);
template<> ::ern411::avs::ExpressionType* Arena::CreateMaybeMessage<::ern411::avs::ExpressionType>(Arena*);
template<> ::ern411::avs::ExternallyLinkedResourceType* Arena::CreateMaybeMessage<::ern411::avs::ExternallyLinkedResourceType>(Arena*);
template<> ::ern411::avs::FingerprintAlgorithmType* Arena::CreateMaybeMessage<::ern411::avs::FingerprintAlgorithmType>(Arena*);
template<> ::ern411::avs::FrameRate* Arena::CreateMaybeMessage<::ern411::avs::FrameRate>(Arena*);
template<> ::ern411::avs::HashSumAlgorithmType* Arena::CreateMaybeMessage<::ern411::avs::HashSumAlgorithmType>(Arena*);
template<> ::ern411::avs::ImageCodecType* Arena::CreateMaybeMessage<::ern411::avs::ImageCodecType>(Arena*);
template<> ::ern411::avs::ImageType* Arena::CreateMaybeMessage<::ern411::avs::ImageType>(Arena*);
template<> ::ern411::avs::InstrumentType* Arena::CreateMaybeMessage<::ern411::avs::InstrumentType>(Arena*);
template<> ::ern411::avs::IsoLanguageCode* Arena::CreateMaybeMessage<::ern411::avs::IsoLanguageCode>(Arena*);
template<> ::ern411::avs::LabelType* Arena::CreateMaybeMessage<::ern411::avs::LabelType>(Arena*);
template<> ::ern411::avs::LinkDescription* Arena::CreateMaybeMessage<::ern411::avs::LinkDescription>(Arena*);
template<> ::ern411::avs::MessageControlType* Arena::CreateMaybeMessage<::ern411::avs::MessageControlType>(Arena*);
template<> ::ern411::avs::OperatingSystemType* Arena::CreateMaybeMessage<::ern411::avs::OperatingSystemType>(Arena*);
template<> ::ern411::avs::PLineType* Arena::CreateMaybeMessage<::ern411::avs::PLineType>(Arena*);
template<> ::ern411::avs::ParentalWarningType* Arena::CreateMaybeMessage<::ern411::avs::ParentalWarningType>(Arena*);
template<> ::ern411::avs::PartyRelationshipType* Arena::CreateMaybeMessage<::ern411::avs::PartyRelationshipType>(Arena*);
template<> ::ern411::avs::Period* Arena::CreateMaybeMessage<::ern411::avs::Period>(Arena*);
template<> ::ern411::avs::PriceInformationType* Arena::CreateMaybeMessage<::ern411::avs::PriceInformationType>(Arena*);
template<> ::ern411::avs::PriceType* Arena::CreateMaybeMessage<::ern411::avs::PriceType>(Arena*);
template<> ::ern411::avs::Purpose* Arena::CreateMaybeMessage<::ern411::avs::Purpose>(Arena*);
template<> ::ern411::avs::RatingAgency* Arena::CreateMaybeMessage<::ern411::avs::RatingAgency>(Arena*);
template<> ::ern411::avs::RatingReason* Arena::CreateMaybeMessage<::ern411::avs::RatingReason>(Arena*);
template<> ::ern411::avs::RecordingMode* Arena::CreateMaybeMessage<::ern411::avs::RecordingMode>(Arena*);
template<> ::ern411::avs::ReferenceCreation* Arena::CreateMaybeMessage<::ern411::avs::ReferenceCreation>(Arena*);
template<> ::ern411::avs::RelationalRelator* Arena::CreateMaybeMessage<::ern411::avs::RelationalRelator>(Arena*);
template<> ::ern411::avs::ReleaseProfileVariantVersionId* Arena::CreateMaybeMessage<::ern411::avs::ReleaseProfileVariantVersionId>(Arena*);
template<> ::ern411::avs::ReleaseProfileVersionId* Arena::CreateMaybeMessage<::ern411::avs::ReleaseProfileVersionId>(Arena*);
template<> ::ern411::avs::ReleaseRelationshipType* Arena::CreateMaybeMessage<::ern411::avs::ReleaseRelationshipType>(Arena*);
template<> ::ern411::avs::ReleaseType_ERN4* Arena::CreateMaybeMessage<::ern411::avs::ReleaseType_ERN4>(Arena*);
template<> ::ern411::avs::ResourceGroupType* Arena::CreateMaybeMessage<::ern411::avs::ResourceGroupType>(Arena*);
template<> ::ern411::avs::ResourceRelationshipType* Arena::CreateMaybeMessage<::ern411::avs::ResourceRelationshipType>(Arena*);
template<> ::ern411::avs::RightsClaimPolicyType* Arena::CreateMaybeMessage<::ern411::avs::RightsClaimPolicyType>(Arena*);
template<> ::ern411::avs::RightsControllerRole* Arena::CreateMaybeMessage<::ern411::avs::RightsControllerRole>(Arena*);
template<> ::ern411::avs::RightsControllerType* Arena::CreateMaybeMessage<::ern411::avs::RightsControllerType>(Arena*);
template<> ::ern411::avs::RightsCoverage* Arena::CreateMaybeMessage<::ern411::avs::RightsCoverage>(Arena*);
template<> ::ern411::avs::SheetMusicCodecType* Arena::CreateMaybeMessage<::ern411::avs::SheetMusicCodecType>(Arena*);
template<> ::ern411::avs::SheetMusicType* Arena::CreateMaybeMessage<::ern411::avs::SheetMusicType>(Arena*);
template<> ::ern411::avs::SoftwareType* Arena::CreateMaybeMessage<::ern411::avs::SoftwareType>(Arena*);
template<> ::ern411::avs::SoundRecordingType* Arena::CreateMaybeMessage<::ern411::avs::SoundRecordingType>(Arena*);
template<> ::ern411::avs::SubTitleType* Arena::CreateMaybeMessage<::ern411::avs::SubTitleType>(Arena*);
template<> ::ern411::avs::TerritoryCodeType* Arena::CreateMaybeMessage<::ern411::avs::TerritoryCodeType>(Arena*);
template<> ::ern411::avs::TerritoryCodeTypeIncludingDeprecatedCodes* Arena::CreateMaybeMessage<::ern411::avs::TerritoryCodeTypeIncludingDeprecatedCodes>(Arena*);
template<> ::ern411::avs::TextCodecType* Arena::CreateMaybeMessage<::ern411::avs::TextCodecType>(Arena*);
template<> ::ern411::avs::TextType* Arena::CreateMaybeMessage<::ern411::avs::TextType>(Arena*);
template<> ::ern411::avs::ThemeType* Arena::CreateMaybeMessage<::ern411::avs::ThemeType>(Arena*);
template<> ::ern411::avs::TitleType* Arena::CreateMaybeMessage<::ern411::avs::TitleType>(Arena*);
template<> ::ern411::avs::UnitOfBitRate* Arena::CreateMaybeMessage<::ern411::avs::UnitOfBitRate>(Arena*);
template<> ::ern411::avs::UnitOfConditionValue* Arena::CreateMaybeMessage<::ern411::avs::UnitOfConditionValue>(Arena*);
template<> ::ern411::avs::UnitOfExtent* Arena::CreateMaybeMessage<::ern411::avs::UnitOfExtent>(Arena*);
template<> ::ern411::avs::UnitOfFrameRate* Arena::CreateMaybeMessage<::ern411::avs::UnitOfFrameRate>(Arena*);
template<> ::ern411::avs::UnitOfFrequency* Arena::CreateMaybeMessage<::ern411::avs::UnitOfFrequency>(Arena*);
template<> ::ern411::avs::UseType* Arena::CreateMaybeMessage<::ern411::avs::UseType>(Arena*);
template<> ::ern411::avs::VersionType* Arena::CreateMaybeMessage<::ern411::avs::VersionType>(Arena*);
template<> ::ern411::avs::VideoCodecType* Arena::CreateMaybeMessage<::ern411::avs::VideoCodecType>(Arena*);
template<> ::ern411::avs::VideoDefinitionType* Arena::CreateMaybeMessage<::ern411::avs::VideoDefinitionType>(Arena*);
template<> ::ern411::avs::VideoType* Arena::CreateMaybeMessage<::ern411::avs::VideoType>(Arena*);
template<> ::ern411::avs::VisualPerceptionType* Arena::CreateMaybeMessage<::ern411::avs::VisualPerceptionType>(Arena*);
template<> ::ern411::avs::VocalType* Arena::CreateMaybeMessage<::ern411::avs::VocalType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ern411 {
namespace avs {

// ===================================================================

class AdditionalTitleType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.AdditionalTitleType) */ {
 public:
  inline AdditionalTitleType() : AdditionalTitleType(nullptr) {}
  virtual ~AdditionalTitleType();

  AdditionalTitleType(const AdditionalTitleType& from);
  AdditionalTitleType(AdditionalTitleType&& from) noexcept
    : AdditionalTitleType() {
    *this = ::std::move(from);
  }

  inline AdditionalTitleType& operator=(const AdditionalTitleType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdditionalTitleType& operator=(AdditionalTitleType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdditionalTitleType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdditionalTitleType* internal_default_instance() {
    return reinterpret_cast<const AdditionalTitleType*>(
               &_AdditionalTitleType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AdditionalTitleType& a, AdditionalTitleType& b) {
    a.Swap(&b);
  }
  inline void Swap(AdditionalTitleType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdditionalTitleType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdditionalTitleType* New() const final {
    return CreateMaybeMessage<AdditionalTitleType>(nullptr);
  }

  AdditionalTitleType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdditionalTitleType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdditionalTitleType& from);
  void MergeFrom(const AdditionalTitleType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdditionalTitleType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.AdditionalTitleType";
  }
  protected:
  explicit AdditionalTitleType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.AdditionalTitleType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class AdministratingRecordCompanyRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.AdministratingRecordCompanyRole) */ {
 public:
  inline AdministratingRecordCompanyRole() : AdministratingRecordCompanyRole(nullptr) {}
  virtual ~AdministratingRecordCompanyRole();

  AdministratingRecordCompanyRole(const AdministratingRecordCompanyRole& from);
  AdministratingRecordCompanyRole(AdministratingRecordCompanyRole&& from) noexcept
    : AdministratingRecordCompanyRole() {
    *this = ::std::move(from);
  }

  inline AdministratingRecordCompanyRole& operator=(const AdministratingRecordCompanyRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdministratingRecordCompanyRole& operator=(AdministratingRecordCompanyRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdministratingRecordCompanyRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdministratingRecordCompanyRole* internal_default_instance() {
    return reinterpret_cast<const AdministratingRecordCompanyRole*>(
               &_AdministratingRecordCompanyRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AdministratingRecordCompanyRole& a, AdministratingRecordCompanyRole& b) {
    a.Swap(&b);
  }
  inline void Swap(AdministratingRecordCompanyRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdministratingRecordCompanyRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdministratingRecordCompanyRole* New() const final {
    return CreateMaybeMessage<AdministratingRecordCompanyRole>(nullptr);
  }

  AdministratingRecordCompanyRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdministratingRecordCompanyRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdministratingRecordCompanyRole& from);
  void MergeFrom(const AdministratingRecordCompanyRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdministratingRecordCompanyRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.AdministratingRecordCompanyRole";
  }
  protected:
  explicit AdministratingRecordCompanyRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.AdministratingRecordCompanyRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class AffiliationType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.AffiliationType) */ {
 public:
  inline AffiliationType() : AffiliationType(nullptr) {}
  virtual ~AffiliationType();

  AffiliationType(const AffiliationType& from);
  AffiliationType(AffiliationType&& from) noexcept
    : AffiliationType() {
    *this = ::std::move(from);
  }

  inline AffiliationType& operator=(const AffiliationType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AffiliationType& operator=(AffiliationType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AffiliationType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AffiliationType* internal_default_instance() {
    return reinterpret_cast<const AffiliationType*>(
               &_AffiliationType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AffiliationType& a, AffiliationType& b) {
    a.Swap(&b);
  }
  inline void Swap(AffiliationType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AffiliationType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AffiliationType* New() const final {
    return CreateMaybeMessage<AffiliationType>(nullptr);
  }

  AffiliationType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AffiliationType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AffiliationType& from);
  void MergeFrom(const AffiliationType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AffiliationType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.AffiliationType";
  }
  protected:
  explicit AffiliationType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.AffiliationType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class AllTerritoryCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.AllTerritoryCode) */ {
 public:
  inline AllTerritoryCode() : AllTerritoryCode(nullptr) {}
  virtual ~AllTerritoryCode();

  AllTerritoryCode(const AllTerritoryCode& from);
  AllTerritoryCode(AllTerritoryCode&& from) noexcept
    : AllTerritoryCode() {
    *this = ::std::move(from);
  }

  inline AllTerritoryCode& operator=(const AllTerritoryCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllTerritoryCode& operator=(AllTerritoryCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AllTerritoryCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllTerritoryCode* internal_default_instance() {
    return reinterpret_cast<const AllTerritoryCode*>(
               &_AllTerritoryCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AllTerritoryCode& a, AllTerritoryCode& b) {
    a.Swap(&b);
  }
  inline void Swap(AllTerritoryCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllTerritoryCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllTerritoryCode* New() const final {
    return CreateMaybeMessage<AllTerritoryCode>(nullptr);
  }

  AllTerritoryCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllTerritoryCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AllTerritoryCode& from);
  void MergeFrom(const AllTerritoryCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllTerritoryCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.AllTerritoryCode";
  }
  protected:
  explicit AllTerritoryCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.AllTerritoryCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class AspectRatioType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.AspectRatioType) */ {
 public:
  inline AspectRatioType() : AspectRatioType(nullptr) {}
  virtual ~AspectRatioType();

  AspectRatioType(const AspectRatioType& from);
  AspectRatioType(AspectRatioType&& from) noexcept
    : AspectRatioType() {
    *this = ::std::move(from);
  }

  inline AspectRatioType& operator=(const AspectRatioType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AspectRatioType& operator=(AspectRatioType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AspectRatioType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AspectRatioType* internal_default_instance() {
    return reinterpret_cast<const AspectRatioType*>(
               &_AspectRatioType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AspectRatioType& a, AspectRatioType& b) {
    a.Swap(&b);
  }
  inline void Swap(AspectRatioType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AspectRatioType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AspectRatioType* New() const final {
    return CreateMaybeMessage<AspectRatioType>(nullptr);
  }

  AspectRatioType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AspectRatioType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AspectRatioType& from);
  void MergeFrom(const AspectRatioType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AspectRatioType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.AspectRatioType";
  }
  protected:
  explicit AspectRatioType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.AspectRatioType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class AudioCodecType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.AudioCodecType) */ {
 public:
  inline AudioCodecType() : AudioCodecType(nullptr) {}
  virtual ~AudioCodecType();

  AudioCodecType(const AudioCodecType& from);
  AudioCodecType(AudioCodecType&& from) noexcept
    : AudioCodecType() {
    *this = ::std::move(from);
  }

  inline AudioCodecType& operator=(const AudioCodecType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioCodecType& operator=(AudioCodecType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioCodecType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioCodecType* internal_default_instance() {
    return reinterpret_cast<const AudioCodecType*>(
               &_AudioCodecType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AudioCodecType& a, AudioCodecType& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioCodecType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioCodecType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioCodecType* New() const final {
    return CreateMaybeMessage<AudioCodecType>(nullptr);
  }

  AudioCodecType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioCodecType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioCodecType& from);
  void MergeFrom(const AudioCodecType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioCodecType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.AudioCodecType";
  }
  protected:
  explicit AudioCodecType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.AudioCodecType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class BinaryDataType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.BinaryDataType) */ {
 public:
  inline BinaryDataType() : BinaryDataType(nullptr) {}
  virtual ~BinaryDataType();

  BinaryDataType(const BinaryDataType& from);
  BinaryDataType(BinaryDataType&& from) noexcept
    : BinaryDataType() {
    *this = ::std::move(from);
  }

  inline BinaryDataType& operator=(const BinaryDataType& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryDataType& operator=(BinaryDataType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BinaryDataType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryDataType* internal_default_instance() {
    return reinterpret_cast<const BinaryDataType*>(
               &_BinaryDataType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BinaryDataType& a, BinaryDataType& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryDataType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryDataType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinaryDataType* New() const final {
    return CreateMaybeMessage<BinaryDataType>(nullptr);
  }

  BinaryDataType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinaryDataType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BinaryDataType& from);
  void MergeFrom(const BinaryDataType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryDataType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.BinaryDataType";
  }
  protected:
  explicit BinaryDataType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.BinaryDataType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class CarrierType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.CarrierType) */ {
 public:
  inline CarrierType() : CarrierType(nullptr) {}
  virtual ~CarrierType();

  CarrierType(const CarrierType& from);
  CarrierType(CarrierType&& from) noexcept
    : CarrierType() {
    *this = ::std::move(from);
  }

  inline CarrierType& operator=(const CarrierType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarrierType& operator=(CarrierType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CarrierType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CarrierType* internal_default_instance() {
    return reinterpret_cast<const CarrierType*>(
               &_CarrierType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CarrierType& a, CarrierType& b) {
    a.Swap(&b);
  }
  inline void Swap(CarrierType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarrierType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CarrierType* New() const final {
    return CreateMaybeMessage<CarrierType>(nullptr);
  }

  CarrierType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CarrierType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CarrierType& from);
  void MergeFrom(const CarrierType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarrierType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.CarrierType";
  }
  protected:
  explicit CarrierType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.CarrierType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class CodingType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.CodingType) */ {
 public:
  inline CodingType() : CodingType(nullptr) {}
  virtual ~CodingType();

  CodingType(const CodingType& from);
  CodingType(CodingType&& from) noexcept
    : CodingType() {
    *this = ::std::move(from);
  }

  inline CodingType& operator=(const CodingType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CodingType& operator=(CodingType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CodingType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CodingType* internal_default_instance() {
    return reinterpret_cast<const CodingType*>(
               &_CodingType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CodingType& a, CodingType& b) {
    a.Swap(&b);
  }
  inline void Swap(CodingType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CodingType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CodingType* New() const final {
    return CreateMaybeMessage<CodingType>(nullptr);
  }

  CodingType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CodingType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CodingType& from);
  void MergeFrom(const CodingType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CodingType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.CodingType";
  }
  protected:
  explicit CodingType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.CodingType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class CommercialModelType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.CommercialModelType) */ {
 public:
  inline CommercialModelType() : CommercialModelType(nullptr) {}
  virtual ~CommercialModelType();

  CommercialModelType(const CommercialModelType& from);
  CommercialModelType(CommercialModelType&& from) noexcept
    : CommercialModelType() {
    *this = ::std::move(from);
  }

  inline CommercialModelType& operator=(const CommercialModelType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommercialModelType& operator=(CommercialModelType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommercialModelType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommercialModelType* internal_default_instance() {
    return reinterpret_cast<const CommercialModelType*>(
               &_CommercialModelType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CommercialModelType& a, CommercialModelType& b) {
    a.Swap(&b);
  }
  inline void Swap(CommercialModelType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommercialModelType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommercialModelType* New() const final {
    return CreateMaybeMessage<CommercialModelType>(nullptr);
  }

  CommercialModelType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommercialModelType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommercialModelType& from);
  void MergeFrom(const CommercialModelType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommercialModelType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.CommercialModelType";
  }
  protected:
  explicit CommercialModelType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.CommercialModelType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class CompositeMusicalWorkType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.CompositeMusicalWorkType) */ {
 public:
  inline CompositeMusicalWorkType() : CompositeMusicalWorkType(nullptr) {}
  virtual ~CompositeMusicalWorkType();

  CompositeMusicalWorkType(const CompositeMusicalWorkType& from);
  CompositeMusicalWorkType(CompositeMusicalWorkType&& from) noexcept
    : CompositeMusicalWorkType() {
    *this = ::std::move(from);
  }

  inline CompositeMusicalWorkType& operator=(const CompositeMusicalWorkType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompositeMusicalWorkType& operator=(CompositeMusicalWorkType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CompositeMusicalWorkType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompositeMusicalWorkType* internal_default_instance() {
    return reinterpret_cast<const CompositeMusicalWorkType*>(
               &_CompositeMusicalWorkType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CompositeMusicalWorkType& a, CompositeMusicalWorkType& b) {
    a.Swap(&b);
  }
  inline void Swap(CompositeMusicalWorkType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompositeMusicalWorkType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompositeMusicalWorkType* New() const final {
    return CreateMaybeMessage<CompositeMusicalWorkType>(nullptr);
  }

  CompositeMusicalWorkType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompositeMusicalWorkType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CompositeMusicalWorkType& from);
  void MergeFrom(const CompositeMusicalWorkType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompositeMusicalWorkType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.CompositeMusicalWorkType";
  }
  protected:
  explicit CompositeMusicalWorkType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.CompositeMusicalWorkType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ContainerFormat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ContainerFormat) */ {
 public:
  inline ContainerFormat() : ContainerFormat(nullptr) {}
  virtual ~ContainerFormat();

  ContainerFormat(const ContainerFormat& from);
  ContainerFormat(ContainerFormat&& from) noexcept
    : ContainerFormat() {
    *this = ::std::move(from);
  }

  inline ContainerFormat& operator=(const ContainerFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContainerFormat& operator=(ContainerFormat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContainerFormat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerFormat* internal_default_instance() {
    return reinterpret_cast<const ContainerFormat*>(
               &_ContainerFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ContainerFormat& a, ContainerFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(ContainerFormat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContainerFormat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContainerFormat* New() const final {
    return CreateMaybeMessage<ContainerFormat>(nullptr);
  }

  ContainerFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContainerFormat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContainerFormat& from);
  void MergeFrom(const ContainerFormat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContainerFormat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ContainerFormat";
  }
  protected:
  explicit ContainerFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ContainerFormat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ContributorRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ContributorRole) */ {
 public:
  inline ContributorRole() : ContributorRole(nullptr) {}
  virtual ~ContributorRole();

  ContributorRole(const ContributorRole& from);
  ContributorRole(ContributorRole&& from) noexcept
    : ContributorRole() {
    *this = ::std::move(from);
  }

  inline ContributorRole& operator=(const ContributorRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContributorRole& operator=(ContributorRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContributorRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContributorRole* internal_default_instance() {
    return reinterpret_cast<const ContributorRole*>(
               &_ContributorRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ContributorRole& a, ContributorRole& b) {
    a.Swap(&b);
  }
  inline void Swap(ContributorRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContributorRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContributorRole* New() const final {
    return CreateMaybeMessage<ContributorRole>(nullptr);
  }

  ContributorRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContributorRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContributorRole& from);
  void MergeFrom(const ContributorRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContributorRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ContributorRole";
  }
  protected:
  explicit ContributorRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ContributorRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class CueOrigin PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.CueOrigin) */ {
 public:
  inline CueOrigin() : CueOrigin(nullptr) {}
  virtual ~CueOrigin();

  CueOrigin(const CueOrigin& from);
  CueOrigin(CueOrigin&& from) noexcept
    : CueOrigin() {
    *this = ::std::move(from);
  }

  inline CueOrigin& operator=(const CueOrigin& from) {
    CopyFrom(from);
    return *this;
  }
  inline CueOrigin& operator=(CueOrigin&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CueOrigin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CueOrigin* internal_default_instance() {
    return reinterpret_cast<const CueOrigin*>(
               &_CueOrigin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CueOrigin& a, CueOrigin& b) {
    a.Swap(&b);
  }
  inline void Swap(CueOrigin* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CueOrigin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CueOrigin* New() const final {
    return CreateMaybeMessage<CueOrigin>(nullptr);
  }

  CueOrigin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CueOrigin>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CueOrigin& from);
  void MergeFrom(const CueOrigin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CueOrigin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.CueOrigin";
  }
  protected:
  explicit CueOrigin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.CueOrigin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class CueSheetType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.CueSheetType) */ {
 public:
  inline CueSheetType() : CueSheetType(nullptr) {}
  virtual ~CueSheetType();

  CueSheetType(const CueSheetType& from);
  CueSheetType(CueSheetType&& from) noexcept
    : CueSheetType() {
    *this = ::std::move(from);
  }

  inline CueSheetType& operator=(const CueSheetType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CueSheetType& operator=(CueSheetType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CueSheetType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CueSheetType* internal_default_instance() {
    return reinterpret_cast<const CueSheetType*>(
               &_CueSheetType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CueSheetType& a, CueSheetType& b) {
    a.Swap(&b);
  }
  inline void Swap(CueSheetType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CueSheetType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CueSheetType* New() const final {
    return CreateMaybeMessage<CueSheetType>(nullptr);
  }

  CueSheetType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CueSheetType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CueSheetType& from);
  void MergeFrom(const CueSheetType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CueSheetType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.CueSheetType";
  }
  protected:
  explicit CueSheetType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.CueSheetType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class CueUseType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.CueUseType) */ {
 public:
  inline CueUseType() : CueUseType(nullptr) {}
  virtual ~CueUseType();

  CueUseType(const CueUseType& from);
  CueUseType(CueUseType&& from) noexcept
    : CueUseType() {
    *this = ::std::move(from);
  }

  inline CueUseType& operator=(const CueUseType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CueUseType& operator=(CueUseType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CueUseType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CueUseType* internal_default_instance() {
    return reinterpret_cast<const CueUseType*>(
               &_CueUseType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CueUseType& a, CueUseType& b) {
    a.Swap(&b);
  }
  inline void Swap(CueUseType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CueUseType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CueUseType* New() const final {
    return CreateMaybeMessage<CueUseType>(nullptr);
  }

  CueUseType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CueUseType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CueUseType& from);
  void MergeFrom(const CueUseType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CueUseType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.CueUseType";
  }
  protected:
  explicit CueUseType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.CueUseType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class CurrencyCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.CurrencyCode) */ {
 public:
  inline CurrencyCode() : CurrencyCode(nullptr) {}
  virtual ~CurrencyCode();

  CurrencyCode(const CurrencyCode& from);
  CurrencyCode(CurrencyCode&& from) noexcept
    : CurrencyCode() {
    *this = ::std::move(from);
  }

  inline CurrencyCode& operator=(const CurrencyCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrencyCode& operator=(CurrencyCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CurrencyCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CurrencyCode* internal_default_instance() {
    return reinterpret_cast<const CurrencyCode*>(
               &_CurrencyCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CurrencyCode& a, CurrencyCode& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrencyCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrencyCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CurrencyCode* New() const final {
    return CreateMaybeMessage<CurrencyCode>(nullptr);
  }

  CurrencyCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CurrencyCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CurrencyCode& from);
  void MergeFrom(const CurrencyCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrencyCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.CurrencyCode";
  }
  protected:
  explicit CurrencyCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.CurrencyCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class CurrentTerritoryCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.CurrentTerritoryCode) */ {
 public:
  inline CurrentTerritoryCode() : CurrentTerritoryCode(nullptr) {}
  virtual ~CurrentTerritoryCode();

  CurrentTerritoryCode(const CurrentTerritoryCode& from);
  CurrentTerritoryCode(CurrentTerritoryCode&& from) noexcept
    : CurrentTerritoryCode() {
    *this = ::std::move(from);
  }

  inline CurrentTerritoryCode& operator=(const CurrentTerritoryCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrentTerritoryCode& operator=(CurrentTerritoryCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CurrentTerritoryCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CurrentTerritoryCode* internal_default_instance() {
    return reinterpret_cast<const CurrentTerritoryCode*>(
               &_CurrentTerritoryCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CurrentTerritoryCode& a, CurrentTerritoryCode& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrentTerritoryCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrentTerritoryCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CurrentTerritoryCode* New() const final {
    return CreateMaybeMessage<CurrentTerritoryCode>(nullptr);
  }

  CurrentTerritoryCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CurrentTerritoryCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CurrentTerritoryCode& from);
  void MergeFrom(const CurrentTerritoryCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentTerritoryCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.CurrentTerritoryCode";
  }
  protected:
  explicit CurrentTerritoryCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.CurrentTerritoryCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class DisplayArtistRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.DisplayArtistRole) */ {
 public:
  inline DisplayArtistRole() : DisplayArtistRole(nullptr) {}
  virtual ~DisplayArtistRole();

  DisplayArtistRole(const DisplayArtistRole& from);
  DisplayArtistRole(DisplayArtistRole&& from) noexcept
    : DisplayArtistRole() {
    *this = ::std::move(from);
  }

  inline DisplayArtistRole& operator=(const DisplayArtistRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisplayArtistRole& operator=(DisplayArtistRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DisplayArtistRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DisplayArtistRole* internal_default_instance() {
    return reinterpret_cast<const DisplayArtistRole*>(
               &_DisplayArtistRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DisplayArtistRole& a, DisplayArtistRole& b) {
    a.Swap(&b);
  }
  inline void Swap(DisplayArtistRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisplayArtistRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DisplayArtistRole* New() const final {
    return CreateMaybeMessage<DisplayArtistRole>(nullptr);
  }

  DisplayArtistRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DisplayArtistRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DisplayArtistRole& from);
  void MergeFrom(const DisplayArtistRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisplayArtistRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.DisplayArtistRole";
  }
  protected:
  explicit DisplayArtistRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.DisplayArtistRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ExpressionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ExpressionType) */ {
 public:
  inline ExpressionType() : ExpressionType(nullptr) {}
  virtual ~ExpressionType();

  ExpressionType(const ExpressionType& from);
  ExpressionType(ExpressionType&& from) noexcept
    : ExpressionType() {
    *this = ::std::move(from);
  }

  inline ExpressionType& operator=(const ExpressionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpressionType& operator=(ExpressionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExpressionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExpressionType* internal_default_instance() {
    return reinterpret_cast<const ExpressionType*>(
               &_ExpressionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ExpressionType& a, ExpressionType& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpressionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpressionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExpressionType* New() const final {
    return CreateMaybeMessage<ExpressionType>(nullptr);
  }

  ExpressionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExpressionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExpressionType& from);
  void MergeFrom(const ExpressionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpressionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ExpressionType";
  }
  protected:
  explicit ExpressionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ExpressionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ExternallyLinkedResourceType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ExternallyLinkedResourceType) */ {
 public:
  inline ExternallyLinkedResourceType() : ExternallyLinkedResourceType(nullptr) {}
  virtual ~ExternallyLinkedResourceType();

  ExternallyLinkedResourceType(const ExternallyLinkedResourceType& from);
  ExternallyLinkedResourceType(ExternallyLinkedResourceType&& from) noexcept
    : ExternallyLinkedResourceType() {
    *this = ::std::move(from);
  }

  inline ExternallyLinkedResourceType& operator=(const ExternallyLinkedResourceType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternallyLinkedResourceType& operator=(ExternallyLinkedResourceType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExternallyLinkedResourceType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExternallyLinkedResourceType* internal_default_instance() {
    return reinterpret_cast<const ExternallyLinkedResourceType*>(
               &_ExternallyLinkedResourceType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ExternallyLinkedResourceType& a, ExternallyLinkedResourceType& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternallyLinkedResourceType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternallyLinkedResourceType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExternallyLinkedResourceType* New() const final {
    return CreateMaybeMessage<ExternallyLinkedResourceType>(nullptr);
  }

  ExternallyLinkedResourceType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExternallyLinkedResourceType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExternallyLinkedResourceType& from);
  void MergeFrom(const ExternallyLinkedResourceType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternallyLinkedResourceType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ExternallyLinkedResourceType";
  }
  protected:
  explicit ExternallyLinkedResourceType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ExternallyLinkedResourceType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class FingerprintAlgorithmType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.FingerprintAlgorithmType) */ {
 public:
  inline FingerprintAlgorithmType() : FingerprintAlgorithmType(nullptr) {}
  virtual ~FingerprintAlgorithmType();

  FingerprintAlgorithmType(const FingerprintAlgorithmType& from);
  FingerprintAlgorithmType(FingerprintAlgorithmType&& from) noexcept
    : FingerprintAlgorithmType() {
    *this = ::std::move(from);
  }

  inline FingerprintAlgorithmType& operator=(const FingerprintAlgorithmType& from) {
    CopyFrom(from);
    return *this;
  }
  inline FingerprintAlgorithmType& operator=(FingerprintAlgorithmType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FingerprintAlgorithmType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FingerprintAlgorithmType* internal_default_instance() {
    return reinterpret_cast<const FingerprintAlgorithmType*>(
               &_FingerprintAlgorithmType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(FingerprintAlgorithmType& a, FingerprintAlgorithmType& b) {
    a.Swap(&b);
  }
  inline void Swap(FingerprintAlgorithmType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FingerprintAlgorithmType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FingerprintAlgorithmType* New() const final {
    return CreateMaybeMessage<FingerprintAlgorithmType>(nullptr);
  }

  FingerprintAlgorithmType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FingerprintAlgorithmType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FingerprintAlgorithmType& from);
  void MergeFrom(const FingerprintAlgorithmType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FingerprintAlgorithmType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.FingerprintAlgorithmType";
  }
  protected:
  explicit FingerprintAlgorithmType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.FingerprintAlgorithmType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class FrameRate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.FrameRate) */ {
 public:
  inline FrameRate() : FrameRate(nullptr) {}
  virtual ~FrameRate();

  FrameRate(const FrameRate& from);
  FrameRate(FrameRate&& from) noexcept
    : FrameRate() {
    *this = ::std::move(from);
  }

  inline FrameRate& operator=(const FrameRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameRate& operator=(FrameRate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FrameRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameRate* internal_default_instance() {
    return reinterpret_cast<const FrameRate*>(
               &_FrameRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(FrameRate& a, FrameRate& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameRate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameRate* New() const final {
    return CreateMaybeMessage<FrameRate>(nullptr);
  }

  FrameRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameRate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FrameRate& from);
  void MergeFrom(const FrameRate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.FrameRate";
  }
  protected:
  explicit FrameRate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.FrameRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class HashSumAlgorithmType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.HashSumAlgorithmType) */ {
 public:
  inline HashSumAlgorithmType() : HashSumAlgorithmType(nullptr) {}
  virtual ~HashSumAlgorithmType();

  HashSumAlgorithmType(const HashSumAlgorithmType& from);
  HashSumAlgorithmType(HashSumAlgorithmType&& from) noexcept
    : HashSumAlgorithmType() {
    *this = ::std::move(from);
  }

  inline HashSumAlgorithmType& operator=(const HashSumAlgorithmType& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashSumAlgorithmType& operator=(HashSumAlgorithmType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HashSumAlgorithmType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HashSumAlgorithmType* internal_default_instance() {
    return reinterpret_cast<const HashSumAlgorithmType*>(
               &_HashSumAlgorithmType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(HashSumAlgorithmType& a, HashSumAlgorithmType& b) {
    a.Swap(&b);
  }
  inline void Swap(HashSumAlgorithmType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashSumAlgorithmType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HashSumAlgorithmType* New() const final {
    return CreateMaybeMessage<HashSumAlgorithmType>(nullptr);
  }

  HashSumAlgorithmType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HashSumAlgorithmType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HashSumAlgorithmType& from);
  void MergeFrom(const HashSumAlgorithmType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashSumAlgorithmType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.HashSumAlgorithmType";
  }
  protected:
  explicit HashSumAlgorithmType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.HashSumAlgorithmType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ImageCodecType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ImageCodecType) */ {
 public:
  inline ImageCodecType() : ImageCodecType(nullptr) {}
  virtual ~ImageCodecType();

  ImageCodecType(const ImageCodecType& from);
  ImageCodecType(ImageCodecType&& from) noexcept
    : ImageCodecType() {
    *this = ::std::move(from);
  }

  inline ImageCodecType& operator=(const ImageCodecType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageCodecType& operator=(ImageCodecType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageCodecType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageCodecType* internal_default_instance() {
    return reinterpret_cast<const ImageCodecType*>(
               &_ImageCodecType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ImageCodecType& a, ImageCodecType& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageCodecType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageCodecType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageCodecType* New() const final {
    return CreateMaybeMessage<ImageCodecType>(nullptr);
  }

  ImageCodecType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageCodecType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageCodecType& from);
  void MergeFrom(const ImageCodecType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageCodecType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ImageCodecType";
  }
  protected:
  explicit ImageCodecType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ImageCodecType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ImageType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ImageType) */ {
 public:
  inline ImageType() : ImageType(nullptr) {}
  virtual ~ImageType();

  ImageType(const ImageType& from);
  ImageType(ImageType&& from) noexcept
    : ImageType() {
    *this = ::std::move(from);
  }

  inline ImageType& operator=(const ImageType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageType& operator=(ImageType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageType* internal_default_instance() {
    return reinterpret_cast<const ImageType*>(
               &_ImageType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ImageType& a, ImageType& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageType* New() const final {
    return CreateMaybeMessage<ImageType>(nullptr);
  }

  ImageType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageType& from);
  void MergeFrom(const ImageType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ImageType";
  }
  protected:
  explicit ImageType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ImageType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class InstrumentType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.InstrumentType) */ {
 public:
  inline InstrumentType() : InstrumentType(nullptr) {}
  virtual ~InstrumentType();

  InstrumentType(const InstrumentType& from);
  InstrumentType(InstrumentType&& from) noexcept
    : InstrumentType() {
    *this = ::std::move(from);
  }

  inline InstrumentType& operator=(const InstrumentType& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentType& operator=(InstrumentType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InstrumentType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InstrumentType* internal_default_instance() {
    return reinterpret_cast<const InstrumentType*>(
               &_InstrumentType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(InstrumentType& a, InstrumentType& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstrumentType* New() const final {
    return CreateMaybeMessage<InstrumentType>(nullptr);
  }

  InstrumentType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstrumentType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InstrumentType& from);
  void MergeFrom(const InstrumentType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.InstrumentType";
  }
  protected:
  explicit InstrumentType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.InstrumentType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class IsoLanguageCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.IsoLanguageCode) */ {
 public:
  inline IsoLanguageCode() : IsoLanguageCode(nullptr) {}
  virtual ~IsoLanguageCode();

  IsoLanguageCode(const IsoLanguageCode& from);
  IsoLanguageCode(IsoLanguageCode&& from) noexcept
    : IsoLanguageCode() {
    *this = ::std::move(from);
  }

  inline IsoLanguageCode& operator=(const IsoLanguageCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsoLanguageCode& operator=(IsoLanguageCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IsoLanguageCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsoLanguageCode* internal_default_instance() {
    return reinterpret_cast<const IsoLanguageCode*>(
               &_IsoLanguageCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(IsoLanguageCode& a, IsoLanguageCode& b) {
    a.Swap(&b);
  }
  inline void Swap(IsoLanguageCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsoLanguageCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IsoLanguageCode* New() const final {
    return CreateMaybeMessage<IsoLanguageCode>(nullptr);
  }

  IsoLanguageCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IsoLanguageCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IsoLanguageCode& from);
  void MergeFrom(const IsoLanguageCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsoLanguageCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.IsoLanguageCode";
  }
  protected:
  explicit IsoLanguageCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.IsoLanguageCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class LabelType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.LabelType) */ {
 public:
  inline LabelType() : LabelType(nullptr) {}
  virtual ~LabelType();

  LabelType(const LabelType& from);
  LabelType(LabelType&& from) noexcept
    : LabelType() {
    *this = ::std::move(from);
  }

  inline LabelType& operator=(const LabelType& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelType& operator=(LabelType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LabelType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LabelType* internal_default_instance() {
    return reinterpret_cast<const LabelType*>(
               &_LabelType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(LabelType& a, LabelType& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LabelType* New() const final {
    return CreateMaybeMessage<LabelType>(nullptr);
  }

  LabelType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LabelType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LabelType& from);
  void MergeFrom(const LabelType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.LabelType";
  }
  protected:
  explicit LabelType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.LabelType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class LinkDescription PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.LinkDescription) */ {
 public:
  inline LinkDescription() : LinkDescription(nullptr) {}
  virtual ~LinkDescription();

  LinkDescription(const LinkDescription& from);
  LinkDescription(LinkDescription&& from) noexcept
    : LinkDescription() {
    *this = ::std::move(from);
  }

  inline LinkDescription& operator=(const LinkDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinkDescription& operator=(LinkDescription&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LinkDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinkDescription* internal_default_instance() {
    return reinterpret_cast<const LinkDescription*>(
               &_LinkDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(LinkDescription& a, LinkDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(LinkDescription* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinkDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LinkDescription* New() const final {
    return CreateMaybeMessage<LinkDescription>(nullptr);
  }

  LinkDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LinkDescription>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LinkDescription& from);
  void MergeFrom(const LinkDescription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkDescription* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.LinkDescription";
  }
  protected:
  explicit LinkDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.LinkDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class MessageControlType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.MessageControlType) */ {
 public:
  inline MessageControlType() : MessageControlType(nullptr) {}
  virtual ~MessageControlType();

  MessageControlType(const MessageControlType& from);
  MessageControlType(MessageControlType&& from) noexcept
    : MessageControlType() {
    *this = ::std::move(from);
  }

  inline MessageControlType& operator=(const MessageControlType& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageControlType& operator=(MessageControlType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessageControlType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageControlType* internal_default_instance() {
    return reinterpret_cast<const MessageControlType*>(
               &_MessageControlType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(MessageControlType& a, MessageControlType& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageControlType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageControlType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageControlType* New() const final {
    return CreateMaybeMessage<MessageControlType>(nullptr);
  }

  MessageControlType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageControlType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessageControlType& from);
  void MergeFrom(const MessageControlType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageControlType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.MessageControlType";
  }
  protected:
  explicit MessageControlType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.MessageControlType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class OperatingSystemType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.OperatingSystemType) */ {
 public:
  inline OperatingSystemType() : OperatingSystemType(nullptr) {}
  virtual ~OperatingSystemType();

  OperatingSystemType(const OperatingSystemType& from);
  OperatingSystemType(OperatingSystemType&& from) noexcept
    : OperatingSystemType() {
    *this = ::std::move(from);
  }

  inline OperatingSystemType& operator=(const OperatingSystemType& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperatingSystemType& operator=(OperatingSystemType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OperatingSystemType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperatingSystemType* internal_default_instance() {
    return reinterpret_cast<const OperatingSystemType*>(
               &_OperatingSystemType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(OperatingSystemType& a, OperatingSystemType& b) {
    a.Swap(&b);
  }
  inline void Swap(OperatingSystemType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperatingSystemType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OperatingSystemType* New() const final {
    return CreateMaybeMessage<OperatingSystemType>(nullptr);
  }

  OperatingSystemType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OperatingSystemType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OperatingSystemType& from);
  void MergeFrom(const OperatingSystemType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperatingSystemType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.OperatingSystemType";
  }
  protected:
  explicit OperatingSystemType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.OperatingSystemType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class PLineType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.PLineType) */ {
 public:
  inline PLineType() : PLineType(nullptr) {}
  virtual ~PLineType();

  PLineType(const PLineType& from);
  PLineType(PLineType&& from) noexcept
    : PLineType() {
    *this = ::std::move(from);
  }

  inline PLineType& operator=(const PLineType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PLineType& operator=(PLineType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PLineType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PLineType* internal_default_instance() {
    return reinterpret_cast<const PLineType*>(
               &_PLineType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(PLineType& a, PLineType& b) {
    a.Swap(&b);
  }
  inline void Swap(PLineType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PLineType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PLineType* New() const final {
    return CreateMaybeMessage<PLineType>(nullptr);
  }

  PLineType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PLineType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PLineType& from);
  void MergeFrom(const PLineType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PLineType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.PLineType";
  }
  protected:
  explicit PLineType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.PLineType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ParentalWarningType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ParentalWarningType) */ {
 public:
  inline ParentalWarningType() : ParentalWarningType(nullptr) {}
  virtual ~ParentalWarningType();

  ParentalWarningType(const ParentalWarningType& from);
  ParentalWarningType(ParentalWarningType&& from) noexcept
    : ParentalWarningType() {
    *this = ::std::move(from);
  }

  inline ParentalWarningType& operator=(const ParentalWarningType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParentalWarningType& operator=(ParentalWarningType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ParentalWarningType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParentalWarningType* internal_default_instance() {
    return reinterpret_cast<const ParentalWarningType*>(
               &_ParentalWarningType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ParentalWarningType& a, ParentalWarningType& b) {
    a.Swap(&b);
  }
  inline void Swap(ParentalWarningType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParentalWarningType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ParentalWarningType* New() const final {
    return CreateMaybeMessage<ParentalWarningType>(nullptr);
  }

  ParentalWarningType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ParentalWarningType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ParentalWarningType& from);
  void MergeFrom(const ParentalWarningType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParentalWarningType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ParentalWarningType";
  }
  protected:
  explicit ParentalWarningType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ParentalWarningType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class PartyRelationshipType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.PartyRelationshipType) */ {
 public:
  inline PartyRelationshipType() : PartyRelationshipType(nullptr) {}
  virtual ~PartyRelationshipType();

  PartyRelationshipType(const PartyRelationshipType& from);
  PartyRelationshipType(PartyRelationshipType&& from) noexcept
    : PartyRelationshipType() {
    *this = ::std::move(from);
  }

  inline PartyRelationshipType& operator=(const PartyRelationshipType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyRelationshipType& operator=(PartyRelationshipType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyRelationshipType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartyRelationshipType* internal_default_instance() {
    return reinterpret_cast<const PartyRelationshipType*>(
               &_PartyRelationshipType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(PartyRelationshipType& a, PartyRelationshipType& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyRelationshipType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyRelationshipType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyRelationshipType* New() const final {
    return CreateMaybeMessage<PartyRelationshipType>(nullptr);
  }

  PartyRelationshipType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyRelationshipType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyRelationshipType& from);
  void MergeFrom(const PartyRelationshipType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyRelationshipType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.PartyRelationshipType";
  }
  protected:
  explicit PartyRelationshipType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.PartyRelationshipType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class Period PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.Period) */ {
 public:
  inline Period() : Period(nullptr) {}
  virtual ~Period();

  Period(const Period& from);
  Period(Period&& from) noexcept
    : Period() {
    *this = ::std::move(from);
  }

  inline Period& operator=(const Period& from) {
    CopyFrom(from);
    return *this;
  }
  inline Period& operator=(Period&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Period& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Period* internal_default_instance() {
    return reinterpret_cast<const Period*>(
               &_Period_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Period& a, Period& b) {
    a.Swap(&b);
  }
  inline void Swap(Period* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Period* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Period* New() const final {
    return CreateMaybeMessage<Period>(nullptr);
  }

  Period* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Period>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Period& from);
  void MergeFrom(const Period& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Period* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.Period";
  }
  protected:
  explicit Period(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.Period)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class PriceInformationType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.PriceInformationType) */ {
 public:
  inline PriceInformationType() : PriceInformationType(nullptr) {}
  virtual ~PriceInformationType();

  PriceInformationType(const PriceInformationType& from);
  PriceInformationType(PriceInformationType&& from) noexcept
    : PriceInformationType() {
    *this = ::std::move(from);
  }

  inline PriceInformationType& operator=(const PriceInformationType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceInformationType& operator=(PriceInformationType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PriceInformationType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PriceInformationType* internal_default_instance() {
    return reinterpret_cast<const PriceInformationType*>(
               &_PriceInformationType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(PriceInformationType& a, PriceInformationType& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceInformationType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceInformationType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PriceInformationType* New() const final {
    return CreateMaybeMessage<PriceInformationType>(nullptr);
  }

  PriceInformationType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PriceInformationType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PriceInformationType& from);
  void MergeFrom(const PriceInformationType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceInformationType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.PriceInformationType";
  }
  protected:
  explicit PriceInformationType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.PriceInformationType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class PriceType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.PriceType) */ {
 public:
  inline PriceType() : PriceType(nullptr) {}
  virtual ~PriceType();

  PriceType(const PriceType& from);
  PriceType(PriceType&& from) noexcept
    : PriceType() {
    *this = ::std::move(from);
  }

  inline PriceType& operator=(const PriceType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceType& operator=(PriceType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PriceType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PriceType* internal_default_instance() {
    return reinterpret_cast<const PriceType*>(
               &_PriceType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(PriceType& a, PriceType& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PriceType* New() const final {
    return CreateMaybeMessage<PriceType>(nullptr);
  }

  PriceType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PriceType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PriceType& from);
  void MergeFrom(const PriceType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.PriceType";
  }
  protected:
  explicit PriceType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAutoValueFieldNumber = 1,
  };
  // optional string auto_value = 1;
  bool has_auto_value() const;
  private:
  bool _internal_has_auto_value() const;
  public:
  void clear_auto_value();
  const std::string& auto_value() const;
  void set_auto_value(const std::string& value);
  void set_auto_value(std::string&& value);
  void set_auto_value(const char* value);
  void set_auto_value(const char* value, size_t size);
  std::string* mutable_auto_value();
  std::string* release_auto_value();
  void set_allocated_auto_value(std::string* auto_value);
  private:
  const std::string& _internal_auto_value() const;
  void _internal_set_auto_value(const std::string& value);
  std::string* _internal_mutable_auto_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.PriceType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auto_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class Purpose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.Purpose) */ {
 public:
  inline Purpose() : Purpose(nullptr) {}
  virtual ~Purpose();

  Purpose(const Purpose& from);
  Purpose(Purpose&& from) noexcept
    : Purpose() {
    *this = ::std::move(from);
  }

  inline Purpose& operator=(const Purpose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Purpose& operator=(Purpose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Purpose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Purpose* internal_default_instance() {
    return reinterpret_cast<const Purpose*>(
               &_Purpose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Purpose& a, Purpose& b) {
    a.Swap(&b);
  }
  inline void Swap(Purpose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Purpose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Purpose* New() const final {
    return CreateMaybeMessage<Purpose>(nullptr);
  }

  Purpose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Purpose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Purpose& from);
  void MergeFrom(const Purpose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Purpose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.Purpose";
  }
  protected:
  explicit Purpose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.Purpose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class RatingAgency PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.RatingAgency) */ {
 public:
  inline RatingAgency() : RatingAgency(nullptr) {}
  virtual ~RatingAgency();

  RatingAgency(const RatingAgency& from);
  RatingAgency(RatingAgency&& from) noexcept
    : RatingAgency() {
    *this = ::std::move(from);
  }

  inline RatingAgency& operator=(const RatingAgency& from) {
    CopyFrom(from);
    return *this;
  }
  inline RatingAgency& operator=(RatingAgency&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RatingAgency& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RatingAgency* internal_default_instance() {
    return reinterpret_cast<const RatingAgency*>(
               &_RatingAgency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(RatingAgency& a, RatingAgency& b) {
    a.Swap(&b);
  }
  inline void Swap(RatingAgency* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RatingAgency* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RatingAgency* New() const final {
    return CreateMaybeMessage<RatingAgency>(nullptr);
  }

  RatingAgency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RatingAgency>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RatingAgency& from);
  void MergeFrom(const RatingAgency& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RatingAgency* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.RatingAgency";
  }
  protected:
  explicit RatingAgency(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.RatingAgency)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class RatingReason PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.RatingReason) */ {
 public:
  inline RatingReason() : RatingReason(nullptr) {}
  virtual ~RatingReason();

  RatingReason(const RatingReason& from);
  RatingReason(RatingReason&& from) noexcept
    : RatingReason() {
    *this = ::std::move(from);
  }

  inline RatingReason& operator=(const RatingReason& from) {
    CopyFrom(from);
    return *this;
  }
  inline RatingReason& operator=(RatingReason&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RatingReason& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RatingReason* internal_default_instance() {
    return reinterpret_cast<const RatingReason*>(
               &_RatingReason_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(RatingReason& a, RatingReason& b) {
    a.Swap(&b);
  }
  inline void Swap(RatingReason* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RatingReason* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RatingReason* New() const final {
    return CreateMaybeMessage<RatingReason>(nullptr);
  }

  RatingReason* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RatingReason>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RatingReason& from);
  void MergeFrom(const RatingReason& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RatingReason* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.RatingReason";
  }
  protected:
  explicit RatingReason(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.RatingReason)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class RecordingMode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.RecordingMode) */ {
 public:
  inline RecordingMode() : RecordingMode(nullptr) {}
  virtual ~RecordingMode();

  RecordingMode(const RecordingMode& from);
  RecordingMode(RecordingMode&& from) noexcept
    : RecordingMode() {
    *this = ::std::move(from);
  }

  inline RecordingMode& operator=(const RecordingMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordingMode& operator=(RecordingMode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecordingMode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordingMode* internal_default_instance() {
    return reinterpret_cast<const RecordingMode*>(
               &_RecordingMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(RecordingMode& a, RecordingMode& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordingMode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordingMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecordingMode* New() const final {
    return CreateMaybeMessage<RecordingMode>(nullptr);
  }

  RecordingMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecordingMode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecordingMode& from);
  void MergeFrom(const RecordingMode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordingMode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.RecordingMode";
  }
  protected:
  explicit RecordingMode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.RecordingMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReferenceCreation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ReferenceCreation) */ {
 public:
  inline ReferenceCreation() : ReferenceCreation(nullptr) {}
  virtual ~ReferenceCreation();

  ReferenceCreation(const ReferenceCreation& from);
  ReferenceCreation(ReferenceCreation&& from) noexcept
    : ReferenceCreation() {
    *this = ::std::move(from);
  }

  inline ReferenceCreation& operator=(const ReferenceCreation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceCreation& operator=(ReferenceCreation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReferenceCreation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReferenceCreation* internal_default_instance() {
    return reinterpret_cast<const ReferenceCreation*>(
               &_ReferenceCreation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ReferenceCreation& a, ReferenceCreation& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceCreation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceCreation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReferenceCreation* New() const final {
    return CreateMaybeMessage<ReferenceCreation>(nullptr);
  }

  ReferenceCreation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceCreation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReferenceCreation& from);
  void MergeFrom(const ReferenceCreation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceCreation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ReferenceCreation";
  }
  protected:
  explicit ReferenceCreation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ReferenceCreation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class RelationalRelator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.RelationalRelator) */ {
 public:
  inline RelationalRelator() : RelationalRelator(nullptr) {}
  virtual ~RelationalRelator();

  RelationalRelator(const RelationalRelator& from);
  RelationalRelator(RelationalRelator&& from) noexcept
    : RelationalRelator() {
    *this = ::std::move(from);
  }

  inline RelationalRelator& operator=(const RelationalRelator& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationalRelator& operator=(RelationalRelator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RelationalRelator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelationalRelator* internal_default_instance() {
    return reinterpret_cast<const RelationalRelator*>(
               &_RelationalRelator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(RelationalRelator& a, RelationalRelator& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationalRelator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationalRelator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelationalRelator* New() const final {
    return CreateMaybeMessage<RelationalRelator>(nullptr);
  }

  RelationalRelator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelationalRelator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RelationalRelator& from);
  void MergeFrom(const RelationalRelator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationalRelator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.RelationalRelator";
  }
  protected:
  explicit RelationalRelator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.RelationalRelator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseProfileVariantVersionId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ReleaseProfileVariantVersionId) */ {
 public:
  inline ReleaseProfileVariantVersionId() : ReleaseProfileVariantVersionId(nullptr) {}
  virtual ~ReleaseProfileVariantVersionId();

  ReleaseProfileVariantVersionId(const ReleaseProfileVariantVersionId& from);
  ReleaseProfileVariantVersionId(ReleaseProfileVariantVersionId&& from) noexcept
    : ReleaseProfileVariantVersionId() {
    *this = ::std::move(from);
  }

  inline ReleaseProfileVariantVersionId& operator=(const ReleaseProfileVariantVersionId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseProfileVariantVersionId& operator=(ReleaseProfileVariantVersionId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReleaseProfileVariantVersionId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseProfileVariantVersionId* internal_default_instance() {
    return reinterpret_cast<const ReleaseProfileVariantVersionId*>(
               &_ReleaseProfileVariantVersionId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ReleaseProfileVariantVersionId& a, ReleaseProfileVariantVersionId& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseProfileVariantVersionId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseProfileVariantVersionId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseProfileVariantVersionId* New() const final {
    return CreateMaybeMessage<ReleaseProfileVariantVersionId>(nullptr);
  }

  ReleaseProfileVariantVersionId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseProfileVariantVersionId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReleaseProfileVariantVersionId& from);
  void MergeFrom(const ReleaseProfileVariantVersionId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseProfileVariantVersionId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ReleaseProfileVariantVersionId";
  }
  protected:
  explicit ReleaseProfileVariantVersionId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ReleaseProfileVariantVersionId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseProfileVersionId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ReleaseProfileVersionId) */ {
 public:
  inline ReleaseProfileVersionId() : ReleaseProfileVersionId(nullptr) {}
  virtual ~ReleaseProfileVersionId();

  ReleaseProfileVersionId(const ReleaseProfileVersionId& from);
  ReleaseProfileVersionId(ReleaseProfileVersionId&& from) noexcept
    : ReleaseProfileVersionId() {
    *this = ::std::move(from);
  }

  inline ReleaseProfileVersionId& operator=(const ReleaseProfileVersionId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseProfileVersionId& operator=(ReleaseProfileVersionId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReleaseProfileVersionId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseProfileVersionId* internal_default_instance() {
    return reinterpret_cast<const ReleaseProfileVersionId*>(
               &_ReleaseProfileVersionId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ReleaseProfileVersionId& a, ReleaseProfileVersionId& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseProfileVersionId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseProfileVersionId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseProfileVersionId* New() const final {
    return CreateMaybeMessage<ReleaseProfileVersionId>(nullptr);
  }

  ReleaseProfileVersionId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseProfileVersionId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReleaseProfileVersionId& from);
  void MergeFrom(const ReleaseProfileVersionId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseProfileVersionId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ReleaseProfileVersionId";
  }
  protected:
  explicit ReleaseProfileVersionId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ReleaseProfileVersionId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseRelationshipType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ReleaseRelationshipType) */ {
 public:
  inline ReleaseRelationshipType() : ReleaseRelationshipType(nullptr) {}
  virtual ~ReleaseRelationshipType();

  ReleaseRelationshipType(const ReleaseRelationshipType& from);
  ReleaseRelationshipType(ReleaseRelationshipType&& from) noexcept
    : ReleaseRelationshipType() {
    *this = ::std::move(from);
  }

  inline ReleaseRelationshipType& operator=(const ReleaseRelationshipType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseRelationshipType& operator=(ReleaseRelationshipType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReleaseRelationshipType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseRelationshipType* internal_default_instance() {
    return reinterpret_cast<const ReleaseRelationshipType*>(
               &_ReleaseRelationshipType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ReleaseRelationshipType& a, ReleaseRelationshipType& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseRelationshipType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseRelationshipType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseRelationshipType* New() const final {
    return CreateMaybeMessage<ReleaseRelationshipType>(nullptr);
  }

  ReleaseRelationshipType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseRelationshipType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReleaseRelationshipType& from);
  void MergeFrom(const ReleaseRelationshipType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseRelationshipType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ReleaseRelationshipType";
  }
  protected:
  explicit ReleaseRelationshipType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ReleaseRelationshipType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseType_ERN4 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ReleaseType_ERN4) */ {
 public:
  inline ReleaseType_ERN4() : ReleaseType_ERN4(nullptr) {}
  virtual ~ReleaseType_ERN4();

  ReleaseType_ERN4(const ReleaseType_ERN4& from);
  ReleaseType_ERN4(ReleaseType_ERN4&& from) noexcept
    : ReleaseType_ERN4() {
    *this = ::std::move(from);
  }

  inline ReleaseType_ERN4& operator=(const ReleaseType_ERN4& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseType_ERN4& operator=(ReleaseType_ERN4&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReleaseType_ERN4& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseType_ERN4* internal_default_instance() {
    return reinterpret_cast<const ReleaseType_ERN4*>(
               &_ReleaseType_ERN4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ReleaseType_ERN4& a, ReleaseType_ERN4& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseType_ERN4* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseType_ERN4* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseType_ERN4* New() const final {
    return CreateMaybeMessage<ReleaseType_ERN4>(nullptr);
  }

  ReleaseType_ERN4* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseType_ERN4>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReleaseType_ERN4& from);
  void MergeFrom(const ReleaseType_ERN4& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseType_ERN4* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ReleaseType_ERN4";
  }
  protected:
  explicit ReleaseType_ERN4(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ReleaseType_ERN4)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ResourceGroupType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ResourceGroupType) */ {
 public:
  inline ResourceGroupType() : ResourceGroupType(nullptr) {}
  virtual ~ResourceGroupType();

  ResourceGroupType(const ResourceGroupType& from);
  ResourceGroupType(ResourceGroupType&& from) noexcept
    : ResourceGroupType() {
    *this = ::std::move(from);
  }

  inline ResourceGroupType& operator=(const ResourceGroupType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceGroupType& operator=(ResourceGroupType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResourceGroupType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceGroupType* internal_default_instance() {
    return reinterpret_cast<const ResourceGroupType*>(
               &_ResourceGroupType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ResourceGroupType& a, ResourceGroupType& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceGroupType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceGroupType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceGroupType* New() const final {
    return CreateMaybeMessage<ResourceGroupType>(nullptr);
  }

  ResourceGroupType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceGroupType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResourceGroupType& from);
  void MergeFrom(const ResourceGroupType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceGroupType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ResourceGroupType";
  }
  protected:
  explicit ResourceGroupType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ResourceGroupType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ResourceRelationshipType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ResourceRelationshipType) */ {
 public:
  inline ResourceRelationshipType() : ResourceRelationshipType(nullptr) {}
  virtual ~ResourceRelationshipType();

  ResourceRelationshipType(const ResourceRelationshipType& from);
  ResourceRelationshipType(ResourceRelationshipType&& from) noexcept
    : ResourceRelationshipType() {
    *this = ::std::move(from);
  }

  inline ResourceRelationshipType& operator=(const ResourceRelationshipType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceRelationshipType& operator=(ResourceRelationshipType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResourceRelationshipType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceRelationshipType* internal_default_instance() {
    return reinterpret_cast<const ResourceRelationshipType*>(
               &_ResourceRelationshipType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(ResourceRelationshipType& a, ResourceRelationshipType& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceRelationshipType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceRelationshipType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceRelationshipType* New() const final {
    return CreateMaybeMessage<ResourceRelationshipType>(nullptr);
  }

  ResourceRelationshipType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceRelationshipType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResourceRelationshipType& from);
  void MergeFrom(const ResourceRelationshipType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceRelationshipType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ResourceRelationshipType";
  }
  protected:
  explicit ResourceRelationshipType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ResourceRelationshipType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class RightsClaimPolicyType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.RightsClaimPolicyType) */ {
 public:
  inline RightsClaimPolicyType() : RightsClaimPolicyType(nullptr) {}
  virtual ~RightsClaimPolicyType();

  RightsClaimPolicyType(const RightsClaimPolicyType& from);
  RightsClaimPolicyType(RightsClaimPolicyType&& from) noexcept
    : RightsClaimPolicyType() {
    *this = ::std::move(from);
  }

  inline RightsClaimPolicyType& operator=(const RightsClaimPolicyType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightsClaimPolicyType& operator=(RightsClaimPolicyType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightsClaimPolicyType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightsClaimPolicyType* internal_default_instance() {
    return reinterpret_cast<const RightsClaimPolicyType*>(
               &_RightsClaimPolicyType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(RightsClaimPolicyType& a, RightsClaimPolicyType& b) {
    a.Swap(&b);
  }
  inline void Swap(RightsClaimPolicyType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightsClaimPolicyType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightsClaimPolicyType* New() const final {
    return CreateMaybeMessage<RightsClaimPolicyType>(nullptr);
  }

  RightsClaimPolicyType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightsClaimPolicyType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightsClaimPolicyType& from);
  void MergeFrom(const RightsClaimPolicyType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightsClaimPolicyType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.RightsClaimPolicyType";
  }
  protected:
  explicit RightsClaimPolicyType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.RightsClaimPolicyType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class RightsControllerRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.RightsControllerRole) */ {
 public:
  inline RightsControllerRole() : RightsControllerRole(nullptr) {}
  virtual ~RightsControllerRole();

  RightsControllerRole(const RightsControllerRole& from);
  RightsControllerRole(RightsControllerRole&& from) noexcept
    : RightsControllerRole() {
    *this = ::std::move(from);
  }

  inline RightsControllerRole& operator=(const RightsControllerRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightsControllerRole& operator=(RightsControllerRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightsControllerRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightsControllerRole* internal_default_instance() {
    return reinterpret_cast<const RightsControllerRole*>(
               &_RightsControllerRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(RightsControllerRole& a, RightsControllerRole& b) {
    a.Swap(&b);
  }
  inline void Swap(RightsControllerRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightsControllerRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightsControllerRole* New() const final {
    return CreateMaybeMessage<RightsControllerRole>(nullptr);
  }

  RightsControllerRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightsControllerRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightsControllerRole& from);
  void MergeFrom(const RightsControllerRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightsControllerRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.RightsControllerRole";
  }
  protected:
  explicit RightsControllerRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.RightsControllerRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class RightsControllerType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.RightsControllerType) */ {
 public:
  inline RightsControllerType() : RightsControllerType(nullptr) {}
  virtual ~RightsControllerType();

  RightsControllerType(const RightsControllerType& from);
  RightsControllerType(RightsControllerType&& from) noexcept
    : RightsControllerType() {
    *this = ::std::move(from);
  }

  inline RightsControllerType& operator=(const RightsControllerType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightsControllerType& operator=(RightsControllerType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightsControllerType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightsControllerType* internal_default_instance() {
    return reinterpret_cast<const RightsControllerType*>(
               &_RightsControllerType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(RightsControllerType& a, RightsControllerType& b) {
    a.Swap(&b);
  }
  inline void Swap(RightsControllerType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightsControllerType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightsControllerType* New() const final {
    return CreateMaybeMessage<RightsControllerType>(nullptr);
  }

  RightsControllerType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightsControllerType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightsControllerType& from);
  void MergeFrom(const RightsControllerType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightsControllerType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.RightsControllerType";
  }
  protected:
  explicit RightsControllerType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.RightsControllerType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class RightsCoverage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.RightsCoverage) */ {
 public:
  inline RightsCoverage() : RightsCoverage(nullptr) {}
  virtual ~RightsCoverage();

  RightsCoverage(const RightsCoverage& from);
  RightsCoverage(RightsCoverage&& from) noexcept
    : RightsCoverage() {
    *this = ::std::move(from);
  }

  inline RightsCoverage& operator=(const RightsCoverage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightsCoverage& operator=(RightsCoverage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightsCoverage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightsCoverage* internal_default_instance() {
    return reinterpret_cast<const RightsCoverage*>(
               &_RightsCoverage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(RightsCoverage& a, RightsCoverage& b) {
    a.Swap(&b);
  }
  inline void Swap(RightsCoverage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightsCoverage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightsCoverage* New() const final {
    return CreateMaybeMessage<RightsCoverage>(nullptr);
  }

  RightsCoverage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightsCoverage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightsCoverage& from);
  void MergeFrom(const RightsCoverage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightsCoverage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.RightsCoverage";
  }
  protected:
  explicit RightsCoverage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.RightsCoverage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class SheetMusicCodecType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.SheetMusicCodecType) */ {
 public:
  inline SheetMusicCodecType() : SheetMusicCodecType(nullptr) {}
  virtual ~SheetMusicCodecType();

  SheetMusicCodecType(const SheetMusicCodecType& from);
  SheetMusicCodecType(SheetMusicCodecType&& from) noexcept
    : SheetMusicCodecType() {
    *this = ::std::move(from);
  }

  inline SheetMusicCodecType& operator=(const SheetMusicCodecType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SheetMusicCodecType& operator=(SheetMusicCodecType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SheetMusicCodecType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SheetMusicCodecType* internal_default_instance() {
    return reinterpret_cast<const SheetMusicCodecType*>(
               &_SheetMusicCodecType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(SheetMusicCodecType& a, SheetMusicCodecType& b) {
    a.Swap(&b);
  }
  inline void Swap(SheetMusicCodecType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SheetMusicCodecType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SheetMusicCodecType* New() const final {
    return CreateMaybeMessage<SheetMusicCodecType>(nullptr);
  }

  SheetMusicCodecType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SheetMusicCodecType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SheetMusicCodecType& from);
  void MergeFrom(const SheetMusicCodecType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SheetMusicCodecType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.SheetMusicCodecType";
  }
  protected:
  explicit SheetMusicCodecType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAutoValueFieldNumber = 1,
  };
  // optional string auto_value = 1;
  bool has_auto_value() const;
  private:
  bool _internal_has_auto_value() const;
  public:
  void clear_auto_value();
  const std::string& auto_value() const;
  void set_auto_value(const std::string& value);
  void set_auto_value(std::string&& value);
  void set_auto_value(const char* value);
  void set_auto_value(const char* value, size_t size);
  std::string* mutable_auto_value();
  std::string* release_auto_value();
  void set_allocated_auto_value(std::string* auto_value);
  private:
  const std::string& _internal_auto_value() const;
  void _internal_set_auto_value(const std::string& value);
  std::string* _internal_mutable_auto_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.SheetMusicCodecType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auto_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class SheetMusicType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.SheetMusicType) */ {
 public:
  inline SheetMusicType() : SheetMusicType(nullptr) {}
  virtual ~SheetMusicType();

  SheetMusicType(const SheetMusicType& from);
  SheetMusicType(SheetMusicType&& from) noexcept
    : SheetMusicType() {
    *this = ::std::move(from);
  }

  inline SheetMusicType& operator=(const SheetMusicType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SheetMusicType& operator=(SheetMusicType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SheetMusicType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SheetMusicType* internal_default_instance() {
    return reinterpret_cast<const SheetMusicType*>(
               &_SheetMusicType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(SheetMusicType& a, SheetMusicType& b) {
    a.Swap(&b);
  }
  inline void Swap(SheetMusicType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SheetMusicType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SheetMusicType* New() const final {
    return CreateMaybeMessage<SheetMusicType>(nullptr);
  }

  SheetMusicType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SheetMusicType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SheetMusicType& from);
  void MergeFrom(const SheetMusicType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SheetMusicType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.SheetMusicType";
  }
  protected:
  explicit SheetMusicType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAutoValueFieldNumber = 1,
  };
  // optional string auto_value = 1;
  bool has_auto_value() const;
  private:
  bool _internal_has_auto_value() const;
  public:
  void clear_auto_value();
  const std::string& auto_value() const;
  void set_auto_value(const std::string& value);
  void set_auto_value(std::string&& value);
  void set_auto_value(const char* value);
  void set_auto_value(const char* value, size_t size);
  std::string* mutable_auto_value();
  std::string* release_auto_value();
  void set_allocated_auto_value(std::string* auto_value);
  private:
  const std::string& _internal_auto_value() const;
  void _internal_set_auto_value(const std::string& value);
  std::string* _internal_mutable_auto_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.SheetMusicType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auto_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class SoftwareType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.SoftwareType) */ {
 public:
  inline SoftwareType() : SoftwareType(nullptr) {}
  virtual ~SoftwareType();

  SoftwareType(const SoftwareType& from);
  SoftwareType(SoftwareType&& from) noexcept
    : SoftwareType() {
    *this = ::std::move(from);
  }

  inline SoftwareType& operator=(const SoftwareType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoftwareType& operator=(SoftwareType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SoftwareType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SoftwareType* internal_default_instance() {
    return reinterpret_cast<const SoftwareType*>(
               &_SoftwareType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(SoftwareType& a, SoftwareType& b) {
    a.Swap(&b);
  }
  inline void Swap(SoftwareType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoftwareType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SoftwareType* New() const final {
    return CreateMaybeMessage<SoftwareType>(nullptr);
  }

  SoftwareType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SoftwareType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SoftwareType& from);
  void MergeFrom(const SoftwareType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoftwareType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.SoftwareType";
  }
  protected:
  explicit SoftwareType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.SoftwareType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class SoundRecordingType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.SoundRecordingType) */ {
 public:
  inline SoundRecordingType() : SoundRecordingType(nullptr) {}
  virtual ~SoundRecordingType();

  SoundRecordingType(const SoundRecordingType& from);
  SoundRecordingType(SoundRecordingType&& from) noexcept
    : SoundRecordingType() {
    *this = ::std::move(from);
  }

  inline SoundRecordingType& operator=(const SoundRecordingType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoundRecordingType& operator=(SoundRecordingType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SoundRecordingType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SoundRecordingType* internal_default_instance() {
    return reinterpret_cast<const SoundRecordingType*>(
               &_SoundRecordingType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(SoundRecordingType& a, SoundRecordingType& b) {
    a.Swap(&b);
  }
  inline void Swap(SoundRecordingType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoundRecordingType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SoundRecordingType* New() const final {
    return CreateMaybeMessage<SoundRecordingType>(nullptr);
  }

  SoundRecordingType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SoundRecordingType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SoundRecordingType& from);
  void MergeFrom(const SoundRecordingType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoundRecordingType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.SoundRecordingType";
  }
  protected:
  explicit SoundRecordingType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.SoundRecordingType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class SubTitleType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.SubTitleType) */ {
 public:
  inline SubTitleType() : SubTitleType(nullptr) {}
  virtual ~SubTitleType();

  SubTitleType(const SubTitleType& from);
  SubTitleType(SubTitleType&& from) noexcept
    : SubTitleType() {
    *this = ::std::move(from);
  }

  inline SubTitleType& operator=(const SubTitleType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubTitleType& operator=(SubTitleType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubTitleType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubTitleType* internal_default_instance() {
    return reinterpret_cast<const SubTitleType*>(
               &_SubTitleType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(SubTitleType& a, SubTitleType& b) {
    a.Swap(&b);
  }
  inline void Swap(SubTitleType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubTitleType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubTitleType* New() const final {
    return CreateMaybeMessage<SubTitleType>(nullptr);
  }

  SubTitleType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubTitleType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubTitleType& from);
  void MergeFrom(const SubTitleType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubTitleType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.SubTitleType";
  }
  protected:
  explicit SubTitleType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.SubTitleType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class TerritoryCodeType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.TerritoryCodeType) */ {
 public:
  inline TerritoryCodeType() : TerritoryCodeType(nullptr) {}
  virtual ~TerritoryCodeType();

  TerritoryCodeType(const TerritoryCodeType& from);
  TerritoryCodeType(TerritoryCodeType&& from) noexcept
    : TerritoryCodeType() {
    *this = ::std::move(from);
  }

  inline TerritoryCodeType& operator=(const TerritoryCodeType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerritoryCodeType& operator=(TerritoryCodeType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TerritoryCodeType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TerritoryCodeType* internal_default_instance() {
    return reinterpret_cast<const TerritoryCodeType*>(
               &_TerritoryCodeType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(TerritoryCodeType& a, TerritoryCodeType& b) {
    a.Swap(&b);
  }
  inline void Swap(TerritoryCodeType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerritoryCodeType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TerritoryCodeType* New() const final {
    return CreateMaybeMessage<TerritoryCodeType>(nullptr);
  }

  TerritoryCodeType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TerritoryCodeType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TerritoryCodeType& from);
  void MergeFrom(const TerritoryCodeType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerritoryCodeType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.TerritoryCodeType";
  }
  protected:
  explicit TerritoryCodeType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.TerritoryCodeType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class TerritoryCodeTypeIncludingDeprecatedCodes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.TerritoryCodeTypeIncludingDeprecatedCodes) */ {
 public:
  inline TerritoryCodeTypeIncludingDeprecatedCodes() : TerritoryCodeTypeIncludingDeprecatedCodes(nullptr) {}
  virtual ~TerritoryCodeTypeIncludingDeprecatedCodes();

  TerritoryCodeTypeIncludingDeprecatedCodes(const TerritoryCodeTypeIncludingDeprecatedCodes& from);
  TerritoryCodeTypeIncludingDeprecatedCodes(TerritoryCodeTypeIncludingDeprecatedCodes&& from) noexcept
    : TerritoryCodeTypeIncludingDeprecatedCodes() {
    *this = ::std::move(from);
  }

  inline TerritoryCodeTypeIncludingDeprecatedCodes& operator=(const TerritoryCodeTypeIncludingDeprecatedCodes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerritoryCodeTypeIncludingDeprecatedCodes& operator=(TerritoryCodeTypeIncludingDeprecatedCodes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TerritoryCodeTypeIncludingDeprecatedCodes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TerritoryCodeTypeIncludingDeprecatedCodes* internal_default_instance() {
    return reinterpret_cast<const TerritoryCodeTypeIncludingDeprecatedCodes*>(
               &_TerritoryCodeTypeIncludingDeprecatedCodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(TerritoryCodeTypeIncludingDeprecatedCodes& a, TerritoryCodeTypeIncludingDeprecatedCodes& b) {
    a.Swap(&b);
  }
  inline void Swap(TerritoryCodeTypeIncludingDeprecatedCodes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerritoryCodeTypeIncludingDeprecatedCodes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TerritoryCodeTypeIncludingDeprecatedCodes* New() const final {
    return CreateMaybeMessage<TerritoryCodeTypeIncludingDeprecatedCodes>(nullptr);
  }

  TerritoryCodeTypeIncludingDeprecatedCodes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TerritoryCodeTypeIncludingDeprecatedCodes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TerritoryCodeTypeIncludingDeprecatedCodes& from);
  void MergeFrom(const TerritoryCodeTypeIncludingDeprecatedCodes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerritoryCodeTypeIncludingDeprecatedCodes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.TerritoryCodeTypeIncludingDeprecatedCodes";
  }
  protected:
  explicit TerritoryCodeTypeIncludingDeprecatedCodes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.TerritoryCodeTypeIncludingDeprecatedCodes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class TextCodecType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.TextCodecType) */ {
 public:
  inline TextCodecType() : TextCodecType(nullptr) {}
  virtual ~TextCodecType();

  TextCodecType(const TextCodecType& from);
  TextCodecType(TextCodecType&& from) noexcept
    : TextCodecType() {
    *this = ::std::move(from);
  }

  inline TextCodecType& operator=(const TextCodecType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextCodecType& operator=(TextCodecType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TextCodecType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextCodecType* internal_default_instance() {
    return reinterpret_cast<const TextCodecType*>(
               &_TextCodecType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(TextCodecType& a, TextCodecType& b) {
    a.Swap(&b);
  }
  inline void Swap(TextCodecType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextCodecType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextCodecType* New() const final {
    return CreateMaybeMessage<TextCodecType>(nullptr);
  }

  TextCodecType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextCodecType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TextCodecType& from);
  void MergeFrom(const TextCodecType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextCodecType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.TextCodecType";
  }
  protected:
  explicit TextCodecType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.TextCodecType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class TextType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.TextType) */ {
 public:
  inline TextType() : TextType(nullptr) {}
  virtual ~TextType();

  TextType(const TextType& from);
  TextType(TextType&& from) noexcept
    : TextType() {
    *this = ::std::move(from);
  }

  inline TextType& operator=(const TextType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextType& operator=(TextType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TextType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextType* internal_default_instance() {
    return reinterpret_cast<const TextType*>(
               &_TextType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(TextType& a, TextType& b) {
    a.Swap(&b);
  }
  inline void Swap(TextType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextType* New() const final {
    return CreateMaybeMessage<TextType>(nullptr);
  }

  TextType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TextType& from);
  void MergeFrom(const TextType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.TextType";
  }
  protected:
  explicit TextType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.TextType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class ThemeType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.ThemeType) */ {
 public:
  inline ThemeType() : ThemeType(nullptr) {}
  virtual ~ThemeType();

  ThemeType(const ThemeType& from);
  ThemeType(ThemeType&& from) noexcept
    : ThemeType() {
    *this = ::std::move(from);
  }

  inline ThemeType& operator=(const ThemeType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThemeType& operator=(ThemeType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ThemeType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThemeType* internal_default_instance() {
    return reinterpret_cast<const ThemeType*>(
               &_ThemeType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(ThemeType& a, ThemeType& b) {
    a.Swap(&b);
  }
  inline void Swap(ThemeType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThemeType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThemeType* New() const final {
    return CreateMaybeMessage<ThemeType>(nullptr);
  }

  ThemeType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThemeType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThemeType& from);
  void MergeFrom(const ThemeType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThemeType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.ThemeType";
  }
  protected:
  explicit ThemeType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.ThemeType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class TitleType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.TitleType) */ {
 public:
  inline TitleType() : TitleType(nullptr) {}
  virtual ~TitleType();

  TitleType(const TitleType& from);
  TitleType(TitleType&& from) noexcept
    : TitleType() {
    *this = ::std::move(from);
  }

  inline TitleType& operator=(const TitleType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TitleType& operator=(TitleType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TitleType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TitleType* internal_default_instance() {
    return reinterpret_cast<const TitleType*>(
               &_TitleType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(TitleType& a, TitleType& b) {
    a.Swap(&b);
  }
  inline void Swap(TitleType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TitleType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TitleType* New() const final {
    return CreateMaybeMessage<TitleType>(nullptr);
  }

  TitleType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TitleType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TitleType& from);
  void MergeFrom(const TitleType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TitleType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.TitleType";
  }
  protected:
  explicit TitleType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.TitleType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class UnitOfBitRate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.UnitOfBitRate) */ {
 public:
  inline UnitOfBitRate() : UnitOfBitRate(nullptr) {}
  virtual ~UnitOfBitRate();

  UnitOfBitRate(const UnitOfBitRate& from);
  UnitOfBitRate(UnitOfBitRate&& from) noexcept
    : UnitOfBitRate() {
    *this = ::std::move(from);
  }

  inline UnitOfBitRate& operator=(const UnitOfBitRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOfBitRate& operator=(UnitOfBitRate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitOfBitRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOfBitRate* internal_default_instance() {
    return reinterpret_cast<const UnitOfBitRate*>(
               &_UnitOfBitRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(UnitOfBitRate& a, UnitOfBitRate& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOfBitRate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOfBitRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitOfBitRate* New() const final {
    return CreateMaybeMessage<UnitOfBitRate>(nullptr);
  }

  UnitOfBitRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitOfBitRate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitOfBitRate& from);
  void MergeFrom(const UnitOfBitRate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOfBitRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.UnitOfBitRate";
  }
  protected:
  explicit UnitOfBitRate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.UnitOfBitRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class UnitOfConditionValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.UnitOfConditionValue) */ {
 public:
  inline UnitOfConditionValue() : UnitOfConditionValue(nullptr) {}
  virtual ~UnitOfConditionValue();

  UnitOfConditionValue(const UnitOfConditionValue& from);
  UnitOfConditionValue(UnitOfConditionValue&& from) noexcept
    : UnitOfConditionValue() {
    *this = ::std::move(from);
  }

  inline UnitOfConditionValue& operator=(const UnitOfConditionValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOfConditionValue& operator=(UnitOfConditionValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitOfConditionValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOfConditionValue* internal_default_instance() {
    return reinterpret_cast<const UnitOfConditionValue*>(
               &_UnitOfConditionValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(UnitOfConditionValue& a, UnitOfConditionValue& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOfConditionValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOfConditionValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitOfConditionValue* New() const final {
    return CreateMaybeMessage<UnitOfConditionValue>(nullptr);
  }

  UnitOfConditionValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitOfConditionValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitOfConditionValue& from);
  void MergeFrom(const UnitOfConditionValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOfConditionValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.UnitOfConditionValue";
  }
  protected:
  explicit UnitOfConditionValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.UnitOfConditionValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class UnitOfExtent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.UnitOfExtent) */ {
 public:
  inline UnitOfExtent() : UnitOfExtent(nullptr) {}
  virtual ~UnitOfExtent();

  UnitOfExtent(const UnitOfExtent& from);
  UnitOfExtent(UnitOfExtent&& from) noexcept
    : UnitOfExtent() {
    *this = ::std::move(from);
  }

  inline UnitOfExtent& operator=(const UnitOfExtent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOfExtent& operator=(UnitOfExtent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitOfExtent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOfExtent* internal_default_instance() {
    return reinterpret_cast<const UnitOfExtent*>(
               &_UnitOfExtent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(UnitOfExtent& a, UnitOfExtent& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOfExtent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOfExtent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitOfExtent* New() const final {
    return CreateMaybeMessage<UnitOfExtent>(nullptr);
  }

  UnitOfExtent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitOfExtent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitOfExtent& from);
  void MergeFrom(const UnitOfExtent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOfExtent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.UnitOfExtent";
  }
  protected:
  explicit UnitOfExtent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.UnitOfExtent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class UnitOfFrameRate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.UnitOfFrameRate) */ {
 public:
  inline UnitOfFrameRate() : UnitOfFrameRate(nullptr) {}
  virtual ~UnitOfFrameRate();

  UnitOfFrameRate(const UnitOfFrameRate& from);
  UnitOfFrameRate(UnitOfFrameRate&& from) noexcept
    : UnitOfFrameRate() {
    *this = ::std::move(from);
  }

  inline UnitOfFrameRate& operator=(const UnitOfFrameRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOfFrameRate& operator=(UnitOfFrameRate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitOfFrameRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOfFrameRate* internal_default_instance() {
    return reinterpret_cast<const UnitOfFrameRate*>(
               &_UnitOfFrameRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(UnitOfFrameRate& a, UnitOfFrameRate& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOfFrameRate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOfFrameRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitOfFrameRate* New() const final {
    return CreateMaybeMessage<UnitOfFrameRate>(nullptr);
  }

  UnitOfFrameRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitOfFrameRate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitOfFrameRate& from);
  void MergeFrom(const UnitOfFrameRate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOfFrameRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.UnitOfFrameRate";
  }
  protected:
  explicit UnitOfFrameRate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.UnitOfFrameRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class UnitOfFrequency PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.UnitOfFrequency) */ {
 public:
  inline UnitOfFrequency() : UnitOfFrequency(nullptr) {}
  virtual ~UnitOfFrequency();

  UnitOfFrequency(const UnitOfFrequency& from);
  UnitOfFrequency(UnitOfFrequency&& from) noexcept
    : UnitOfFrequency() {
    *this = ::std::move(from);
  }

  inline UnitOfFrequency& operator=(const UnitOfFrequency& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOfFrequency& operator=(UnitOfFrequency&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitOfFrequency& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOfFrequency* internal_default_instance() {
    return reinterpret_cast<const UnitOfFrequency*>(
               &_UnitOfFrequency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(UnitOfFrequency& a, UnitOfFrequency& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOfFrequency* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOfFrequency* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitOfFrequency* New() const final {
    return CreateMaybeMessage<UnitOfFrequency>(nullptr);
  }

  UnitOfFrequency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitOfFrequency>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitOfFrequency& from);
  void MergeFrom(const UnitOfFrequency& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOfFrequency* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.UnitOfFrequency";
  }
  protected:
  explicit UnitOfFrequency(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.UnitOfFrequency)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class UseType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.UseType) */ {
 public:
  inline UseType() : UseType(nullptr) {}
  virtual ~UseType();

  UseType(const UseType& from);
  UseType(UseType&& from) noexcept
    : UseType() {
    *this = ::std::move(from);
  }

  inline UseType& operator=(const UseType& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseType& operator=(UseType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UseType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UseType* internal_default_instance() {
    return reinterpret_cast<const UseType*>(
               &_UseType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(UseType& a, UseType& b) {
    a.Swap(&b);
  }
  inline void Swap(UseType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UseType* New() const final {
    return CreateMaybeMessage<UseType>(nullptr);
  }

  UseType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UseType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UseType& from);
  void MergeFrom(const UseType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UseType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.UseType";
  }
  protected:
  explicit UseType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.UseType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class VersionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.VersionType) */ {
 public:
  inline VersionType() : VersionType(nullptr) {}
  virtual ~VersionType();

  VersionType(const VersionType& from);
  VersionType(VersionType&& from) noexcept
    : VersionType() {
    *this = ::std::move(from);
  }

  inline VersionType& operator=(const VersionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionType& operator=(VersionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VersionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionType* internal_default_instance() {
    return reinterpret_cast<const VersionType*>(
               &_VersionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(VersionType& a, VersionType& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VersionType* New() const final {
    return CreateMaybeMessage<VersionType>(nullptr);
  }

  VersionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VersionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VersionType& from);
  void MergeFrom(const VersionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.VersionType";
  }
  protected:
  explicit VersionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.VersionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class VideoCodecType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.VideoCodecType) */ {
 public:
  inline VideoCodecType() : VideoCodecType(nullptr) {}
  virtual ~VideoCodecType();

  VideoCodecType(const VideoCodecType& from);
  VideoCodecType(VideoCodecType&& from) noexcept
    : VideoCodecType() {
    *this = ::std::move(from);
  }

  inline VideoCodecType& operator=(const VideoCodecType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoCodecType& operator=(VideoCodecType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoCodecType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoCodecType* internal_default_instance() {
    return reinterpret_cast<const VideoCodecType*>(
               &_VideoCodecType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(VideoCodecType& a, VideoCodecType& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoCodecType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoCodecType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoCodecType* New() const final {
    return CreateMaybeMessage<VideoCodecType>(nullptr);
  }

  VideoCodecType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoCodecType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoCodecType& from);
  void MergeFrom(const VideoCodecType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoCodecType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.VideoCodecType";
  }
  protected:
  explicit VideoCodecType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.VideoCodecType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class VideoDefinitionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.VideoDefinitionType) */ {
 public:
  inline VideoDefinitionType() : VideoDefinitionType(nullptr) {}
  virtual ~VideoDefinitionType();

  VideoDefinitionType(const VideoDefinitionType& from);
  VideoDefinitionType(VideoDefinitionType&& from) noexcept
    : VideoDefinitionType() {
    *this = ::std::move(from);
  }

  inline VideoDefinitionType& operator=(const VideoDefinitionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoDefinitionType& operator=(VideoDefinitionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoDefinitionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoDefinitionType* internal_default_instance() {
    return reinterpret_cast<const VideoDefinitionType*>(
               &_VideoDefinitionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(VideoDefinitionType& a, VideoDefinitionType& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoDefinitionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoDefinitionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoDefinitionType* New() const final {
    return CreateMaybeMessage<VideoDefinitionType>(nullptr);
  }

  VideoDefinitionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoDefinitionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoDefinitionType& from);
  void MergeFrom(const VideoDefinitionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoDefinitionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.VideoDefinitionType";
  }
  protected:
  explicit VideoDefinitionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.VideoDefinitionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class VideoType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.VideoType) */ {
 public:
  inline VideoType() : VideoType(nullptr) {}
  virtual ~VideoType();

  VideoType(const VideoType& from);
  VideoType(VideoType&& from) noexcept
    : VideoType() {
    *this = ::std::move(from);
  }

  inline VideoType& operator=(const VideoType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoType& operator=(VideoType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoType* internal_default_instance() {
    return reinterpret_cast<const VideoType*>(
               &_VideoType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(VideoType& a, VideoType& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoType* New() const final {
    return CreateMaybeMessage<VideoType>(nullptr);
  }

  VideoType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoType& from);
  void MergeFrom(const VideoType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.VideoType";
  }
  protected:
  explicit VideoType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.VideoType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class VisualPerceptionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.VisualPerceptionType) */ {
 public:
  inline VisualPerceptionType() : VisualPerceptionType(nullptr) {}
  virtual ~VisualPerceptionType();

  VisualPerceptionType(const VisualPerceptionType& from);
  VisualPerceptionType(VisualPerceptionType&& from) noexcept
    : VisualPerceptionType() {
    *this = ::std::move(from);
  }

  inline VisualPerceptionType& operator=(const VisualPerceptionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisualPerceptionType& operator=(VisualPerceptionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VisualPerceptionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VisualPerceptionType* internal_default_instance() {
    return reinterpret_cast<const VisualPerceptionType*>(
               &_VisualPerceptionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(VisualPerceptionType& a, VisualPerceptionType& b) {
    a.Swap(&b);
  }
  inline void Swap(VisualPerceptionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisualPerceptionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VisualPerceptionType* New() const final {
    return CreateMaybeMessage<VisualPerceptionType>(nullptr);
  }

  VisualPerceptionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VisualPerceptionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VisualPerceptionType& from);
  void MergeFrom(const VisualPerceptionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisualPerceptionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.VisualPerceptionType";
  }
  protected:
  explicit VisualPerceptionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.VisualPerceptionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// -------------------------------------------------------------------

class VocalType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ern411.avs.VocalType) */ {
 public:
  inline VocalType() : VocalType(nullptr) {}
  virtual ~VocalType();

  VocalType(const VocalType& from);
  VocalType(VocalType&& from) noexcept
    : VocalType() {
    *this = ::std::move(from);
  }

  inline VocalType& operator=(const VocalType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VocalType& operator=(VocalType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VocalType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VocalType* internal_default_instance() {
    return reinterpret_cast<const VocalType*>(
               &_VocalType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(VocalType& a, VocalType& b) {
    a.Swap(&b);
  }
  inline void Swap(VocalType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VocalType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VocalType* New() const final {
    return CreateMaybeMessage<VocalType>(nullptr);
  }

  VocalType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VocalType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VocalType& from);
  void MergeFrom(const VocalType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VocalType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ern411.avs.VocalType";
  }
  protected:
  explicit VocalType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:ern411.avs.VocalType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AdditionalTitleType

// optional string enum_value = 1;
inline bool AdditionalTitleType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdditionalTitleType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AdditionalTitleType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdditionalTitleType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.AdditionalTitleType.enum_value)
  return _internal_enum_value();
}
inline void AdditionalTitleType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.AdditionalTitleType.enum_value)
}
inline std::string* AdditionalTitleType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.AdditionalTitleType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AdditionalTitleType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AdditionalTitleType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AdditionalTitleType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.AdditionalTitleType.enum_value)
}
inline void AdditionalTitleType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.AdditionalTitleType.enum_value)
}
inline void AdditionalTitleType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.AdditionalTitleType.enum_value)
}
inline std::string* AdditionalTitleType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AdditionalTitleType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.AdditionalTitleType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AdditionalTitleType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.AdditionalTitleType.enum_value)
}

// -------------------------------------------------------------------

// AdministratingRecordCompanyRole

// optional string enum_value = 1;
inline bool AdministratingRecordCompanyRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdministratingRecordCompanyRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AdministratingRecordCompanyRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdministratingRecordCompanyRole::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.AdministratingRecordCompanyRole.enum_value)
  return _internal_enum_value();
}
inline void AdministratingRecordCompanyRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.AdministratingRecordCompanyRole.enum_value)
}
inline std::string* AdministratingRecordCompanyRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.AdministratingRecordCompanyRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AdministratingRecordCompanyRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AdministratingRecordCompanyRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AdministratingRecordCompanyRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.AdministratingRecordCompanyRole.enum_value)
}
inline void AdministratingRecordCompanyRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.AdministratingRecordCompanyRole.enum_value)
}
inline void AdministratingRecordCompanyRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.AdministratingRecordCompanyRole.enum_value)
}
inline std::string* AdministratingRecordCompanyRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AdministratingRecordCompanyRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.AdministratingRecordCompanyRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AdministratingRecordCompanyRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.AdministratingRecordCompanyRole.enum_value)
}

// -------------------------------------------------------------------

// AffiliationType

// optional string enum_value = 1;
inline bool AffiliationType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AffiliationType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AffiliationType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AffiliationType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.AffiliationType.enum_value)
  return _internal_enum_value();
}
inline void AffiliationType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.AffiliationType.enum_value)
}
inline std::string* AffiliationType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.AffiliationType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AffiliationType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AffiliationType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AffiliationType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.AffiliationType.enum_value)
}
inline void AffiliationType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.AffiliationType.enum_value)
}
inline void AffiliationType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.AffiliationType.enum_value)
}
inline std::string* AffiliationType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AffiliationType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.AffiliationType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AffiliationType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.AffiliationType.enum_value)
}

// -------------------------------------------------------------------

// AllTerritoryCode

// optional string enum_value = 1;
inline bool AllTerritoryCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllTerritoryCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AllTerritoryCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AllTerritoryCode::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.AllTerritoryCode.enum_value)
  return _internal_enum_value();
}
inline void AllTerritoryCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.AllTerritoryCode.enum_value)
}
inline std::string* AllTerritoryCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.AllTerritoryCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AllTerritoryCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AllTerritoryCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AllTerritoryCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.AllTerritoryCode.enum_value)
}
inline void AllTerritoryCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.AllTerritoryCode.enum_value)
}
inline void AllTerritoryCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.AllTerritoryCode.enum_value)
}
inline std::string* AllTerritoryCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AllTerritoryCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.AllTerritoryCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AllTerritoryCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.AllTerritoryCode.enum_value)
}

// -------------------------------------------------------------------

// AspectRatioType

// optional string enum_value = 1;
inline bool AspectRatioType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AspectRatioType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AspectRatioType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AspectRatioType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.AspectRatioType.enum_value)
  return _internal_enum_value();
}
inline void AspectRatioType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.AspectRatioType.enum_value)
}
inline std::string* AspectRatioType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.AspectRatioType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AspectRatioType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AspectRatioType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AspectRatioType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.AspectRatioType.enum_value)
}
inline void AspectRatioType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.AspectRatioType.enum_value)
}
inline void AspectRatioType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.AspectRatioType.enum_value)
}
inline std::string* AspectRatioType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AspectRatioType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.AspectRatioType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AspectRatioType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.AspectRatioType.enum_value)
}

// -------------------------------------------------------------------

// AudioCodecType

// optional string enum_value = 1;
inline bool AudioCodecType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioCodecType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AudioCodecType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioCodecType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.AudioCodecType.enum_value)
  return _internal_enum_value();
}
inline void AudioCodecType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.AudioCodecType.enum_value)
}
inline std::string* AudioCodecType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.AudioCodecType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AudioCodecType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AudioCodecType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioCodecType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.AudioCodecType.enum_value)
}
inline void AudioCodecType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.AudioCodecType.enum_value)
}
inline void AudioCodecType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.AudioCodecType.enum_value)
}
inline std::string* AudioCodecType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioCodecType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.AudioCodecType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioCodecType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.AudioCodecType.enum_value)
}

// -------------------------------------------------------------------

// BinaryDataType

// optional string enum_value = 1;
inline bool BinaryDataType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BinaryDataType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void BinaryDataType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BinaryDataType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.BinaryDataType.enum_value)
  return _internal_enum_value();
}
inline void BinaryDataType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.BinaryDataType.enum_value)
}
inline std::string* BinaryDataType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.BinaryDataType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& BinaryDataType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void BinaryDataType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BinaryDataType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.BinaryDataType.enum_value)
}
inline void BinaryDataType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.BinaryDataType.enum_value)
}
inline void BinaryDataType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.BinaryDataType.enum_value)
}
inline std::string* BinaryDataType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BinaryDataType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.BinaryDataType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BinaryDataType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.BinaryDataType.enum_value)
}

// -------------------------------------------------------------------

// CarrierType

// optional string enum_value = 1;
inline bool CarrierType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CarrierType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CarrierType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CarrierType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.CarrierType.enum_value)
  return _internal_enum_value();
}
inline void CarrierType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.CarrierType.enum_value)
}
inline std::string* CarrierType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.CarrierType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CarrierType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CarrierType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CarrierType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.CarrierType.enum_value)
}
inline void CarrierType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.CarrierType.enum_value)
}
inline void CarrierType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.CarrierType.enum_value)
}
inline std::string* CarrierType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CarrierType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.CarrierType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CarrierType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.CarrierType.enum_value)
}

// -------------------------------------------------------------------

// CodingType

// optional string enum_value = 1;
inline bool CodingType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CodingType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CodingType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CodingType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.CodingType.enum_value)
  return _internal_enum_value();
}
inline void CodingType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.CodingType.enum_value)
}
inline std::string* CodingType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.CodingType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CodingType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CodingType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CodingType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.CodingType.enum_value)
}
inline void CodingType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.CodingType.enum_value)
}
inline void CodingType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.CodingType.enum_value)
}
inline std::string* CodingType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CodingType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.CodingType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CodingType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.CodingType.enum_value)
}

// -------------------------------------------------------------------

// CommercialModelType

// optional string enum_value = 1;
inline bool CommercialModelType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommercialModelType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CommercialModelType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommercialModelType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.CommercialModelType.enum_value)
  return _internal_enum_value();
}
inline void CommercialModelType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.CommercialModelType.enum_value)
}
inline std::string* CommercialModelType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.CommercialModelType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CommercialModelType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CommercialModelType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommercialModelType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.CommercialModelType.enum_value)
}
inline void CommercialModelType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.CommercialModelType.enum_value)
}
inline void CommercialModelType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.CommercialModelType.enum_value)
}
inline std::string* CommercialModelType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommercialModelType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.CommercialModelType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommercialModelType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.CommercialModelType.enum_value)
}

// -------------------------------------------------------------------

// CompositeMusicalWorkType

// optional string enum_value = 1;
inline bool CompositeMusicalWorkType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CompositeMusicalWorkType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CompositeMusicalWorkType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompositeMusicalWorkType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.CompositeMusicalWorkType.enum_value)
  return _internal_enum_value();
}
inline void CompositeMusicalWorkType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.CompositeMusicalWorkType.enum_value)
}
inline std::string* CompositeMusicalWorkType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.CompositeMusicalWorkType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CompositeMusicalWorkType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CompositeMusicalWorkType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CompositeMusicalWorkType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.CompositeMusicalWorkType.enum_value)
}
inline void CompositeMusicalWorkType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.CompositeMusicalWorkType.enum_value)
}
inline void CompositeMusicalWorkType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.CompositeMusicalWorkType.enum_value)
}
inline std::string* CompositeMusicalWorkType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CompositeMusicalWorkType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.CompositeMusicalWorkType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CompositeMusicalWorkType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.CompositeMusicalWorkType.enum_value)
}

// -------------------------------------------------------------------

// ContainerFormat

// optional string enum_value = 1;
inline bool ContainerFormat::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContainerFormat::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ContainerFormat::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContainerFormat::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ContainerFormat.enum_value)
  return _internal_enum_value();
}
inline void ContainerFormat::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ContainerFormat.enum_value)
}
inline std::string* ContainerFormat::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ContainerFormat.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ContainerFormat::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ContainerFormat::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ContainerFormat::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ContainerFormat.enum_value)
}
inline void ContainerFormat::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ContainerFormat.enum_value)
}
inline void ContainerFormat::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ContainerFormat.enum_value)
}
inline std::string* ContainerFormat::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ContainerFormat::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ContainerFormat.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ContainerFormat::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ContainerFormat.enum_value)
}

// -------------------------------------------------------------------

// ContributorRole

// optional string enum_value = 1;
inline bool ContributorRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContributorRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ContributorRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContributorRole::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ContributorRole.enum_value)
  return _internal_enum_value();
}
inline void ContributorRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ContributorRole.enum_value)
}
inline std::string* ContributorRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ContributorRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ContributorRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ContributorRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ContributorRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ContributorRole.enum_value)
}
inline void ContributorRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ContributorRole.enum_value)
}
inline void ContributorRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ContributorRole.enum_value)
}
inline std::string* ContributorRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ContributorRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ContributorRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ContributorRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ContributorRole.enum_value)
}

// -------------------------------------------------------------------

// CueOrigin

// optional string enum_value = 1;
inline bool CueOrigin::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CueOrigin::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CueOrigin::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CueOrigin::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.CueOrigin.enum_value)
  return _internal_enum_value();
}
inline void CueOrigin::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.CueOrigin.enum_value)
}
inline std::string* CueOrigin::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.CueOrigin.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CueOrigin::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CueOrigin::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CueOrigin::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.CueOrigin.enum_value)
}
inline void CueOrigin::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.CueOrigin.enum_value)
}
inline void CueOrigin::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.CueOrigin.enum_value)
}
inline std::string* CueOrigin::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CueOrigin::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.CueOrigin.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CueOrigin::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.CueOrigin.enum_value)
}

// -------------------------------------------------------------------

// CueSheetType

// optional string enum_value = 1;
inline bool CueSheetType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CueSheetType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CueSheetType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CueSheetType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.CueSheetType.enum_value)
  return _internal_enum_value();
}
inline void CueSheetType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.CueSheetType.enum_value)
}
inline std::string* CueSheetType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.CueSheetType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CueSheetType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CueSheetType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CueSheetType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.CueSheetType.enum_value)
}
inline void CueSheetType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.CueSheetType.enum_value)
}
inline void CueSheetType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.CueSheetType.enum_value)
}
inline std::string* CueSheetType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CueSheetType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.CueSheetType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CueSheetType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.CueSheetType.enum_value)
}

// -------------------------------------------------------------------

// CueUseType

// optional string enum_value = 1;
inline bool CueUseType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CueUseType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CueUseType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CueUseType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.CueUseType.enum_value)
  return _internal_enum_value();
}
inline void CueUseType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.CueUseType.enum_value)
}
inline std::string* CueUseType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.CueUseType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CueUseType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CueUseType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CueUseType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.CueUseType.enum_value)
}
inline void CueUseType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.CueUseType.enum_value)
}
inline void CueUseType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.CueUseType.enum_value)
}
inline std::string* CueUseType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CueUseType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.CueUseType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CueUseType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.CueUseType.enum_value)
}

// -------------------------------------------------------------------

// CurrencyCode

// optional string enum_value = 1;
inline bool CurrencyCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CurrencyCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CurrencyCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CurrencyCode::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.CurrencyCode.enum_value)
  return _internal_enum_value();
}
inline void CurrencyCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.CurrencyCode.enum_value)
}
inline std::string* CurrencyCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.CurrencyCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CurrencyCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CurrencyCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CurrencyCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.CurrencyCode.enum_value)
}
inline void CurrencyCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.CurrencyCode.enum_value)
}
inline void CurrencyCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.CurrencyCode.enum_value)
}
inline std::string* CurrencyCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CurrencyCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.CurrencyCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CurrencyCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.CurrencyCode.enum_value)
}

// -------------------------------------------------------------------

// CurrentTerritoryCode

// optional string enum_value = 1;
inline bool CurrentTerritoryCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CurrentTerritoryCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CurrentTerritoryCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CurrentTerritoryCode::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.CurrentTerritoryCode.enum_value)
  return _internal_enum_value();
}
inline void CurrentTerritoryCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.CurrentTerritoryCode.enum_value)
}
inline std::string* CurrentTerritoryCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.CurrentTerritoryCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CurrentTerritoryCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CurrentTerritoryCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CurrentTerritoryCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.CurrentTerritoryCode.enum_value)
}
inline void CurrentTerritoryCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.CurrentTerritoryCode.enum_value)
}
inline void CurrentTerritoryCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.CurrentTerritoryCode.enum_value)
}
inline std::string* CurrentTerritoryCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CurrentTerritoryCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.CurrentTerritoryCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CurrentTerritoryCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.CurrentTerritoryCode.enum_value)
}

// -------------------------------------------------------------------

// DisplayArtistRole

// optional string enum_value = 1;
inline bool DisplayArtistRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DisplayArtistRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DisplayArtistRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DisplayArtistRole::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.DisplayArtistRole.enum_value)
  return _internal_enum_value();
}
inline void DisplayArtistRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.DisplayArtistRole.enum_value)
}
inline std::string* DisplayArtistRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.DisplayArtistRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DisplayArtistRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DisplayArtistRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DisplayArtistRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.DisplayArtistRole.enum_value)
}
inline void DisplayArtistRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.DisplayArtistRole.enum_value)
}
inline void DisplayArtistRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.DisplayArtistRole.enum_value)
}
inline std::string* DisplayArtistRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DisplayArtistRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.DisplayArtistRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DisplayArtistRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.DisplayArtistRole.enum_value)
}

// -------------------------------------------------------------------

// ExpressionType

// optional string enum_value = 1;
inline bool ExpressionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExpressionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ExpressionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExpressionType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ExpressionType.enum_value)
  return _internal_enum_value();
}
inline void ExpressionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ExpressionType.enum_value)
}
inline std::string* ExpressionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ExpressionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ExpressionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ExpressionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ExpressionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ExpressionType.enum_value)
}
inline void ExpressionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ExpressionType.enum_value)
}
inline void ExpressionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ExpressionType.enum_value)
}
inline std::string* ExpressionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ExpressionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ExpressionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ExpressionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ExpressionType.enum_value)
}

// -------------------------------------------------------------------

// ExternallyLinkedResourceType

// optional string enum_value = 1;
inline bool ExternallyLinkedResourceType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExternallyLinkedResourceType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ExternallyLinkedResourceType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExternallyLinkedResourceType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ExternallyLinkedResourceType.enum_value)
  return _internal_enum_value();
}
inline void ExternallyLinkedResourceType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ExternallyLinkedResourceType.enum_value)
}
inline std::string* ExternallyLinkedResourceType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ExternallyLinkedResourceType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ExternallyLinkedResourceType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ExternallyLinkedResourceType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ExternallyLinkedResourceType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ExternallyLinkedResourceType.enum_value)
}
inline void ExternallyLinkedResourceType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ExternallyLinkedResourceType.enum_value)
}
inline void ExternallyLinkedResourceType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ExternallyLinkedResourceType.enum_value)
}
inline std::string* ExternallyLinkedResourceType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ExternallyLinkedResourceType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ExternallyLinkedResourceType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ExternallyLinkedResourceType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ExternallyLinkedResourceType.enum_value)
}

// -------------------------------------------------------------------

// FingerprintAlgorithmType

// optional string enum_value = 1;
inline bool FingerprintAlgorithmType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FingerprintAlgorithmType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void FingerprintAlgorithmType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FingerprintAlgorithmType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.FingerprintAlgorithmType.enum_value)
  return _internal_enum_value();
}
inline void FingerprintAlgorithmType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.FingerprintAlgorithmType.enum_value)
}
inline std::string* FingerprintAlgorithmType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.FingerprintAlgorithmType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& FingerprintAlgorithmType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void FingerprintAlgorithmType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FingerprintAlgorithmType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.FingerprintAlgorithmType.enum_value)
}
inline void FingerprintAlgorithmType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.FingerprintAlgorithmType.enum_value)
}
inline void FingerprintAlgorithmType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.FingerprintAlgorithmType.enum_value)
}
inline std::string* FingerprintAlgorithmType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FingerprintAlgorithmType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.FingerprintAlgorithmType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FingerprintAlgorithmType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.FingerprintAlgorithmType.enum_value)
}

// -------------------------------------------------------------------

// FrameRate

// optional string enum_value = 1;
inline bool FrameRate::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FrameRate::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void FrameRate::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FrameRate::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.FrameRate.enum_value)
  return _internal_enum_value();
}
inline void FrameRate::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.FrameRate.enum_value)
}
inline std::string* FrameRate::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.FrameRate.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& FrameRate::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void FrameRate::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FrameRate::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.FrameRate.enum_value)
}
inline void FrameRate::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.FrameRate.enum_value)
}
inline void FrameRate::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.FrameRate.enum_value)
}
inline std::string* FrameRate::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FrameRate::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.FrameRate.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FrameRate::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.FrameRate.enum_value)
}

// -------------------------------------------------------------------

// HashSumAlgorithmType

// optional string enum_value = 1;
inline bool HashSumAlgorithmType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HashSumAlgorithmType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void HashSumAlgorithmType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HashSumAlgorithmType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.HashSumAlgorithmType.enum_value)
  return _internal_enum_value();
}
inline void HashSumAlgorithmType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.HashSumAlgorithmType.enum_value)
}
inline std::string* HashSumAlgorithmType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.HashSumAlgorithmType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& HashSumAlgorithmType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void HashSumAlgorithmType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HashSumAlgorithmType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.HashSumAlgorithmType.enum_value)
}
inline void HashSumAlgorithmType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.HashSumAlgorithmType.enum_value)
}
inline void HashSumAlgorithmType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.HashSumAlgorithmType.enum_value)
}
inline std::string* HashSumAlgorithmType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HashSumAlgorithmType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.HashSumAlgorithmType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HashSumAlgorithmType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.HashSumAlgorithmType.enum_value)
}

// -------------------------------------------------------------------

// ImageCodecType

// optional string enum_value = 1;
inline bool ImageCodecType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImageCodecType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ImageCodecType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImageCodecType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ImageCodecType.enum_value)
  return _internal_enum_value();
}
inline void ImageCodecType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ImageCodecType.enum_value)
}
inline std::string* ImageCodecType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ImageCodecType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ImageCodecType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ImageCodecType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageCodecType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ImageCodecType.enum_value)
}
inline void ImageCodecType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ImageCodecType.enum_value)
}
inline void ImageCodecType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ImageCodecType.enum_value)
}
inline std::string* ImageCodecType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageCodecType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ImageCodecType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageCodecType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ImageCodecType.enum_value)
}

// -------------------------------------------------------------------

// ImageType

// optional string enum_value = 1;
inline bool ImageType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImageType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ImageType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImageType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ImageType.enum_value)
  return _internal_enum_value();
}
inline void ImageType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ImageType.enum_value)
}
inline std::string* ImageType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ImageType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ImageType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ImageType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ImageType.enum_value)
}
inline void ImageType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ImageType.enum_value)
}
inline void ImageType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ImageType.enum_value)
}
inline std::string* ImageType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ImageType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ImageType.enum_value)
}

// -------------------------------------------------------------------

// InstrumentType

// optional string enum_value = 1;
inline bool InstrumentType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstrumentType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void InstrumentType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstrumentType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.InstrumentType.enum_value)
  return _internal_enum_value();
}
inline void InstrumentType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.InstrumentType.enum_value)
}
inline std::string* InstrumentType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.InstrumentType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& InstrumentType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void InstrumentType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InstrumentType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.InstrumentType.enum_value)
}
inline void InstrumentType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.InstrumentType.enum_value)
}
inline void InstrumentType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.InstrumentType.enum_value)
}
inline std::string* InstrumentType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InstrumentType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.InstrumentType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InstrumentType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.InstrumentType.enum_value)
}

// -------------------------------------------------------------------

// IsoLanguageCode

// optional string enum_value = 1;
inline bool IsoLanguageCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IsoLanguageCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void IsoLanguageCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IsoLanguageCode::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.IsoLanguageCode.enum_value)
  return _internal_enum_value();
}
inline void IsoLanguageCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.IsoLanguageCode.enum_value)
}
inline std::string* IsoLanguageCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.IsoLanguageCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& IsoLanguageCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void IsoLanguageCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void IsoLanguageCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.IsoLanguageCode.enum_value)
}
inline void IsoLanguageCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.IsoLanguageCode.enum_value)
}
inline void IsoLanguageCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.IsoLanguageCode.enum_value)
}
inline std::string* IsoLanguageCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* IsoLanguageCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.IsoLanguageCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IsoLanguageCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.IsoLanguageCode.enum_value)
}

// -------------------------------------------------------------------

// LabelType

// optional string enum_value = 1;
inline bool LabelType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LabelType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void LabelType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LabelType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.LabelType.enum_value)
  return _internal_enum_value();
}
inline void LabelType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.LabelType.enum_value)
}
inline std::string* LabelType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.LabelType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& LabelType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void LabelType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LabelType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.LabelType.enum_value)
}
inline void LabelType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.LabelType.enum_value)
}
inline void LabelType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.LabelType.enum_value)
}
inline std::string* LabelType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LabelType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.LabelType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LabelType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.LabelType.enum_value)
}

// -------------------------------------------------------------------

// LinkDescription

// optional string enum_value = 1;
inline bool LinkDescription::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LinkDescription::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void LinkDescription::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LinkDescription::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.LinkDescription.enum_value)
  return _internal_enum_value();
}
inline void LinkDescription::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.LinkDescription.enum_value)
}
inline std::string* LinkDescription::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.LinkDescription.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& LinkDescription::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void LinkDescription::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LinkDescription::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.LinkDescription.enum_value)
}
inline void LinkDescription::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.LinkDescription.enum_value)
}
inline void LinkDescription::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.LinkDescription.enum_value)
}
inline std::string* LinkDescription::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LinkDescription::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.LinkDescription.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LinkDescription::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.LinkDescription.enum_value)
}

// -------------------------------------------------------------------

// MessageControlType

// optional string enum_value = 1;
inline bool MessageControlType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessageControlType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MessageControlType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessageControlType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.MessageControlType.enum_value)
  return _internal_enum_value();
}
inline void MessageControlType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.MessageControlType.enum_value)
}
inline std::string* MessageControlType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.MessageControlType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MessageControlType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MessageControlType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MessageControlType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.MessageControlType.enum_value)
}
inline void MessageControlType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.MessageControlType.enum_value)
}
inline void MessageControlType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.MessageControlType.enum_value)
}
inline std::string* MessageControlType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MessageControlType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.MessageControlType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessageControlType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.MessageControlType.enum_value)
}

// -------------------------------------------------------------------

// OperatingSystemType

// optional string enum_value = 1;
inline bool OperatingSystemType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OperatingSystemType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void OperatingSystemType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OperatingSystemType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.OperatingSystemType.enum_value)
  return _internal_enum_value();
}
inline void OperatingSystemType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.OperatingSystemType.enum_value)
}
inline std::string* OperatingSystemType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.OperatingSystemType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& OperatingSystemType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void OperatingSystemType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void OperatingSystemType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.OperatingSystemType.enum_value)
}
inline void OperatingSystemType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.OperatingSystemType.enum_value)
}
inline void OperatingSystemType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.OperatingSystemType.enum_value)
}
inline std::string* OperatingSystemType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* OperatingSystemType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.OperatingSystemType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void OperatingSystemType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.OperatingSystemType.enum_value)
}

// -------------------------------------------------------------------

// PLineType

// optional string enum_value = 1;
inline bool PLineType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PLineType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void PLineType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PLineType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.PLineType.enum_value)
  return _internal_enum_value();
}
inline void PLineType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.PLineType.enum_value)
}
inline std::string* PLineType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.PLineType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& PLineType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void PLineType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PLineType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.PLineType.enum_value)
}
inline void PLineType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.PLineType.enum_value)
}
inline void PLineType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.PLineType.enum_value)
}
inline std::string* PLineType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PLineType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.PLineType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PLineType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.PLineType.enum_value)
}

// -------------------------------------------------------------------

// ParentalWarningType

// optional string enum_value = 1;
inline bool ParentalWarningType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ParentalWarningType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ParentalWarningType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ParentalWarningType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ParentalWarningType.enum_value)
  return _internal_enum_value();
}
inline void ParentalWarningType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ParentalWarningType.enum_value)
}
inline std::string* ParentalWarningType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ParentalWarningType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ParentalWarningType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ParentalWarningType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ParentalWarningType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ParentalWarningType.enum_value)
}
inline void ParentalWarningType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ParentalWarningType.enum_value)
}
inline void ParentalWarningType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ParentalWarningType.enum_value)
}
inline std::string* ParentalWarningType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ParentalWarningType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ParentalWarningType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ParentalWarningType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ParentalWarningType.enum_value)
}

// -------------------------------------------------------------------

// PartyRelationshipType

// optional string enum_value = 1;
inline bool PartyRelationshipType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PartyRelationshipType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void PartyRelationshipType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartyRelationshipType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.PartyRelationshipType.enum_value)
  return _internal_enum_value();
}
inline void PartyRelationshipType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.PartyRelationshipType.enum_value)
}
inline std::string* PartyRelationshipType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.PartyRelationshipType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& PartyRelationshipType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void PartyRelationshipType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PartyRelationshipType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.PartyRelationshipType.enum_value)
}
inline void PartyRelationshipType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.PartyRelationshipType.enum_value)
}
inline void PartyRelationshipType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.PartyRelationshipType.enum_value)
}
inline std::string* PartyRelationshipType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PartyRelationshipType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.PartyRelationshipType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyRelationshipType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.PartyRelationshipType.enum_value)
}

// -------------------------------------------------------------------

// Period

// optional string enum_value = 1;
inline bool Period::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Period::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void Period::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Period::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.Period.enum_value)
  return _internal_enum_value();
}
inline void Period::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.Period.enum_value)
}
inline std::string* Period::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.Period.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& Period::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void Period::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Period::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.Period.enum_value)
}
inline void Period::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.Period.enum_value)
}
inline void Period::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.Period.enum_value)
}
inline std::string* Period::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Period::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.Period.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Period::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.Period.enum_value)
}

// -------------------------------------------------------------------

// PriceInformationType

// optional string enum_value = 1;
inline bool PriceInformationType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PriceInformationType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void PriceInformationType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PriceInformationType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.PriceInformationType.enum_value)
  return _internal_enum_value();
}
inline void PriceInformationType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.PriceInformationType.enum_value)
}
inline std::string* PriceInformationType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.PriceInformationType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& PriceInformationType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void PriceInformationType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PriceInformationType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.PriceInformationType.enum_value)
}
inline void PriceInformationType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.PriceInformationType.enum_value)
}
inline void PriceInformationType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.PriceInformationType.enum_value)
}
inline std::string* PriceInformationType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PriceInformationType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.PriceInformationType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PriceInformationType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.PriceInformationType.enum_value)
}

// -------------------------------------------------------------------

// PriceType

// optional string auto_value = 1;
inline bool PriceType::_internal_has_auto_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PriceType::has_auto_value() const {
  return _internal_has_auto_value();
}
inline void PriceType::clear_auto_value() {
  auto_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PriceType::auto_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.PriceType.auto_value)
  return _internal_auto_value();
}
inline void PriceType::set_auto_value(const std::string& value) {
  _internal_set_auto_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.PriceType.auto_value)
}
inline std::string* PriceType::mutable_auto_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.PriceType.auto_value)
  return _internal_mutable_auto_value();
}
inline const std::string& PriceType::_internal_auto_value() const {
  return auto_value_.Get();
}
inline void PriceType::_internal_set_auto_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  auto_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PriceType::set_auto_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  auto_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.PriceType.auto_value)
}
inline void PriceType::set_auto_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  auto_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.PriceType.auto_value)
}
inline void PriceType::set_auto_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  auto_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.PriceType.auto_value)
}
inline std::string* PriceType::_internal_mutable_auto_value() {
  _has_bits_[0] |= 0x00000001u;
  return auto_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PriceType::release_auto_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.PriceType.auto_value)
  if (!_internal_has_auto_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return auto_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PriceType::set_allocated_auto_value(std::string* auto_value) {
  if (auto_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  auto_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auto_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.PriceType.auto_value)
}

// -------------------------------------------------------------------

// Purpose

// optional string enum_value = 1;
inline bool Purpose::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Purpose::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void Purpose::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Purpose::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.Purpose.enum_value)
  return _internal_enum_value();
}
inline void Purpose::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.Purpose.enum_value)
}
inline std::string* Purpose::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.Purpose.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& Purpose::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void Purpose::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Purpose::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.Purpose.enum_value)
}
inline void Purpose::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.Purpose.enum_value)
}
inline void Purpose::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.Purpose.enum_value)
}
inline std::string* Purpose::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Purpose::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.Purpose.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Purpose::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.Purpose.enum_value)
}

// -------------------------------------------------------------------

// RatingAgency

// optional string enum_value = 1;
inline bool RatingAgency::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RatingAgency::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RatingAgency::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RatingAgency::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.RatingAgency.enum_value)
  return _internal_enum_value();
}
inline void RatingAgency::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.RatingAgency.enum_value)
}
inline std::string* RatingAgency::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.RatingAgency.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RatingAgency::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RatingAgency::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RatingAgency::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.RatingAgency.enum_value)
}
inline void RatingAgency::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.RatingAgency.enum_value)
}
inline void RatingAgency::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.RatingAgency.enum_value)
}
inline std::string* RatingAgency::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RatingAgency::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.RatingAgency.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RatingAgency::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.RatingAgency.enum_value)
}

// -------------------------------------------------------------------

// RatingReason

// optional string enum_value = 1;
inline bool RatingReason::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RatingReason::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RatingReason::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RatingReason::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.RatingReason.enum_value)
  return _internal_enum_value();
}
inline void RatingReason::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.RatingReason.enum_value)
}
inline std::string* RatingReason::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.RatingReason.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RatingReason::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RatingReason::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RatingReason::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.RatingReason.enum_value)
}
inline void RatingReason::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.RatingReason.enum_value)
}
inline void RatingReason::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.RatingReason.enum_value)
}
inline std::string* RatingReason::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RatingReason::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.RatingReason.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RatingReason::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.RatingReason.enum_value)
}

// -------------------------------------------------------------------

// RecordingMode

// optional string enum_value = 1;
inline bool RecordingMode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RecordingMode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RecordingMode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordingMode::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.RecordingMode.enum_value)
  return _internal_enum_value();
}
inline void RecordingMode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.RecordingMode.enum_value)
}
inline std::string* RecordingMode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.RecordingMode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RecordingMode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RecordingMode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RecordingMode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.RecordingMode.enum_value)
}
inline void RecordingMode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.RecordingMode.enum_value)
}
inline void RecordingMode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.RecordingMode.enum_value)
}
inline std::string* RecordingMode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RecordingMode::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.RecordingMode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RecordingMode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.RecordingMode.enum_value)
}

// -------------------------------------------------------------------

// ReferenceCreation

// optional string enum_value = 1;
inline bool ReferenceCreation::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReferenceCreation::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReferenceCreation::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReferenceCreation::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ReferenceCreation.enum_value)
  return _internal_enum_value();
}
inline void ReferenceCreation::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ReferenceCreation.enum_value)
}
inline std::string* ReferenceCreation::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ReferenceCreation.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReferenceCreation::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReferenceCreation::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReferenceCreation::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ReferenceCreation.enum_value)
}
inline void ReferenceCreation::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ReferenceCreation.enum_value)
}
inline void ReferenceCreation::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ReferenceCreation.enum_value)
}
inline std::string* ReferenceCreation::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReferenceCreation::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ReferenceCreation.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReferenceCreation::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ReferenceCreation.enum_value)
}

// -------------------------------------------------------------------

// RelationalRelator

// optional string enum_value = 1;
inline bool RelationalRelator::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RelationalRelator::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RelationalRelator::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RelationalRelator::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.RelationalRelator.enum_value)
  return _internal_enum_value();
}
inline void RelationalRelator::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.RelationalRelator.enum_value)
}
inline std::string* RelationalRelator::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.RelationalRelator.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RelationalRelator::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RelationalRelator::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RelationalRelator::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.RelationalRelator.enum_value)
}
inline void RelationalRelator::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.RelationalRelator.enum_value)
}
inline void RelationalRelator::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.RelationalRelator.enum_value)
}
inline std::string* RelationalRelator::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RelationalRelator::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.RelationalRelator.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RelationalRelator::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.RelationalRelator.enum_value)
}

// -------------------------------------------------------------------

// ReleaseProfileVariantVersionId

// optional string enum_value = 1;
inline bool ReleaseProfileVariantVersionId::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReleaseProfileVariantVersionId::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReleaseProfileVariantVersionId::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReleaseProfileVariantVersionId::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ReleaseProfileVariantVersionId.enum_value)
  return _internal_enum_value();
}
inline void ReleaseProfileVariantVersionId::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ReleaseProfileVariantVersionId.enum_value)
}
inline std::string* ReleaseProfileVariantVersionId::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ReleaseProfileVariantVersionId.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReleaseProfileVariantVersionId::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReleaseProfileVariantVersionId::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReleaseProfileVariantVersionId::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ReleaseProfileVariantVersionId.enum_value)
}
inline void ReleaseProfileVariantVersionId::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ReleaseProfileVariantVersionId.enum_value)
}
inline void ReleaseProfileVariantVersionId::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ReleaseProfileVariantVersionId.enum_value)
}
inline std::string* ReleaseProfileVariantVersionId::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReleaseProfileVariantVersionId::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ReleaseProfileVariantVersionId.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReleaseProfileVariantVersionId::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ReleaseProfileVariantVersionId.enum_value)
}

// -------------------------------------------------------------------

// ReleaseProfileVersionId

// optional string enum_value = 1;
inline bool ReleaseProfileVersionId::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReleaseProfileVersionId::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReleaseProfileVersionId::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReleaseProfileVersionId::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ReleaseProfileVersionId.enum_value)
  return _internal_enum_value();
}
inline void ReleaseProfileVersionId::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ReleaseProfileVersionId.enum_value)
}
inline std::string* ReleaseProfileVersionId::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ReleaseProfileVersionId.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReleaseProfileVersionId::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReleaseProfileVersionId::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReleaseProfileVersionId::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ReleaseProfileVersionId.enum_value)
}
inline void ReleaseProfileVersionId::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ReleaseProfileVersionId.enum_value)
}
inline void ReleaseProfileVersionId::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ReleaseProfileVersionId.enum_value)
}
inline std::string* ReleaseProfileVersionId::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReleaseProfileVersionId::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ReleaseProfileVersionId.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReleaseProfileVersionId::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ReleaseProfileVersionId.enum_value)
}

// -------------------------------------------------------------------

// ReleaseRelationshipType

// optional string enum_value = 1;
inline bool ReleaseRelationshipType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReleaseRelationshipType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReleaseRelationshipType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReleaseRelationshipType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ReleaseRelationshipType.enum_value)
  return _internal_enum_value();
}
inline void ReleaseRelationshipType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ReleaseRelationshipType.enum_value)
}
inline std::string* ReleaseRelationshipType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ReleaseRelationshipType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReleaseRelationshipType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReleaseRelationshipType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReleaseRelationshipType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ReleaseRelationshipType.enum_value)
}
inline void ReleaseRelationshipType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ReleaseRelationshipType.enum_value)
}
inline void ReleaseRelationshipType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ReleaseRelationshipType.enum_value)
}
inline std::string* ReleaseRelationshipType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReleaseRelationshipType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ReleaseRelationshipType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReleaseRelationshipType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ReleaseRelationshipType.enum_value)
}

// -------------------------------------------------------------------

// ReleaseType_ERN4

// optional string enum_value = 1;
inline bool ReleaseType_ERN4::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReleaseType_ERN4::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReleaseType_ERN4::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReleaseType_ERN4::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ReleaseType_ERN4.enum_value)
  return _internal_enum_value();
}
inline void ReleaseType_ERN4::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ReleaseType_ERN4.enum_value)
}
inline std::string* ReleaseType_ERN4::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ReleaseType_ERN4.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReleaseType_ERN4::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReleaseType_ERN4::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReleaseType_ERN4::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ReleaseType_ERN4.enum_value)
}
inline void ReleaseType_ERN4::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ReleaseType_ERN4.enum_value)
}
inline void ReleaseType_ERN4::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ReleaseType_ERN4.enum_value)
}
inline std::string* ReleaseType_ERN4::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReleaseType_ERN4::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ReleaseType_ERN4.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReleaseType_ERN4::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ReleaseType_ERN4.enum_value)
}

// -------------------------------------------------------------------

// ResourceGroupType

// optional string enum_value = 1;
inline bool ResourceGroupType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResourceGroupType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ResourceGroupType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceGroupType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ResourceGroupType.enum_value)
  return _internal_enum_value();
}
inline void ResourceGroupType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ResourceGroupType.enum_value)
}
inline std::string* ResourceGroupType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ResourceGroupType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ResourceGroupType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ResourceGroupType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ResourceGroupType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ResourceGroupType.enum_value)
}
inline void ResourceGroupType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ResourceGroupType.enum_value)
}
inline void ResourceGroupType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ResourceGroupType.enum_value)
}
inline std::string* ResourceGroupType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ResourceGroupType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ResourceGroupType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ResourceGroupType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ResourceGroupType.enum_value)
}

// -------------------------------------------------------------------

// ResourceRelationshipType

// optional string enum_value = 1;
inline bool ResourceRelationshipType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResourceRelationshipType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ResourceRelationshipType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceRelationshipType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ResourceRelationshipType.enum_value)
  return _internal_enum_value();
}
inline void ResourceRelationshipType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ResourceRelationshipType.enum_value)
}
inline std::string* ResourceRelationshipType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ResourceRelationshipType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ResourceRelationshipType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ResourceRelationshipType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ResourceRelationshipType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ResourceRelationshipType.enum_value)
}
inline void ResourceRelationshipType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ResourceRelationshipType.enum_value)
}
inline void ResourceRelationshipType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ResourceRelationshipType.enum_value)
}
inline std::string* ResourceRelationshipType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ResourceRelationshipType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ResourceRelationshipType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ResourceRelationshipType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ResourceRelationshipType.enum_value)
}

// -------------------------------------------------------------------

// RightsClaimPolicyType

// optional string enum_value = 1;
inline bool RightsClaimPolicyType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RightsClaimPolicyType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RightsClaimPolicyType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RightsClaimPolicyType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.RightsClaimPolicyType.enum_value)
  return _internal_enum_value();
}
inline void RightsClaimPolicyType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.RightsClaimPolicyType.enum_value)
}
inline std::string* RightsClaimPolicyType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.RightsClaimPolicyType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RightsClaimPolicyType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RightsClaimPolicyType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RightsClaimPolicyType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.RightsClaimPolicyType.enum_value)
}
inline void RightsClaimPolicyType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.RightsClaimPolicyType.enum_value)
}
inline void RightsClaimPolicyType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.RightsClaimPolicyType.enum_value)
}
inline std::string* RightsClaimPolicyType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RightsClaimPolicyType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.RightsClaimPolicyType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RightsClaimPolicyType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.RightsClaimPolicyType.enum_value)
}

// -------------------------------------------------------------------

// RightsControllerRole

// optional string enum_value = 1;
inline bool RightsControllerRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RightsControllerRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RightsControllerRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RightsControllerRole::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.RightsControllerRole.enum_value)
  return _internal_enum_value();
}
inline void RightsControllerRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.RightsControllerRole.enum_value)
}
inline std::string* RightsControllerRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.RightsControllerRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RightsControllerRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RightsControllerRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RightsControllerRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.RightsControllerRole.enum_value)
}
inline void RightsControllerRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.RightsControllerRole.enum_value)
}
inline void RightsControllerRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.RightsControllerRole.enum_value)
}
inline std::string* RightsControllerRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RightsControllerRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.RightsControllerRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RightsControllerRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.RightsControllerRole.enum_value)
}

// -------------------------------------------------------------------

// RightsControllerType

// optional string enum_value = 1;
inline bool RightsControllerType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RightsControllerType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RightsControllerType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RightsControllerType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.RightsControllerType.enum_value)
  return _internal_enum_value();
}
inline void RightsControllerType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.RightsControllerType.enum_value)
}
inline std::string* RightsControllerType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.RightsControllerType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RightsControllerType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RightsControllerType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RightsControllerType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.RightsControllerType.enum_value)
}
inline void RightsControllerType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.RightsControllerType.enum_value)
}
inline void RightsControllerType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.RightsControllerType.enum_value)
}
inline std::string* RightsControllerType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RightsControllerType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.RightsControllerType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RightsControllerType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.RightsControllerType.enum_value)
}

// -------------------------------------------------------------------

// RightsCoverage

// optional string enum_value = 1;
inline bool RightsCoverage::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RightsCoverage::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RightsCoverage::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RightsCoverage::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.RightsCoverage.enum_value)
  return _internal_enum_value();
}
inline void RightsCoverage::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.RightsCoverage.enum_value)
}
inline std::string* RightsCoverage::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.RightsCoverage.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RightsCoverage::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RightsCoverage::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RightsCoverage::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.RightsCoverage.enum_value)
}
inline void RightsCoverage::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.RightsCoverage.enum_value)
}
inline void RightsCoverage::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.RightsCoverage.enum_value)
}
inline std::string* RightsCoverage::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RightsCoverage::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.RightsCoverage.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RightsCoverage::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.RightsCoverage.enum_value)
}

// -------------------------------------------------------------------

// SheetMusicCodecType

// optional string auto_value = 1;
inline bool SheetMusicCodecType::_internal_has_auto_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SheetMusicCodecType::has_auto_value() const {
  return _internal_has_auto_value();
}
inline void SheetMusicCodecType::clear_auto_value() {
  auto_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SheetMusicCodecType::auto_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.SheetMusicCodecType.auto_value)
  return _internal_auto_value();
}
inline void SheetMusicCodecType::set_auto_value(const std::string& value) {
  _internal_set_auto_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.SheetMusicCodecType.auto_value)
}
inline std::string* SheetMusicCodecType::mutable_auto_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.SheetMusicCodecType.auto_value)
  return _internal_mutable_auto_value();
}
inline const std::string& SheetMusicCodecType::_internal_auto_value() const {
  return auto_value_.Get();
}
inline void SheetMusicCodecType::_internal_set_auto_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  auto_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SheetMusicCodecType::set_auto_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  auto_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.SheetMusicCodecType.auto_value)
}
inline void SheetMusicCodecType::set_auto_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  auto_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.SheetMusicCodecType.auto_value)
}
inline void SheetMusicCodecType::set_auto_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  auto_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.SheetMusicCodecType.auto_value)
}
inline std::string* SheetMusicCodecType::_internal_mutable_auto_value() {
  _has_bits_[0] |= 0x00000001u;
  return auto_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SheetMusicCodecType::release_auto_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.SheetMusicCodecType.auto_value)
  if (!_internal_has_auto_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return auto_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SheetMusicCodecType::set_allocated_auto_value(std::string* auto_value) {
  if (auto_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  auto_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auto_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.SheetMusicCodecType.auto_value)
}

// -------------------------------------------------------------------

// SheetMusicType

// optional string auto_value = 1;
inline bool SheetMusicType::_internal_has_auto_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SheetMusicType::has_auto_value() const {
  return _internal_has_auto_value();
}
inline void SheetMusicType::clear_auto_value() {
  auto_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SheetMusicType::auto_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.SheetMusicType.auto_value)
  return _internal_auto_value();
}
inline void SheetMusicType::set_auto_value(const std::string& value) {
  _internal_set_auto_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.SheetMusicType.auto_value)
}
inline std::string* SheetMusicType::mutable_auto_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.SheetMusicType.auto_value)
  return _internal_mutable_auto_value();
}
inline const std::string& SheetMusicType::_internal_auto_value() const {
  return auto_value_.Get();
}
inline void SheetMusicType::_internal_set_auto_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  auto_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SheetMusicType::set_auto_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  auto_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.SheetMusicType.auto_value)
}
inline void SheetMusicType::set_auto_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  auto_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.SheetMusicType.auto_value)
}
inline void SheetMusicType::set_auto_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  auto_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.SheetMusicType.auto_value)
}
inline std::string* SheetMusicType::_internal_mutable_auto_value() {
  _has_bits_[0] |= 0x00000001u;
  return auto_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SheetMusicType::release_auto_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.SheetMusicType.auto_value)
  if (!_internal_has_auto_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return auto_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SheetMusicType::set_allocated_auto_value(std::string* auto_value) {
  if (auto_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  auto_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auto_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.SheetMusicType.auto_value)
}

// -------------------------------------------------------------------

// SoftwareType

// optional string enum_value = 1;
inline bool SoftwareType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SoftwareType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void SoftwareType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SoftwareType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.SoftwareType.enum_value)
  return _internal_enum_value();
}
inline void SoftwareType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.SoftwareType.enum_value)
}
inline std::string* SoftwareType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.SoftwareType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& SoftwareType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void SoftwareType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SoftwareType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.SoftwareType.enum_value)
}
inline void SoftwareType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.SoftwareType.enum_value)
}
inline void SoftwareType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.SoftwareType.enum_value)
}
inline std::string* SoftwareType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SoftwareType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.SoftwareType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SoftwareType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.SoftwareType.enum_value)
}

// -------------------------------------------------------------------

// SoundRecordingType

// optional string enum_value = 1;
inline bool SoundRecordingType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SoundRecordingType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void SoundRecordingType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SoundRecordingType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.SoundRecordingType.enum_value)
  return _internal_enum_value();
}
inline void SoundRecordingType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.SoundRecordingType.enum_value)
}
inline std::string* SoundRecordingType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.SoundRecordingType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& SoundRecordingType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void SoundRecordingType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SoundRecordingType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.SoundRecordingType.enum_value)
}
inline void SoundRecordingType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.SoundRecordingType.enum_value)
}
inline void SoundRecordingType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.SoundRecordingType.enum_value)
}
inline std::string* SoundRecordingType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SoundRecordingType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.SoundRecordingType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SoundRecordingType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.SoundRecordingType.enum_value)
}

// -------------------------------------------------------------------

// SubTitleType

// optional string enum_value = 1;
inline bool SubTitleType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubTitleType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void SubTitleType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubTitleType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.SubTitleType.enum_value)
  return _internal_enum_value();
}
inline void SubTitleType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.SubTitleType.enum_value)
}
inline std::string* SubTitleType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.SubTitleType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& SubTitleType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void SubTitleType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubTitleType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.SubTitleType.enum_value)
}
inline void SubTitleType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.SubTitleType.enum_value)
}
inline void SubTitleType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.SubTitleType.enum_value)
}
inline std::string* SubTitleType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubTitleType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.SubTitleType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubTitleType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.SubTitleType.enum_value)
}

// -------------------------------------------------------------------

// TerritoryCodeType

// optional string enum_value = 1;
inline bool TerritoryCodeType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TerritoryCodeType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TerritoryCodeType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TerritoryCodeType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.TerritoryCodeType.enum_value)
  return _internal_enum_value();
}
inline void TerritoryCodeType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.TerritoryCodeType.enum_value)
}
inline std::string* TerritoryCodeType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.TerritoryCodeType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TerritoryCodeType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TerritoryCodeType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TerritoryCodeType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.TerritoryCodeType.enum_value)
}
inline void TerritoryCodeType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.TerritoryCodeType.enum_value)
}
inline void TerritoryCodeType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.TerritoryCodeType.enum_value)
}
inline std::string* TerritoryCodeType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TerritoryCodeType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.TerritoryCodeType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TerritoryCodeType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.TerritoryCodeType.enum_value)
}

// -------------------------------------------------------------------

// TerritoryCodeTypeIncludingDeprecatedCodes

// optional string enum_value = 1;
inline bool TerritoryCodeTypeIncludingDeprecatedCodes::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TerritoryCodeTypeIncludingDeprecatedCodes::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TerritoryCodeTypeIncludingDeprecatedCodes::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
  return _internal_enum_value();
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
}
inline std::string* TerritoryCodeTypeIncludingDeprecatedCodes::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TerritoryCodeTypeIncludingDeprecatedCodes::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
}
inline std::string* TerritoryCodeTypeIncludingDeprecatedCodes::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TerritoryCodeTypeIncludingDeprecatedCodes::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
}

// -------------------------------------------------------------------

// TextCodecType

// optional string enum_value = 1;
inline bool TextCodecType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TextCodecType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TextCodecType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextCodecType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.TextCodecType.enum_value)
  return _internal_enum_value();
}
inline void TextCodecType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.TextCodecType.enum_value)
}
inline std::string* TextCodecType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.TextCodecType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TextCodecType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TextCodecType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TextCodecType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.TextCodecType.enum_value)
}
inline void TextCodecType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.TextCodecType.enum_value)
}
inline void TextCodecType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.TextCodecType.enum_value)
}
inline std::string* TextCodecType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TextCodecType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.TextCodecType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextCodecType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.TextCodecType.enum_value)
}

// -------------------------------------------------------------------

// TextType

// optional string enum_value = 1;
inline bool TextType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TextType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TextType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.TextType.enum_value)
  return _internal_enum_value();
}
inline void TextType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.TextType.enum_value)
}
inline std::string* TextType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.TextType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TextType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TextType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TextType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.TextType.enum_value)
}
inline void TextType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.TextType.enum_value)
}
inline void TextType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.TextType.enum_value)
}
inline std::string* TextType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TextType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.TextType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.TextType.enum_value)
}

// -------------------------------------------------------------------

// ThemeType

// optional string enum_value = 1;
inline bool ThemeType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ThemeType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ThemeType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ThemeType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.ThemeType.enum_value)
  return _internal_enum_value();
}
inline void ThemeType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.ThemeType.enum_value)
}
inline std::string* ThemeType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.ThemeType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ThemeType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ThemeType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ThemeType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.ThemeType.enum_value)
}
inline void ThemeType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.ThemeType.enum_value)
}
inline void ThemeType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.ThemeType.enum_value)
}
inline std::string* ThemeType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ThemeType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.ThemeType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ThemeType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.ThemeType.enum_value)
}

// -------------------------------------------------------------------

// TitleType

// optional string enum_value = 1;
inline bool TitleType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TitleType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TitleType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TitleType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.TitleType.enum_value)
  return _internal_enum_value();
}
inline void TitleType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.TitleType.enum_value)
}
inline std::string* TitleType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.TitleType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TitleType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TitleType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TitleType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.TitleType.enum_value)
}
inline void TitleType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.TitleType.enum_value)
}
inline void TitleType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.TitleType.enum_value)
}
inline std::string* TitleType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TitleType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.TitleType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TitleType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.TitleType.enum_value)
}

// -------------------------------------------------------------------

// UnitOfBitRate

// optional string enum_value = 1;
inline bool UnitOfBitRate::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOfBitRate::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UnitOfBitRate::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitOfBitRate::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.UnitOfBitRate.enum_value)
  return _internal_enum_value();
}
inline void UnitOfBitRate::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.UnitOfBitRate.enum_value)
}
inline std::string* UnitOfBitRate::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.UnitOfBitRate.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UnitOfBitRate::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UnitOfBitRate::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitOfBitRate::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.UnitOfBitRate.enum_value)
}
inline void UnitOfBitRate::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.UnitOfBitRate.enum_value)
}
inline void UnitOfBitRate::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.UnitOfBitRate.enum_value)
}
inline std::string* UnitOfBitRate::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitOfBitRate::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.UnitOfBitRate.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitOfBitRate::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.UnitOfBitRate.enum_value)
}

// -------------------------------------------------------------------

// UnitOfConditionValue

// optional string enum_value = 1;
inline bool UnitOfConditionValue::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOfConditionValue::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UnitOfConditionValue::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitOfConditionValue::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.UnitOfConditionValue.enum_value)
  return _internal_enum_value();
}
inline void UnitOfConditionValue::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.UnitOfConditionValue.enum_value)
}
inline std::string* UnitOfConditionValue::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.UnitOfConditionValue.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UnitOfConditionValue::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UnitOfConditionValue::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitOfConditionValue::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.UnitOfConditionValue.enum_value)
}
inline void UnitOfConditionValue::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.UnitOfConditionValue.enum_value)
}
inline void UnitOfConditionValue::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.UnitOfConditionValue.enum_value)
}
inline std::string* UnitOfConditionValue::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitOfConditionValue::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.UnitOfConditionValue.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitOfConditionValue::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.UnitOfConditionValue.enum_value)
}

// -------------------------------------------------------------------

// UnitOfExtent

// optional string enum_value = 1;
inline bool UnitOfExtent::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOfExtent::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UnitOfExtent::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitOfExtent::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.UnitOfExtent.enum_value)
  return _internal_enum_value();
}
inline void UnitOfExtent::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.UnitOfExtent.enum_value)
}
inline std::string* UnitOfExtent::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.UnitOfExtent.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UnitOfExtent::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UnitOfExtent::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitOfExtent::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.UnitOfExtent.enum_value)
}
inline void UnitOfExtent::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.UnitOfExtent.enum_value)
}
inline void UnitOfExtent::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.UnitOfExtent.enum_value)
}
inline std::string* UnitOfExtent::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitOfExtent::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.UnitOfExtent.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitOfExtent::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.UnitOfExtent.enum_value)
}

// -------------------------------------------------------------------

// UnitOfFrameRate

// optional string enum_value = 1;
inline bool UnitOfFrameRate::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOfFrameRate::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UnitOfFrameRate::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitOfFrameRate::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.UnitOfFrameRate.enum_value)
  return _internal_enum_value();
}
inline void UnitOfFrameRate::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.UnitOfFrameRate.enum_value)
}
inline std::string* UnitOfFrameRate::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.UnitOfFrameRate.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UnitOfFrameRate::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UnitOfFrameRate::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitOfFrameRate::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.UnitOfFrameRate.enum_value)
}
inline void UnitOfFrameRate::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.UnitOfFrameRate.enum_value)
}
inline void UnitOfFrameRate::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.UnitOfFrameRate.enum_value)
}
inline std::string* UnitOfFrameRate::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitOfFrameRate::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.UnitOfFrameRate.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitOfFrameRate::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.UnitOfFrameRate.enum_value)
}

// -------------------------------------------------------------------

// UnitOfFrequency

// optional string enum_value = 1;
inline bool UnitOfFrequency::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOfFrequency::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UnitOfFrequency::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitOfFrequency::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.UnitOfFrequency.enum_value)
  return _internal_enum_value();
}
inline void UnitOfFrequency::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.UnitOfFrequency.enum_value)
}
inline std::string* UnitOfFrequency::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.UnitOfFrequency.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UnitOfFrequency::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UnitOfFrequency::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitOfFrequency::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.UnitOfFrequency.enum_value)
}
inline void UnitOfFrequency::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.UnitOfFrequency.enum_value)
}
inline void UnitOfFrequency::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.UnitOfFrequency.enum_value)
}
inline std::string* UnitOfFrequency::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitOfFrequency::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.UnitOfFrequency.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitOfFrequency::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.UnitOfFrequency.enum_value)
}

// -------------------------------------------------------------------

// UseType

// optional string enum_value = 1;
inline bool UseType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UseType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UseType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UseType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.UseType.enum_value)
  return _internal_enum_value();
}
inline void UseType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.UseType.enum_value)
}
inline std::string* UseType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.UseType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UseType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UseType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UseType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.UseType.enum_value)
}
inline void UseType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.UseType.enum_value)
}
inline void UseType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.UseType.enum_value)
}
inline std::string* UseType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UseType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.UseType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UseType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.UseType.enum_value)
}

// -------------------------------------------------------------------

// VersionType

// optional string enum_value = 1;
inline bool VersionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VersionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VersionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VersionType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.VersionType.enum_value)
  return _internal_enum_value();
}
inline void VersionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.VersionType.enum_value)
}
inline std::string* VersionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.VersionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VersionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VersionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VersionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.VersionType.enum_value)
}
inline void VersionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.VersionType.enum_value)
}
inline void VersionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.VersionType.enum_value)
}
inline std::string* VersionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VersionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.VersionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VersionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.VersionType.enum_value)
}

// -------------------------------------------------------------------

// VideoCodecType

// optional string enum_value = 1;
inline bool VideoCodecType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoCodecType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VideoCodecType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoCodecType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.VideoCodecType.enum_value)
  return _internal_enum_value();
}
inline void VideoCodecType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.VideoCodecType.enum_value)
}
inline std::string* VideoCodecType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.VideoCodecType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VideoCodecType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VideoCodecType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoCodecType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.VideoCodecType.enum_value)
}
inline void VideoCodecType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.VideoCodecType.enum_value)
}
inline void VideoCodecType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.VideoCodecType.enum_value)
}
inline std::string* VideoCodecType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoCodecType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.VideoCodecType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoCodecType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.VideoCodecType.enum_value)
}

// -------------------------------------------------------------------

// VideoDefinitionType

// optional string enum_value = 1;
inline bool VideoDefinitionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoDefinitionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VideoDefinitionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoDefinitionType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.VideoDefinitionType.enum_value)
  return _internal_enum_value();
}
inline void VideoDefinitionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.VideoDefinitionType.enum_value)
}
inline std::string* VideoDefinitionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.VideoDefinitionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VideoDefinitionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VideoDefinitionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoDefinitionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.VideoDefinitionType.enum_value)
}
inline void VideoDefinitionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.VideoDefinitionType.enum_value)
}
inline void VideoDefinitionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.VideoDefinitionType.enum_value)
}
inline std::string* VideoDefinitionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoDefinitionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.VideoDefinitionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoDefinitionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.VideoDefinitionType.enum_value)
}

// -------------------------------------------------------------------

// VideoType

// optional string enum_value = 1;
inline bool VideoType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VideoType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.VideoType.enum_value)
  return _internal_enum_value();
}
inline void VideoType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.VideoType.enum_value)
}
inline std::string* VideoType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.VideoType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VideoType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VideoType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.VideoType.enum_value)
}
inline void VideoType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.VideoType.enum_value)
}
inline void VideoType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.VideoType.enum_value)
}
inline std::string* VideoType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.VideoType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.VideoType.enum_value)
}

// -------------------------------------------------------------------

// VisualPerceptionType

// optional string enum_value = 1;
inline bool VisualPerceptionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VisualPerceptionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VisualPerceptionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VisualPerceptionType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.VisualPerceptionType.enum_value)
  return _internal_enum_value();
}
inline void VisualPerceptionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.VisualPerceptionType.enum_value)
}
inline std::string* VisualPerceptionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.VisualPerceptionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VisualPerceptionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VisualPerceptionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VisualPerceptionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.VisualPerceptionType.enum_value)
}
inline void VisualPerceptionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.VisualPerceptionType.enum_value)
}
inline void VisualPerceptionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.VisualPerceptionType.enum_value)
}
inline std::string* VisualPerceptionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VisualPerceptionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.VisualPerceptionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VisualPerceptionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.VisualPerceptionType.enum_value)
}

// -------------------------------------------------------------------

// VocalType

// optional string enum_value = 1;
inline bool VocalType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VocalType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VocalType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VocalType::enum_value() const {
  // @@protoc_insertion_point(field_get:ern411.avs.VocalType.enum_value)
  return _internal_enum_value();
}
inline void VocalType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:ern411.avs.VocalType.enum_value)
}
inline std::string* VocalType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:ern411.avs.VocalType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VocalType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VocalType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VocalType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ern411.avs.VocalType.enum_value)
}
inline void VocalType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ern411.avs.VocalType.enum_value)
}
inline void VocalType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ern411.avs.VocalType.enum_value)
}
inline std::string* VocalType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VocalType::release_enum_value() {
  // @@protoc_insertion_point(field_release:ern411.avs.VocalType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VocalType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ern411.avs.VocalType.enum_value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace avs
}  // namespace ern411

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ddex_2dxmltoproto_2fgenerated_2fern42_2favs_2eproto
