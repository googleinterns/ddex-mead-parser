// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ddex-xmltoproto/generated/mead101/avs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[191]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
namespace mead101 {
namespace avs {
class AdditionalTitleType;
class AdditionalTitleTypeDefaultTypeInternal;
extern AdditionalTitleTypeDefaultTypeInternal _AdditionalTitleType_default_instance_;
class AdditionalUseType;
class AdditionalUseTypeDefaultTypeInternal;
extern AdditionalUseTypeDefaultTypeInternal _AdditionalUseType_default_instance_;
class AdditionalVideoType;
class AdditionalVideoTypeDefaultTypeInternal;
extern AdditionalVideoTypeDefaultTypeInternal _AdditionalVideoType_default_instance_;
class AdministratingRecordCompanyRole;
class AdministratingRecordCompanyRoleDefaultTypeInternal;
extern AdministratingRecordCompanyRoleDefaultTypeInternal _AdministratingRecordCompanyRole_default_instance_;
class AffiliationType;
class AffiliationTypeDefaultTypeInternal;
extern AffiliationTypeDefaultTypeInternal _AffiliationType_default_instance_;
class AllTerritoryCode;
class AllTerritoryCodeDefaultTypeInternal;
extern AllTerritoryCodeDefaultTypeInternal _AllTerritoryCode_default_instance_;
class ArtistRole;
class ArtistRoleDefaultTypeInternal;
extern ArtistRoleDefaultTypeInternal _ArtistRole_default_instance_;
class ArtistType;
class ArtistTypeDefaultTypeInternal;
extern ArtistTypeDefaultTypeInternal _ArtistType_default_instance_;
class AspectRatioType;
class AspectRatioTypeDefaultTypeInternal;
extern AspectRatioTypeDefaultTypeInternal _AspectRatioType_default_instance_;
class AsserterType;
class AsserterTypeDefaultTypeInternal;
extern AsserterTypeDefaultTypeInternal _AsserterType_default_instance_;
class AudioCodecType;
class AudioCodecTypeDefaultTypeInternal;
extern AudioCodecTypeDefaultTypeInternal _AudioCodecType_default_instance_;
class AvsVersionId;
class AvsVersionIdDefaultTypeInternal;
extern AvsVersionIdDefaultTypeInternal _AvsVersionId_default_instance_;
class BinaryDataType;
class BinaryDataTypeDefaultTypeInternal;
extern BinaryDataTypeDefaultTypeInternal _BinaryDataType_default_instance_;
class BusinessMusicalWorkContributorRole;
class BusinessMusicalWorkContributorRoleDefaultTypeInternal;
extern BusinessMusicalWorkContributorRoleDefaultTypeInternal _BusinessMusicalWorkContributorRole_default_instance_;
class CarrierType;
class CarrierTypeDefaultTypeInternal;
extern CarrierTypeDefaultTypeInternal _CarrierType_default_instance_;
class CatalogTransferType;
class CatalogTransferTypeDefaultTypeInternal;
extern CatalogTransferTypeDefaultTypeInternal _CatalogTransferType_default_instance_;
class CdProtectionType;
class CdProtectionTypeDefaultTypeInternal;
extern CdProtectionTypeDefaultTypeInternal _CdProtectionType_default_instance_;
class CharacterType;
class CharacterTypeDefaultTypeInternal;
extern CharacterTypeDefaultTypeInternal _CharacterType_default_instance_;
class ClaimStatus;
class ClaimStatusDefaultTypeInternal;
extern ClaimStatusDefaultTypeInternal _ClaimStatus_default_instance_;
class ClassifiedGenre;
class ClassifiedGenreDefaultTypeInternal;
extern ClassifiedGenreDefaultTypeInternal _ClassifiedGenre_default_instance_;
class CodingType;
class CodingTypeDefaultTypeInternal;
extern CodingTypeDefaultTypeInternal _CodingType_default_instance_;
class CommentaryNoteType;
class CommentaryNoteTypeDefaultTypeInternal;
extern CommentaryNoteTypeDefaultTypeInternal _CommentaryNoteType_default_instance_;
class CommercialModelType;
class CommercialModelTypeDefaultTypeInternal;
extern CommercialModelTypeDefaultTypeInternal _CommercialModelType_default_instance_;
class CommercialModelType_MWNL;
class CommercialModelType_MWNLDefaultTypeInternal;
extern CommercialModelType_MWNLDefaultTypeInternal _CommercialModelType_MWNL_default_instance_;
class CompilationType;
class CompilationTypeDefaultTypeInternal;
extern CompilationTypeDefaultTypeInternal _CompilationType_default_instance_;
class CompositeMusicalWorkType;
class CompositeMusicalWorkTypeDefaultTypeInternal;
extern CompositeMusicalWorkTypeDefaultTypeInternal _CompositeMusicalWorkType_default_instance_;
class ContainerFormat;
class ContainerFormatDefaultTypeInternal;
extern ContainerFormatDefaultTypeInternal _ContainerFormat_default_instance_;
class ContributorRole;
class ContributorRoleDefaultTypeInternal;
extern ContributorRoleDefaultTypeInternal _ContributorRole_default_instance_;
class CreativeMusicalWorkContributorRole;
class CreativeMusicalWorkContributorRoleDefaultTypeInternal;
extern CreativeMusicalWorkContributorRoleDefaultTypeInternal _CreativeMusicalWorkContributorRole_default_instance_;
class CueOrigin;
class CueOriginDefaultTypeInternal;
extern CueOriginDefaultTypeInternal _CueOrigin_default_instance_;
class CueSheetType;
class CueSheetTypeDefaultTypeInternal;
extern CueSheetTypeDefaultTypeInternal _CueSheetType_default_instance_;
class CueUseType;
class CueUseTypeDefaultTypeInternal;
extern CueUseTypeDefaultTypeInternal _CueUseType_default_instance_;
class CurrencyCode;
class CurrencyCodeDefaultTypeInternal;
extern CurrencyCodeDefaultTypeInternal _CurrencyCode_default_instance_;
class CurrentTerritoryCode;
class CurrentTerritoryCodeDefaultTypeInternal;
extern CurrentTerritoryCodeDefaultTypeInternal _CurrentTerritoryCode_default_instance_;
class DanceAndRhythmStyle;
class DanceAndRhythmStyleDefaultTypeInternal;
extern DanceAndRhythmStyleDefaultTypeInternal _DanceAndRhythmStyle_default_instance_;
class DataCarrierFormat;
class DataCarrierFormatDefaultTypeInternal;
extern DataCarrierFormatDefaultTypeInternal _DataCarrierFormat_default_instance_;
class DataCarrierType;
class DataCarrierTypeDefaultTypeInternal;
extern DataCarrierTypeDefaultTypeInternal _DataCarrierType_default_instance_;
class DdexTerritoryCode;
class DdexTerritoryCodeDefaultTypeInternal;
extern DdexTerritoryCodeDefaultTypeInternal _DdexTerritoryCode_default_instance_;
class DeprecatedCurrencyCode;
class DeprecatedCurrencyCodeDefaultTypeInternal;
extern DeprecatedCurrencyCodeDefaultTypeInternal _DeprecatedCurrencyCode_default_instance_;
class DeprecatedIsoTerritoryCode;
class DeprecatedIsoTerritoryCodeDefaultTypeInternal;
extern DeprecatedIsoTerritoryCodeDefaultTypeInternal _DeprecatedIsoTerritoryCode_default_instance_;
class DeprecatedReleaseType;
class DeprecatedReleaseTypeDefaultTypeInternal;
extern DeprecatedReleaseTypeDefaultTypeInternal _DeprecatedReleaseType_default_instance_;
class DigitizationMode;
class DigitizationModeDefaultTypeInternal;
extern DigitizationModeDefaultTypeInternal _DigitizationMode_default_instance_;
class DisplayArtistRole;
class DisplayArtistRoleDefaultTypeInternal;
extern DisplayArtistRoleDefaultTypeInternal _DisplayArtistRole_default_instance_;
class DistributionChannelType;
class DistributionChannelTypeDefaultTypeInternal;
extern DistributionChannelTypeDefaultTypeInternal _DistributionChannelType_default_instance_;
class DocumentType_LoD;
class DocumentType_LoDDefaultTypeInternal;
extern DocumentType_LoDDefaultTypeInternal _DocumentType_LoD_default_instance_;
class DocumentType_MWL;
class DocumentType_MWLDefaultTypeInternal;
extern DocumentType_MWLDefaultTypeInternal _DocumentType_MWL_default_instance_;
class DpidStatus;
class DpidStatusDefaultTypeInternal;
extern DpidStatusDefaultTypeInternal _DpidStatus_default_instance_;
class DrmEnforcementType;
class DrmEnforcementTypeDefaultTypeInternal;
extern DrmEnforcementTypeDefaultTypeInternal _DrmEnforcementType_default_instance_;
class ElementConfiguration;
class ElementConfigurationDefaultTypeInternal;
extern ElementConfigurationDefaultTypeInternal _ElementConfiguration_default_instance_;
class ElementDesignation;
class ElementDesignationDefaultTypeInternal;
extern ElementDesignationDefaultTypeInternal _ElementDesignation_default_instance_;
class EncodingType;
class EncodingTypeDefaultTypeInternal;
extern EncodingTypeDefaultTypeInternal _EncodingType_default_instance_;
class EquipmentType;
class EquipmentTypeDefaultTypeInternal;
extern EquipmentTypeDefaultTypeInternal _EquipmentType_default_instance_;
class ErnMessageType;
class ErnMessageTypeDefaultTypeInternal;
extern ErnMessageTypeDefaultTypeInternal _ErnMessageType_default_instance_;
class ErnTestMessageType;
class ErnTestMessageTypeDefaultTypeInternal;
extern ErnTestMessageTypeDefaultTypeInternal _ErnTestMessageType_default_instance_;
class ErncFileStatus;
class ErncFileStatusDefaultTypeInternal;
extern ErncFileStatusDefaultTypeInternal _ErncFileStatus_default_instance_;
class ErncProposedActionType;
class ErncProposedActionTypeDefaultTypeInternal;
extern ErncProposedActionTypeDefaultTypeInternal _ErncProposedActionType_default_instance_;
class ErrorSeverity;
class ErrorSeverityDefaultTypeInternal;
extern ErrorSeverityDefaultTypeInternal _ErrorSeverity_default_instance_;
class ErrorType;
class ErrorTypeDefaultTypeInternal;
extern ErrorTypeDefaultTypeInternal _ErrorType_default_instance_;
class ExceptionReason;
class ExceptionReasonDefaultTypeInternal;
extern ExceptionReasonDefaultTypeInternal _ExceptionReason_default_instance_;
class ExpressionType;
class ExpressionTypeDefaultTypeInternal;
extern ExpressionTypeDefaultTypeInternal _ExpressionType_default_instance_;
class ExternallyLinkedResourceType;
class ExternallyLinkedResourceTypeDefaultTypeInternal;
extern ExternallyLinkedResourceTypeDefaultTypeInternal _ExternallyLinkedResourceType_default_instance_;
class FileType;
class FileTypeDefaultTypeInternal;
extern FileTypeDefaultTypeInternal _FileType_default_instance_;
class FingerprintAlgorithmType;
class FingerprintAlgorithmTypeDefaultTypeInternal;
extern FingerprintAlgorithmTypeDefaultTypeInternal _FingerprintAlgorithmType_default_instance_;
class Form;
class FormDefaultTypeInternal;
extern FormDefaultTypeInternal _Form_default_instance_;
class FrameRate;
class FrameRateDefaultTypeInternal;
extern FrameRateDefaultTypeInternal _FrameRate_default_instance_;
class Gender;
class GenderDefaultTypeInternal;
extern GenderDefaultTypeInternal _Gender_default_instance_;
class GoverningAgreementType;
class GoverningAgreementTypeDefaultTypeInternal;
extern GoverningAgreementTypeDefaultTypeInternal _GoverningAgreementType_default_instance_;
class HashSumAlgorithmType;
class HashSumAlgorithmTypeDefaultTypeInternal;
extern HashSumAlgorithmTypeDefaultTypeInternal _HashSumAlgorithmType_default_instance_;
class ImageCodecType;
class ImageCodecTypeDefaultTypeInternal;
extern ImageCodecTypeDefaultTypeInternal _ImageCodecType_default_instance_;
class ImageType;
class ImageTypeDefaultTypeInternal;
extern ImageTypeDefaultTypeInternal _ImageType_default_instance_;
class InstrumentType;
class InstrumentTypeDefaultTypeInternal;
extern InstrumentTypeDefaultTypeInternal _InstrumentType_default_instance_;
class Iso639Part12LanguageCode;
class Iso639Part12LanguageCodeDefaultTypeInternal;
extern Iso639Part12LanguageCodeDefaultTypeInternal _Iso639Part12LanguageCode_default_instance_;
class Iso639Part3LanguageCode;
class Iso639Part3LanguageCodeDefaultTypeInternal;
extern Iso639Part3LanguageCodeDefaultTypeInternal _Iso639Part3LanguageCode_default_instance_;
class IsoCurrencyCode;
class IsoCurrencyCodeDefaultTypeInternal;
extern IsoCurrencyCodeDefaultTypeInternal _IsoCurrencyCode_default_instance_;
class IsoLanguageCode;
class IsoLanguageCodeDefaultTypeInternal;
extern IsoLanguageCodeDefaultTypeInternal _IsoLanguageCode_default_instance_;
class IsoTerritoryCode;
class IsoTerritoryCodeDefaultTypeInternal;
extern IsoTerritoryCodeDefaultTypeInternal _IsoTerritoryCode_default_instance_;
class LabelNameType;
class LabelNameTypeDefaultTypeInternal;
extern LabelNameTypeDefaultTypeInternal _LabelNameType_default_instance_;
class LabelType;
class LabelTypeDefaultTypeInternal;
extern LabelTypeDefaultTypeInternal _LabelType_default_instance_;
class LanguageLocalizationType;
class LanguageLocalizationTypeDefaultTypeInternal;
extern LanguageLocalizationTypeDefaultTypeInternal _LanguageLocalizationType_default_instance_;
class LicenseRecord;
class LicenseRecordDefaultTypeInternal;
extern LicenseRecordDefaultTypeInternal _LicenseRecord_default_instance_;
class LicenseRefusalReason;
class LicenseRefusalReasonDefaultTypeInternal;
extern LicenseRefusalReasonDefaultTypeInternal _LicenseRefusalReason_default_instance_;
class LicenseRejectionReason;
class LicenseRejectionReasonDefaultTypeInternal;
extern LicenseRejectionReasonDefaultTypeInternal _LicenseRejectionReason_default_instance_;
class LinkAcknowledgementStatus;
class LinkAcknowledgementStatusDefaultTypeInternal;
extern LinkAcknowledgementStatusDefaultTypeInternal _LinkAcknowledgementStatus_default_instance_;
class LinkDescription;
class LinkDescriptionDefaultTypeInternal;
extern LinkDescriptionDefaultTypeInternal _LinkDescription_default_instance_;
class LyricsType;
class LyricsTypeDefaultTypeInternal;
extern LyricsTypeDefaultTypeInternal _LyricsType_default_instance_;
class MembershipType;
class MembershipTypeDefaultTypeInternal;
extern MembershipTypeDefaultTypeInternal _MembershipType_default_instance_;
class MessageActionType;
class MessageActionTypeDefaultTypeInternal;
extern MessageActionTypeDefaultTypeInternal _MessageActionType_default_instance_;
class MessageControlType;
class MessageControlTypeDefaultTypeInternal;
extern MessageControlTypeDefaultTypeInternal _MessageControlType_default_instance_;
class MessagePurpose;
class MessagePurposeDefaultTypeInternal;
extern MessagePurposeDefaultTypeInternal _MessagePurpose_default_instance_;
class MessageType;
class MessageTypeDefaultTypeInternal;
extern MessageTypeDefaultTypeInternal _MessageType_default_instance_;
class MetadataSourceType;
class MetadataSourceTypeDefaultTypeInternal;
extern MetadataSourceTypeDefaultTypeInternal _MetadataSourceType_default_instance_;
class MissingLinkReason;
class MissingLinkReasonDefaultTypeInternal;
extern MissingLinkReasonDefaultTypeInternal _MissingLinkReason_default_instance_;
class MlcMessageType;
class MlcMessageTypeDefaultTypeInternal;
extern MlcMessageTypeDefaultTypeInternal _MlcMessageType_default_instance_;
class Mode;
class ModeDefaultTypeInternal;
extern ModeDefaultTypeInternal _Mode_default_instance_;
class MoodType;
class MoodTypeDefaultTypeInternal;
extern MoodTypeDefaultTypeInternal _MoodType_default_instance_;
class MusicalWorkContributorRole;
class MusicalWorkContributorRoleDefaultTypeInternal;
extern MusicalWorkContributorRoleDefaultTypeInternal _MusicalWorkContributorRole_default_instance_;
class MusicalWorkType;
class MusicalWorkTypeDefaultTypeInternal;
extern MusicalWorkTypeDefaultTypeInternal _MusicalWorkType_default_instance_;
class MwnlFileStatus;
class MwnlFileStatusDefaultTypeInternal;
extern MwnlFileStatusDefaultTypeInternal _MwnlFileStatus_default_instance_;
class MwnlProposedActionType;
class MwnlProposedActionTypeDefaultTypeInternal;
extern MwnlProposedActionTypeDefaultTypeInternal _MwnlProposedActionType_default_instance_;
class NewStudioRole;
class NewStudioRoleDefaultTypeInternal;
extern NewStudioRoleDefaultTypeInternal _NewStudioRole_default_instance_;
class OperatingSystemType;
class OperatingSystemTypeDefaultTypeInternal;
extern OperatingSystemTypeDefaultTypeInternal _OperatingSystemType_default_instance_;
class PLineType;
class PLineTypeDefaultTypeInternal;
extern PLineTypeDefaultTypeInternal _PLineType_default_instance_;
class ParentalWarningType;
class ParentalWarningTypeDefaultTypeInternal;
extern ParentalWarningTypeDefaultTypeInternal _ParentalWarningType_default_instance_;
class PartyRelationshipType;
class PartyRelationshipTypeDefaultTypeInternal;
extern PartyRelationshipTypeDefaultTypeInternal _PartyRelationshipType_default_instance_;
class PercentageType;
class PercentageTypeDefaultTypeInternal;
extern PercentageTypeDefaultTypeInternal _PercentageType_default_instance_;
class Period;
class PeriodDefaultTypeInternal;
extern PeriodDefaultTypeInternal _Period_default_instance_;
class PhysicalCarrierType;
class PhysicalCarrierTypeDefaultTypeInternal;
extern PhysicalCarrierTypeDefaultTypeInternal _PhysicalCarrierType_default_instance_;
class PriceInformationType;
class PriceInformationTypeDefaultTypeInternal;
extern PriceInformationTypeDefaultTypeInternal _PriceInformationType_default_instance_;
class ProductType;
class ProductTypeDefaultTypeInternal;
extern ProductTypeDefaultTypeInternal _ProductType_default_instance_;
class ProfileId;
class ProfileIdDefaultTypeInternal;
extern ProfileIdDefaultTypeInternal _ProfileId_default_instance_;
class Purpose;
class PurposeDefaultTypeInternal;
extern PurposeDefaultTypeInternal _Purpose_default_instance_;
class RatingAgency;
class RatingAgencyDefaultTypeInternal;
extern RatingAgencyDefaultTypeInternal _RatingAgency_default_instance_;
class RatingReason;
class RatingReasonDefaultTypeInternal;
extern RatingReasonDefaultTypeInternal _RatingReason_default_instance_;
class RecipientRevenueType;
class RecipientRevenueTypeDefaultTypeInternal;
extern RecipientRevenueTypeDefaultTypeInternal _RecipientRevenueType_default_instance_;
class RecordingMode;
class RecordingModeDefaultTypeInternal;
extern RecordingModeDefaultTypeInternal _RecordingMode_default_instance_;
class RecordingPartType;
class RecordingPartTypeDefaultTypeInternal;
extern RecordingPartTypeDefaultTypeInternal _RecordingPartType_default_instance_;
class ReferenceCreation;
class ReferenceCreationDefaultTypeInternal;
extern ReferenceCreationDefaultTypeInternal _ReferenceCreation_default_instance_;
class ReferenceUnit;
class ReferenceUnitDefaultTypeInternal;
extern ReferenceUnitDefaultTypeInternal _ReferenceUnit_default_instance_;
class RegistrationStatus;
class RegistrationStatusDefaultTypeInternal;
extern RegistrationStatusDefaultTypeInternal _RegistrationStatus_default_instance_;
class RelatedResourceType;
class RelatedResourceTypeDefaultTypeInternal;
extern RelatedResourceTypeDefaultTypeInternal _RelatedResourceType_default_instance_;
class RelationalRelator;
class RelationalRelatorDefaultTypeInternal;
extern RelationalRelatorDefaultTypeInternal _RelationalRelator_default_instance_;
class ReleaseProfileVariantVersionId;
class ReleaseProfileVariantVersionIdDefaultTypeInternal;
extern ReleaseProfileVariantVersionIdDefaultTypeInternal _ReleaseProfileVariantVersionId_default_instance_;
class ReleaseProfileVersionId;
class ReleaseProfileVersionIdDefaultTypeInternal;
extern ReleaseProfileVersionIdDefaultTypeInternal _ReleaseProfileVersionId_default_instance_;
class ReleaseRelationshipType;
class ReleaseRelationshipTypeDefaultTypeInternal;
extern ReleaseRelationshipTypeDefaultTypeInternal _ReleaseRelationshipType_default_instance_;
class ReleaseResourceType;
class ReleaseResourceTypeDefaultTypeInternal;
extern ReleaseResourceTypeDefaultTypeInternal _ReleaseResourceType_default_instance_;
class ReleaseType;
class ReleaseTypeDefaultTypeInternal;
extern ReleaseTypeDefaultTypeInternal _ReleaseType_default_instance_;
class ReleaseType_ERN4;
class ReleaseType_ERN4DefaultTypeInternal;
extern ReleaseType_ERN4DefaultTypeInternal _ReleaseType_ERN4_default_instance_;
class ReleaseType_MCNOTIF;
class ReleaseType_MCNOTIFDefaultTypeInternal;
extern ReleaseType_MCNOTIFDefaultTypeInternal _ReleaseType_MCNOTIF_default_instance_;
class RequestMessagePurpose;
class RequestMessagePurposeDefaultTypeInternal;
extern RequestMessagePurposeDefaultTypeInternal _RequestMessagePurpose_default_instance_;
class RequestReason;
class RequestReasonDefaultTypeInternal;
extern RequestReasonDefaultTypeInternal _RequestReason_default_instance_;
class ResourceContributorRole;
class ResourceContributorRoleDefaultTypeInternal;
extern ResourceContributorRoleDefaultTypeInternal _ResourceContributorRole_default_instance_;
class ResourceGroupType;
class ResourceGroupTypeDefaultTypeInternal;
extern ResourceGroupTypeDefaultTypeInternal _ResourceGroupType_default_instance_;
class ResourceRelationshipType;
class ResourceRelationshipTypeDefaultTypeInternal;
extern ResourceRelationshipTypeDefaultTypeInternal _ResourceRelationshipType_default_instance_;
class ResourceType;
class ResourceTypeDefaultTypeInternal;
extern ResourceTypeDefaultTypeInternal _ResourceType_default_instance_;
class ResourceType_MCNOTIF;
class ResourceType_MCNOTIFDefaultTypeInternal;
extern ResourceType_MCNOTIFDefaultTypeInternal _ResourceType_MCNOTIF_default_instance_;
class ResourceWorkRelationshipType;
class ResourceWorkRelationshipTypeDefaultTypeInternal;
extern ResourceWorkRelationshipTypeDefaultTypeInternal _ResourceWorkRelationshipType_default_instance_;
class RevenueSourceType;
class RevenueSourceTypeDefaultTypeInternal;
extern RevenueSourceTypeDefaultTypeInternal _RevenueSourceType_default_instance_;
class RightShareType;
class RightShareTypeDefaultTypeInternal;
extern RightShareTypeDefaultTypeInternal _RightShareType_default_instance_;
class RightsClaimPolicyType;
class RightsClaimPolicyTypeDefaultTypeInternal;
extern RightsClaimPolicyTypeDefaultTypeInternal _RightsClaimPolicyType_default_instance_;
class RightsClaimStatus;
class RightsClaimStatusDefaultTypeInternal;
extern RightsClaimStatusDefaultTypeInternal _RightsClaimStatus_default_instance_;
class RightsControllerRole;
class RightsControllerRoleDefaultTypeInternal;
extern RightsControllerRoleDefaultTypeInternal _RightsControllerRole_default_instance_;
class RightsControllerType;
class RightsControllerTypeDefaultTypeInternal;
extern RightsControllerTypeDefaultTypeInternal _RightsControllerType_default_instance_;
class RightsCoverage;
class RightsCoverageDefaultTypeInternal;
extern RightsCoverageDefaultTypeInternal _RightsCoverage_default_instance_;
class RightsCoverage_MWNL;
class RightsCoverage_MWNLDefaultTypeInternal;
extern RightsCoverage_MWNLDefaultTypeInternal _RightsCoverage_MWNL_default_instance_;
class RightsStatementProfile;
class RightsStatementProfileDefaultTypeInternal;
extern RightsStatementProfileDefaultTypeInternal _RightsStatementProfile_default_instance_;
class RootChordNote;
class RootChordNoteDefaultTypeInternal;
extern RootChordNoteDefaultTypeInternal _RootChordNote_default_instance_;
class RootChordQuality;
class RootChordQualityDefaultTypeInternal;
extern RootChordQualityDefaultTypeInternal _RootChordQuality_default_instance_;
class RoyaltyRateCalculationType;
class RoyaltyRateCalculationTypeDefaultTypeInternal;
extern RoyaltyRateCalculationTypeDefaultTypeInternal _RoyaltyRateCalculationType_default_instance_;
class RoyaltyRateType;
class RoyaltyRateTypeDefaultTypeInternal;
extern RoyaltyRateTypeDefaultTypeInternal _RoyaltyRateType_default_instance_;
class SessionType;
class SessionTypeDefaultTypeInternal;
extern SessionTypeDefaultTypeInternal _SessionType_default_instance_;
class SheetMusicCodecType;
class SheetMusicCodecTypeDefaultTypeInternal;
extern SheetMusicCodecTypeDefaultTypeInternal _SheetMusicCodecType_default_instance_;
class SheetMusicType;
class SheetMusicTypeDefaultTypeInternal;
extern SheetMusicTypeDefaultTypeInternal _SheetMusicType_default_instance_;
class SoftwareType;
class SoftwareTypeDefaultTypeInternal;
extern SoftwareTypeDefaultTypeInternal _SoftwareType_default_instance_;
class SoundRecordingType;
class SoundRecordingTypeDefaultTypeInternal;
extern SoundRecordingTypeDefaultTypeInternal _SoundRecordingType_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class SubGenre;
class SubGenreDefaultTypeInternal;
extern SubGenreDefaultTypeInternal _SubGenre_default_instance_;
class SubTitleType;
class SubTitleTypeDefaultTypeInternal;
extern SubTitleTypeDefaultTypeInternal _SubTitleType_default_instance_;
class SupplyChainStatus;
class SupplyChainStatusDefaultTypeInternal;
extern SupplyChainStatusDefaultTypeInternal _SupplyChainStatus_default_instance_;
class Tempo;
class TempoDefaultTypeInternal;
extern TempoDefaultTypeInternal _Tempo_default_instance_;
class TerritoryCodeType;
class TerritoryCodeTypeDefaultTypeInternal;
extern TerritoryCodeTypeDefaultTypeInternal _TerritoryCodeType_default_instance_;
class TerritoryCodeTypeIncludingDeprecatedCodes;
class TerritoryCodeTypeIncludingDeprecatedCodesDefaultTypeInternal;
extern TerritoryCodeTypeIncludingDeprecatedCodesDefaultTypeInternal _TerritoryCodeTypeIncludingDeprecatedCodes_default_instance_;
class TextCodecType;
class TextCodecTypeDefaultTypeInternal;
extern TextCodecTypeDefaultTypeInternal _TextCodecType_default_instance_;
class TextType;
class TextTypeDefaultTypeInternal;
extern TextTypeDefaultTypeInternal _TextType_default_instance_;
class TextType_ATOM;
class TextType_ATOMDefaultTypeInternal;
extern TextType_ATOMDefaultTypeInternal _TextType_ATOM_default_instance_;
class Theme;
class ThemeDefaultTypeInternal;
extern ThemeDefaultTypeInternal _Theme_default_instance_;
class ThemeType;
class ThemeTypeDefaultTypeInternal;
extern ThemeTypeDefaultTypeInternal _ThemeType_default_instance_;
class TimecodeType;
class TimecodeTypeDefaultTypeInternal;
extern TimecodeTypeDefaultTypeInternal _TimecodeType_default_instance_;
class TisTerritoryCode;
class TisTerritoryCodeDefaultTypeInternal;
extern TisTerritoryCodeDefaultTypeInternal _TisTerritoryCode_default_instance_;
class TitleType;
class TitleTypeDefaultTypeInternal;
extern TitleTypeDefaultTypeInternal _TitleType_default_instance_;
class TransferCategory;
class TransferCategoryDefaultTypeInternal;
extern TransferCategoryDefaultTypeInternal _TransferCategory_default_instance_;
class TransferType;
class TransferTypeDefaultTypeInternal;
extern TransferTypeDefaultTypeInternal _TransferType_default_instance_;
class UnitOfBitRate;
class UnitOfBitRateDefaultTypeInternal;
extern UnitOfBitRateDefaultTypeInternal _UnitOfBitRate_default_instance_;
class UnitOfConditionValue;
class UnitOfConditionValueDefaultTypeInternal;
extern UnitOfConditionValueDefaultTypeInternal _UnitOfConditionValue_default_instance_;
class UnitOfCuePoints;
class UnitOfCuePointsDefaultTypeInternal;
extern UnitOfCuePointsDefaultTypeInternal _UnitOfCuePoints_default_instance_;
class UnitOfDuration;
class UnitOfDurationDefaultTypeInternal;
extern UnitOfDurationDefaultTypeInternal _UnitOfDuration_default_instance_;
class UnitOfExtent;
class UnitOfExtentDefaultTypeInternal;
extern UnitOfExtentDefaultTypeInternal _UnitOfExtent_default_instance_;
class UnitOfFrameRate;
class UnitOfFrameRateDefaultTypeInternal;
extern UnitOfFrameRateDefaultTypeInternal _UnitOfFrameRate_default_instance_;
class UnitOfFrequency;
class UnitOfFrequencyDefaultTypeInternal;
extern UnitOfFrequencyDefaultTypeInternal _UnitOfFrequency_default_instance_;
class UseType;
class UseTypeDefaultTypeInternal;
extern UseTypeDefaultTypeInternal _UseType_default_instance_;
class UseType_MLC;
class UseType_MLCDefaultTypeInternal;
extern UseType_MLCDefaultTypeInternal _UseType_MLC_default_instance_;
class UseType_MWNL;
class UseType_MWNLDefaultTypeInternal;
extern UseType_MWNLDefaultTypeInternal _UseType_MWNL_default_instance_;
class UserInterfaceType;
class UserInterfaceTypeDefaultTypeInternal;
extern UserInterfaceTypeDefaultTypeInternal _UserInterfaceType_default_instance_;
class VersionType;
class VersionTypeDefaultTypeInternal;
extern VersionTypeDefaultTypeInternal _VersionType_default_instance_;
class VideoCodecType;
class VideoCodecTypeDefaultTypeInternal;
extern VideoCodecTypeDefaultTypeInternal _VideoCodecType_default_instance_;
class VideoDefinitionType;
class VideoDefinitionTypeDefaultTypeInternal;
extern VideoDefinitionTypeDefaultTypeInternal _VideoDefinitionType_default_instance_;
class VideoType;
class VideoTypeDefaultTypeInternal;
extern VideoTypeDefaultTypeInternal _VideoType_default_instance_;
class VideoType_DSRF;
class VideoType_DSRFDefaultTypeInternal;
extern VideoType_DSRFDefaultTypeInternal _VideoType_DSRF_default_instance_;
class VisualPerceptionType;
class VisualPerceptionTypeDefaultTypeInternal;
extern VisualPerceptionTypeDefaultTypeInternal _VisualPerceptionType_default_instance_;
class VocalRegister;
class VocalRegisterDefaultTypeInternal;
extern VocalRegisterDefaultTypeInternal _VocalRegister_default_instance_;
class VocalType;
class VocalTypeDefaultTypeInternal;
extern VocalTypeDefaultTypeInternal _VocalType_default_instance_;
class WorkRelationshipType;
class WorkRelationshipTypeDefaultTypeInternal;
extern WorkRelationshipTypeDefaultTypeInternal _WorkRelationshipType_default_instance_;
}  // namespace avs
}  // namespace mead101
PROTOBUF_NAMESPACE_OPEN
template<> ::mead101::avs::AdditionalTitleType* Arena::CreateMaybeMessage<::mead101::avs::AdditionalTitleType>(Arena*);
template<> ::mead101::avs::AdditionalUseType* Arena::CreateMaybeMessage<::mead101::avs::AdditionalUseType>(Arena*);
template<> ::mead101::avs::AdditionalVideoType* Arena::CreateMaybeMessage<::mead101::avs::AdditionalVideoType>(Arena*);
template<> ::mead101::avs::AdministratingRecordCompanyRole* Arena::CreateMaybeMessage<::mead101::avs::AdministratingRecordCompanyRole>(Arena*);
template<> ::mead101::avs::AffiliationType* Arena::CreateMaybeMessage<::mead101::avs::AffiliationType>(Arena*);
template<> ::mead101::avs::AllTerritoryCode* Arena::CreateMaybeMessage<::mead101::avs::AllTerritoryCode>(Arena*);
template<> ::mead101::avs::ArtistRole* Arena::CreateMaybeMessage<::mead101::avs::ArtistRole>(Arena*);
template<> ::mead101::avs::ArtistType* Arena::CreateMaybeMessage<::mead101::avs::ArtistType>(Arena*);
template<> ::mead101::avs::AspectRatioType* Arena::CreateMaybeMessage<::mead101::avs::AspectRatioType>(Arena*);
template<> ::mead101::avs::AsserterType* Arena::CreateMaybeMessage<::mead101::avs::AsserterType>(Arena*);
template<> ::mead101::avs::AudioCodecType* Arena::CreateMaybeMessage<::mead101::avs::AudioCodecType>(Arena*);
template<> ::mead101::avs::AvsVersionId* Arena::CreateMaybeMessage<::mead101::avs::AvsVersionId>(Arena*);
template<> ::mead101::avs::BinaryDataType* Arena::CreateMaybeMessage<::mead101::avs::BinaryDataType>(Arena*);
template<> ::mead101::avs::BusinessMusicalWorkContributorRole* Arena::CreateMaybeMessage<::mead101::avs::BusinessMusicalWorkContributorRole>(Arena*);
template<> ::mead101::avs::CarrierType* Arena::CreateMaybeMessage<::mead101::avs::CarrierType>(Arena*);
template<> ::mead101::avs::CatalogTransferType* Arena::CreateMaybeMessage<::mead101::avs::CatalogTransferType>(Arena*);
template<> ::mead101::avs::CdProtectionType* Arena::CreateMaybeMessage<::mead101::avs::CdProtectionType>(Arena*);
template<> ::mead101::avs::CharacterType* Arena::CreateMaybeMessage<::mead101::avs::CharacterType>(Arena*);
template<> ::mead101::avs::ClaimStatus* Arena::CreateMaybeMessage<::mead101::avs::ClaimStatus>(Arena*);
template<> ::mead101::avs::ClassifiedGenre* Arena::CreateMaybeMessage<::mead101::avs::ClassifiedGenre>(Arena*);
template<> ::mead101::avs::CodingType* Arena::CreateMaybeMessage<::mead101::avs::CodingType>(Arena*);
template<> ::mead101::avs::CommentaryNoteType* Arena::CreateMaybeMessage<::mead101::avs::CommentaryNoteType>(Arena*);
template<> ::mead101::avs::CommercialModelType* Arena::CreateMaybeMessage<::mead101::avs::CommercialModelType>(Arena*);
template<> ::mead101::avs::CommercialModelType_MWNL* Arena::CreateMaybeMessage<::mead101::avs::CommercialModelType_MWNL>(Arena*);
template<> ::mead101::avs::CompilationType* Arena::CreateMaybeMessage<::mead101::avs::CompilationType>(Arena*);
template<> ::mead101::avs::CompositeMusicalWorkType* Arena::CreateMaybeMessage<::mead101::avs::CompositeMusicalWorkType>(Arena*);
template<> ::mead101::avs::ContainerFormat* Arena::CreateMaybeMessage<::mead101::avs::ContainerFormat>(Arena*);
template<> ::mead101::avs::ContributorRole* Arena::CreateMaybeMessage<::mead101::avs::ContributorRole>(Arena*);
template<> ::mead101::avs::CreativeMusicalWorkContributorRole* Arena::CreateMaybeMessage<::mead101::avs::CreativeMusicalWorkContributorRole>(Arena*);
template<> ::mead101::avs::CueOrigin* Arena::CreateMaybeMessage<::mead101::avs::CueOrigin>(Arena*);
template<> ::mead101::avs::CueSheetType* Arena::CreateMaybeMessage<::mead101::avs::CueSheetType>(Arena*);
template<> ::mead101::avs::CueUseType* Arena::CreateMaybeMessage<::mead101::avs::CueUseType>(Arena*);
template<> ::mead101::avs::CurrencyCode* Arena::CreateMaybeMessage<::mead101::avs::CurrencyCode>(Arena*);
template<> ::mead101::avs::CurrentTerritoryCode* Arena::CreateMaybeMessage<::mead101::avs::CurrentTerritoryCode>(Arena*);
template<> ::mead101::avs::DanceAndRhythmStyle* Arena::CreateMaybeMessage<::mead101::avs::DanceAndRhythmStyle>(Arena*);
template<> ::mead101::avs::DataCarrierFormat* Arena::CreateMaybeMessage<::mead101::avs::DataCarrierFormat>(Arena*);
template<> ::mead101::avs::DataCarrierType* Arena::CreateMaybeMessage<::mead101::avs::DataCarrierType>(Arena*);
template<> ::mead101::avs::DdexTerritoryCode* Arena::CreateMaybeMessage<::mead101::avs::DdexTerritoryCode>(Arena*);
template<> ::mead101::avs::DeprecatedCurrencyCode* Arena::CreateMaybeMessage<::mead101::avs::DeprecatedCurrencyCode>(Arena*);
template<> ::mead101::avs::DeprecatedIsoTerritoryCode* Arena::CreateMaybeMessage<::mead101::avs::DeprecatedIsoTerritoryCode>(Arena*);
template<> ::mead101::avs::DeprecatedReleaseType* Arena::CreateMaybeMessage<::mead101::avs::DeprecatedReleaseType>(Arena*);
template<> ::mead101::avs::DigitizationMode* Arena::CreateMaybeMessage<::mead101::avs::DigitizationMode>(Arena*);
template<> ::mead101::avs::DisplayArtistRole* Arena::CreateMaybeMessage<::mead101::avs::DisplayArtistRole>(Arena*);
template<> ::mead101::avs::DistributionChannelType* Arena::CreateMaybeMessage<::mead101::avs::DistributionChannelType>(Arena*);
template<> ::mead101::avs::DocumentType_LoD* Arena::CreateMaybeMessage<::mead101::avs::DocumentType_LoD>(Arena*);
template<> ::mead101::avs::DocumentType_MWL* Arena::CreateMaybeMessage<::mead101::avs::DocumentType_MWL>(Arena*);
template<> ::mead101::avs::DpidStatus* Arena::CreateMaybeMessage<::mead101::avs::DpidStatus>(Arena*);
template<> ::mead101::avs::DrmEnforcementType* Arena::CreateMaybeMessage<::mead101::avs::DrmEnforcementType>(Arena*);
template<> ::mead101::avs::ElementConfiguration* Arena::CreateMaybeMessage<::mead101::avs::ElementConfiguration>(Arena*);
template<> ::mead101::avs::ElementDesignation* Arena::CreateMaybeMessage<::mead101::avs::ElementDesignation>(Arena*);
template<> ::mead101::avs::EncodingType* Arena::CreateMaybeMessage<::mead101::avs::EncodingType>(Arena*);
template<> ::mead101::avs::EquipmentType* Arena::CreateMaybeMessage<::mead101::avs::EquipmentType>(Arena*);
template<> ::mead101::avs::ErnMessageType* Arena::CreateMaybeMessage<::mead101::avs::ErnMessageType>(Arena*);
template<> ::mead101::avs::ErnTestMessageType* Arena::CreateMaybeMessage<::mead101::avs::ErnTestMessageType>(Arena*);
template<> ::mead101::avs::ErncFileStatus* Arena::CreateMaybeMessage<::mead101::avs::ErncFileStatus>(Arena*);
template<> ::mead101::avs::ErncProposedActionType* Arena::CreateMaybeMessage<::mead101::avs::ErncProposedActionType>(Arena*);
template<> ::mead101::avs::ErrorSeverity* Arena::CreateMaybeMessage<::mead101::avs::ErrorSeverity>(Arena*);
template<> ::mead101::avs::ErrorType* Arena::CreateMaybeMessage<::mead101::avs::ErrorType>(Arena*);
template<> ::mead101::avs::ExceptionReason* Arena::CreateMaybeMessage<::mead101::avs::ExceptionReason>(Arena*);
template<> ::mead101::avs::ExpressionType* Arena::CreateMaybeMessage<::mead101::avs::ExpressionType>(Arena*);
template<> ::mead101::avs::ExternallyLinkedResourceType* Arena::CreateMaybeMessage<::mead101::avs::ExternallyLinkedResourceType>(Arena*);
template<> ::mead101::avs::FileType* Arena::CreateMaybeMessage<::mead101::avs::FileType>(Arena*);
template<> ::mead101::avs::FingerprintAlgorithmType* Arena::CreateMaybeMessage<::mead101::avs::FingerprintAlgorithmType>(Arena*);
template<> ::mead101::avs::Form* Arena::CreateMaybeMessage<::mead101::avs::Form>(Arena*);
template<> ::mead101::avs::FrameRate* Arena::CreateMaybeMessage<::mead101::avs::FrameRate>(Arena*);
template<> ::mead101::avs::Gender* Arena::CreateMaybeMessage<::mead101::avs::Gender>(Arena*);
template<> ::mead101::avs::GoverningAgreementType* Arena::CreateMaybeMessage<::mead101::avs::GoverningAgreementType>(Arena*);
template<> ::mead101::avs::HashSumAlgorithmType* Arena::CreateMaybeMessage<::mead101::avs::HashSumAlgorithmType>(Arena*);
template<> ::mead101::avs::ImageCodecType* Arena::CreateMaybeMessage<::mead101::avs::ImageCodecType>(Arena*);
template<> ::mead101::avs::ImageType* Arena::CreateMaybeMessage<::mead101::avs::ImageType>(Arena*);
template<> ::mead101::avs::InstrumentType* Arena::CreateMaybeMessage<::mead101::avs::InstrumentType>(Arena*);
template<> ::mead101::avs::Iso639Part12LanguageCode* Arena::CreateMaybeMessage<::mead101::avs::Iso639Part12LanguageCode>(Arena*);
template<> ::mead101::avs::Iso639Part3LanguageCode* Arena::CreateMaybeMessage<::mead101::avs::Iso639Part3LanguageCode>(Arena*);
template<> ::mead101::avs::IsoCurrencyCode* Arena::CreateMaybeMessage<::mead101::avs::IsoCurrencyCode>(Arena*);
template<> ::mead101::avs::IsoLanguageCode* Arena::CreateMaybeMessage<::mead101::avs::IsoLanguageCode>(Arena*);
template<> ::mead101::avs::IsoTerritoryCode* Arena::CreateMaybeMessage<::mead101::avs::IsoTerritoryCode>(Arena*);
template<> ::mead101::avs::LabelNameType* Arena::CreateMaybeMessage<::mead101::avs::LabelNameType>(Arena*);
template<> ::mead101::avs::LabelType* Arena::CreateMaybeMessage<::mead101::avs::LabelType>(Arena*);
template<> ::mead101::avs::LanguageLocalizationType* Arena::CreateMaybeMessage<::mead101::avs::LanguageLocalizationType>(Arena*);
template<> ::mead101::avs::LicenseRecord* Arena::CreateMaybeMessage<::mead101::avs::LicenseRecord>(Arena*);
template<> ::mead101::avs::LicenseRefusalReason* Arena::CreateMaybeMessage<::mead101::avs::LicenseRefusalReason>(Arena*);
template<> ::mead101::avs::LicenseRejectionReason* Arena::CreateMaybeMessage<::mead101::avs::LicenseRejectionReason>(Arena*);
template<> ::mead101::avs::LinkAcknowledgementStatus* Arena::CreateMaybeMessage<::mead101::avs::LinkAcknowledgementStatus>(Arena*);
template<> ::mead101::avs::LinkDescription* Arena::CreateMaybeMessage<::mead101::avs::LinkDescription>(Arena*);
template<> ::mead101::avs::LyricsType* Arena::CreateMaybeMessage<::mead101::avs::LyricsType>(Arena*);
template<> ::mead101::avs::MembershipType* Arena::CreateMaybeMessage<::mead101::avs::MembershipType>(Arena*);
template<> ::mead101::avs::MessageActionType* Arena::CreateMaybeMessage<::mead101::avs::MessageActionType>(Arena*);
template<> ::mead101::avs::MessageControlType* Arena::CreateMaybeMessage<::mead101::avs::MessageControlType>(Arena*);
template<> ::mead101::avs::MessagePurpose* Arena::CreateMaybeMessage<::mead101::avs::MessagePurpose>(Arena*);
template<> ::mead101::avs::MessageType* Arena::CreateMaybeMessage<::mead101::avs::MessageType>(Arena*);
template<> ::mead101::avs::MetadataSourceType* Arena::CreateMaybeMessage<::mead101::avs::MetadataSourceType>(Arena*);
template<> ::mead101::avs::MissingLinkReason* Arena::CreateMaybeMessage<::mead101::avs::MissingLinkReason>(Arena*);
template<> ::mead101::avs::MlcMessageType* Arena::CreateMaybeMessage<::mead101::avs::MlcMessageType>(Arena*);
template<> ::mead101::avs::Mode* Arena::CreateMaybeMessage<::mead101::avs::Mode>(Arena*);
template<> ::mead101::avs::MoodType* Arena::CreateMaybeMessage<::mead101::avs::MoodType>(Arena*);
template<> ::mead101::avs::MusicalWorkContributorRole* Arena::CreateMaybeMessage<::mead101::avs::MusicalWorkContributorRole>(Arena*);
template<> ::mead101::avs::MusicalWorkType* Arena::CreateMaybeMessage<::mead101::avs::MusicalWorkType>(Arena*);
template<> ::mead101::avs::MwnlFileStatus* Arena::CreateMaybeMessage<::mead101::avs::MwnlFileStatus>(Arena*);
template<> ::mead101::avs::MwnlProposedActionType* Arena::CreateMaybeMessage<::mead101::avs::MwnlProposedActionType>(Arena*);
template<> ::mead101::avs::NewStudioRole* Arena::CreateMaybeMessage<::mead101::avs::NewStudioRole>(Arena*);
template<> ::mead101::avs::OperatingSystemType* Arena::CreateMaybeMessage<::mead101::avs::OperatingSystemType>(Arena*);
template<> ::mead101::avs::PLineType* Arena::CreateMaybeMessage<::mead101::avs::PLineType>(Arena*);
template<> ::mead101::avs::ParentalWarningType* Arena::CreateMaybeMessage<::mead101::avs::ParentalWarningType>(Arena*);
template<> ::mead101::avs::PartyRelationshipType* Arena::CreateMaybeMessage<::mead101::avs::PartyRelationshipType>(Arena*);
template<> ::mead101::avs::PercentageType* Arena::CreateMaybeMessage<::mead101::avs::PercentageType>(Arena*);
template<> ::mead101::avs::Period* Arena::CreateMaybeMessage<::mead101::avs::Period>(Arena*);
template<> ::mead101::avs::PhysicalCarrierType* Arena::CreateMaybeMessage<::mead101::avs::PhysicalCarrierType>(Arena*);
template<> ::mead101::avs::PriceInformationType* Arena::CreateMaybeMessage<::mead101::avs::PriceInformationType>(Arena*);
template<> ::mead101::avs::ProductType* Arena::CreateMaybeMessage<::mead101::avs::ProductType>(Arena*);
template<> ::mead101::avs::ProfileId* Arena::CreateMaybeMessage<::mead101::avs::ProfileId>(Arena*);
template<> ::mead101::avs::Purpose* Arena::CreateMaybeMessage<::mead101::avs::Purpose>(Arena*);
template<> ::mead101::avs::RatingAgency* Arena::CreateMaybeMessage<::mead101::avs::RatingAgency>(Arena*);
template<> ::mead101::avs::RatingReason* Arena::CreateMaybeMessage<::mead101::avs::RatingReason>(Arena*);
template<> ::mead101::avs::RecipientRevenueType* Arena::CreateMaybeMessage<::mead101::avs::RecipientRevenueType>(Arena*);
template<> ::mead101::avs::RecordingMode* Arena::CreateMaybeMessage<::mead101::avs::RecordingMode>(Arena*);
template<> ::mead101::avs::RecordingPartType* Arena::CreateMaybeMessage<::mead101::avs::RecordingPartType>(Arena*);
template<> ::mead101::avs::ReferenceCreation* Arena::CreateMaybeMessage<::mead101::avs::ReferenceCreation>(Arena*);
template<> ::mead101::avs::ReferenceUnit* Arena::CreateMaybeMessage<::mead101::avs::ReferenceUnit>(Arena*);
template<> ::mead101::avs::RegistrationStatus* Arena::CreateMaybeMessage<::mead101::avs::RegistrationStatus>(Arena*);
template<> ::mead101::avs::RelatedResourceType* Arena::CreateMaybeMessage<::mead101::avs::RelatedResourceType>(Arena*);
template<> ::mead101::avs::RelationalRelator* Arena::CreateMaybeMessage<::mead101::avs::RelationalRelator>(Arena*);
template<> ::mead101::avs::ReleaseProfileVariantVersionId* Arena::CreateMaybeMessage<::mead101::avs::ReleaseProfileVariantVersionId>(Arena*);
template<> ::mead101::avs::ReleaseProfileVersionId* Arena::CreateMaybeMessage<::mead101::avs::ReleaseProfileVersionId>(Arena*);
template<> ::mead101::avs::ReleaseRelationshipType* Arena::CreateMaybeMessage<::mead101::avs::ReleaseRelationshipType>(Arena*);
template<> ::mead101::avs::ReleaseResourceType* Arena::CreateMaybeMessage<::mead101::avs::ReleaseResourceType>(Arena*);
template<> ::mead101::avs::ReleaseType* Arena::CreateMaybeMessage<::mead101::avs::ReleaseType>(Arena*);
template<> ::mead101::avs::ReleaseType_ERN4* Arena::CreateMaybeMessage<::mead101::avs::ReleaseType_ERN4>(Arena*);
template<> ::mead101::avs::ReleaseType_MCNOTIF* Arena::CreateMaybeMessage<::mead101::avs::ReleaseType_MCNOTIF>(Arena*);
template<> ::mead101::avs::RequestMessagePurpose* Arena::CreateMaybeMessage<::mead101::avs::RequestMessagePurpose>(Arena*);
template<> ::mead101::avs::RequestReason* Arena::CreateMaybeMessage<::mead101::avs::RequestReason>(Arena*);
template<> ::mead101::avs::ResourceContributorRole* Arena::CreateMaybeMessage<::mead101::avs::ResourceContributorRole>(Arena*);
template<> ::mead101::avs::ResourceGroupType* Arena::CreateMaybeMessage<::mead101::avs::ResourceGroupType>(Arena*);
template<> ::mead101::avs::ResourceRelationshipType* Arena::CreateMaybeMessage<::mead101::avs::ResourceRelationshipType>(Arena*);
template<> ::mead101::avs::ResourceType* Arena::CreateMaybeMessage<::mead101::avs::ResourceType>(Arena*);
template<> ::mead101::avs::ResourceType_MCNOTIF* Arena::CreateMaybeMessage<::mead101::avs::ResourceType_MCNOTIF>(Arena*);
template<> ::mead101::avs::ResourceWorkRelationshipType* Arena::CreateMaybeMessage<::mead101::avs::ResourceWorkRelationshipType>(Arena*);
template<> ::mead101::avs::RevenueSourceType* Arena::CreateMaybeMessage<::mead101::avs::RevenueSourceType>(Arena*);
template<> ::mead101::avs::RightShareType* Arena::CreateMaybeMessage<::mead101::avs::RightShareType>(Arena*);
template<> ::mead101::avs::RightsClaimPolicyType* Arena::CreateMaybeMessage<::mead101::avs::RightsClaimPolicyType>(Arena*);
template<> ::mead101::avs::RightsClaimStatus* Arena::CreateMaybeMessage<::mead101::avs::RightsClaimStatus>(Arena*);
template<> ::mead101::avs::RightsControllerRole* Arena::CreateMaybeMessage<::mead101::avs::RightsControllerRole>(Arena*);
template<> ::mead101::avs::RightsControllerType* Arena::CreateMaybeMessage<::mead101::avs::RightsControllerType>(Arena*);
template<> ::mead101::avs::RightsCoverage* Arena::CreateMaybeMessage<::mead101::avs::RightsCoverage>(Arena*);
template<> ::mead101::avs::RightsCoverage_MWNL* Arena::CreateMaybeMessage<::mead101::avs::RightsCoverage_MWNL>(Arena*);
template<> ::mead101::avs::RightsStatementProfile* Arena::CreateMaybeMessage<::mead101::avs::RightsStatementProfile>(Arena*);
template<> ::mead101::avs::RootChordNote* Arena::CreateMaybeMessage<::mead101::avs::RootChordNote>(Arena*);
template<> ::mead101::avs::RootChordQuality* Arena::CreateMaybeMessage<::mead101::avs::RootChordQuality>(Arena*);
template<> ::mead101::avs::RoyaltyRateCalculationType* Arena::CreateMaybeMessage<::mead101::avs::RoyaltyRateCalculationType>(Arena*);
template<> ::mead101::avs::RoyaltyRateType* Arena::CreateMaybeMessage<::mead101::avs::RoyaltyRateType>(Arena*);
template<> ::mead101::avs::SessionType* Arena::CreateMaybeMessage<::mead101::avs::SessionType>(Arena*);
template<> ::mead101::avs::SheetMusicCodecType* Arena::CreateMaybeMessage<::mead101::avs::SheetMusicCodecType>(Arena*);
template<> ::mead101::avs::SheetMusicType* Arena::CreateMaybeMessage<::mead101::avs::SheetMusicType>(Arena*);
template<> ::mead101::avs::SoftwareType* Arena::CreateMaybeMessage<::mead101::avs::SoftwareType>(Arena*);
template<> ::mead101::avs::SoundRecordingType* Arena::CreateMaybeMessage<::mead101::avs::SoundRecordingType>(Arena*);
template<> ::mead101::avs::Status* Arena::CreateMaybeMessage<::mead101::avs::Status>(Arena*);
template<> ::mead101::avs::SubGenre* Arena::CreateMaybeMessage<::mead101::avs::SubGenre>(Arena*);
template<> ::mead101::avs::SubTitleType* Arena::CreateMaybeMessage<::mead101::avs::SubTitleType>(Arena*);
template<> ::mead101::avs::SupplyChainStatus* Arena::CreateMaybeMessage<::mead101::avs::SupplyChainStatus>(Arena*);
template<> ::mead101::avs::Tempo* Arena::CreateMaybeMessage<::mead101::avs::Tempo>(Arena*);
template<> ::mead101::avs::TerritoryCodeType* Arena::CreateMaybeMessage<::mead101::avs::TerritoryCodeType>(Arena*);
template<> ::mead101::avs::TerritoryCodeTypeIncludingDeprecatedCodes* Arena::CreateMaybeMessage<::mead101::avs::TerritoryCodeTypeIncludingDeprecatedCodes>(Arena*);
template<> ::mead101::avs::TextCodecType* Arena::CreateMaybeMessage<::mead101::avs::TextCodecType>(Arena*);
template<> ::mead101::avs::TextType* Arena::CreateMaybeMessage<::mead101::avs::TextType>(Arena*);
template<> ::mead101::avs::TextType_ATOM* Arena::CreateMaybeMessage<::mead101::avs::TextType_ATOM>(Arena*);
template<> ::mead101::avs::Theme* Arena::CreateMaybeMessage<::mead101::avs::Theme>(Arena*);
template<> ::mead101::avs::ThemeType* Arena::CreateMaybeMessage<::mead101::avs::ThemeType>(Arena*);
template<> ::mead101::avs::TimecodeType* Arena::CreateMaybeMessage<::mead101::avs::TimecodeType>(Arena*);
template<> ::mead101::avs::TisTerritoryCode* Arena::CreateMaybeMessage<::mead101::avs::TisTerritoryCode>(Arena*);
template<> ::mead101::avs::TitleType* Arena::CreateMaybeMessage<::mead101::avs::TitleType>(Arena*);
template<> ::mead101::avs::TransferCategory* Arena::CreateMaybeMessage<::mead101::avs::TransferCategory>(Arena*);
template<> ::mead101::avs::TransferType* Arena::CreateMaybeMessage<::mead101::avs::TransferType>(Arena*);
template<> ::mead101::avs::UnitOfBitRate* Arena::CreateMaybeMessage<::mead101::avs::UnitOfBitRate>(Arena*);
template<> ::mead101::avs::UnitOfConditionValue* Arena::CreateMaybeMessage<::mead101::avs::UnitOfConditionValue>(Arena*);
template<> ::mead101::avs::UnitOfCuePoints* Arena::CreateMaybeMessage<::mead101::avs::UnitOfCuePoints>(Arena*);
template<> ::mead101::avs::UnitOfDuration* Arena::CreateMaybeMessage<::mead101::avs::UnitOfDuration>(Arena*);
template<> ::mead101::avs::UnitOfExtent* Arena::CreateMaybeMessage<::mead101::avs::UnitOfExtent>(Arena*);
template<> ::mead101::avs::UnitOfFrameRate* Arena::CreateMaybeMessage<::mead101::avs::UnitOfFrameRate>(Arena*);
template<> ::mead101::avs::UnitOfFrequency* Arena::CreateMaybeMessage<::mead101::avs::UnitOfFrequency>(Arena*);
template<> ::mead101::avs::UseType* Arena::CreateMaybeMessage<::mead101::avs::UseType>(Arena*);
template<> ::mead101::avs::UseType_MLC* Arena::CreateMaybeMessage<::mead101::avs::UseType_MLC>(Arena*);
template<> ::mead101::avs::UseType_MWNL* Arena::CreateMaybeMessage<::mead101::avs::UseType_MWNL>(Arena*);
template<> ::mead101::avs::UserInterfaceType* Arena::CreateMaybeMessage<::mead101::avs::UserInterfaceType>(Arena*);
template<> ::mead101::avs::VersionType* Arena::CreateMaybeMessage<::mead101::avs::VersionType>(Arena*);
template<> ::mead101::avs::VideoCodecType* Arena::CreateMaybeMessage<::mead101::avs::VideoCodecType>(Arena*);
template<> ::mead101::avs::VideoDefinitionType* Arena::CreateMaybeMessage<::mead101::avs::VideoDefinitionType>(Arena*);
template<> ::mead101::avs::VideoType* Arena::CreateMaybeMessage<::mead101::avs::VideoType>(Arena*);
template<> ::mead101::avs::VideoType_DSRF* Arena::CreateMaybeMessage<::mead101::avs::VideoType_DSRF>(Arena*);
template<> ::mead101::avs::VisualPerceptionType* Arena::CreateMaybeMessage<::mead101::avs::VisualPerceptionType>(Arena*);
template<> ::mead101::avs::VocalRegister* Arena::CreateMaybeMessage<::mead101::avs::VocalRegister>(Arena*);
template<> ::mead101::avs::VocalType* Arena::CreateMaybeMessage<::mead101::avs::VocalType>(Arena*);
template<> ::mead101::avs::WorkRelationshipType* Arena::CreateMaybeMessage<::mead101::avs::WorkRelationshipType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mead101 {
namespace avs {

// ===================================================================

class AdditionalTitleType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.AdditionalTitleType) */ {
 public:
  inline AdditionalTitleType() : AdditionalTitleType(nullptr) {}
  virtual ~AdditionalTitleType();

  AdditionalTitleType(const AdditionalTitleType& from);
  AdditionalTitleType(AdditionalTitleType&& from) noexcept
    : AdditionalTitleType() {
    *this = ::std::move(from);
  }

  inline AdditionalTitleType& operator=(const AdditionalTitleType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdditionalTitleType& operator=(AdditionalTitleType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdditionalTitleType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdditionalTitleType* internal_default_instance() {
    return reinterpret_cast<const AdditionalTitleType*>(
               &_AdditionalTitleType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AdditionalTitleType& a, AdditionalTitleType& b) {
    a.Swap(&b);
  }
  inline void Swap(AdditionalTitleType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdditionalTitleType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdditionalTitleType* New() const final {
    return CreateMaybeMessage<AdditionalTitleType>(nullptr);
  }

  AdditionalTitleType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdditionalTitleType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdditionalTitleType& from);
  void MergeFrom(const AdditionalTitleType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdditionalTitleType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.AdditionalTitleType";
  }
  protected:
  explicit AdditionalTitleType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.AdditionalTitleType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class AdditionalUseType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.AdditionalUseType) */ {
 public:
  inline AdditionalUseType() : AdditionalUseType(nullptr) {}
  virtual ~AdditionalUseType();

  AdditionalUseType(const AdditionalUseType& from);
  AdditionalUseType(AdditionalUseType&& from) noexcept
    : AdditionalUseType() {
    *this = ::std::move(from);
  }

  inline AdditionalUseType& operator=(const AdditionalUseType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdditionalUseType& operator=(AdditionalUseType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdditionalUseType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdditionalUseType* internal_default_instance() {
    return reinterpret_cast<const AdditionalUseType*>(
               &_AdditionalUseType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AdditionalUseType& a, AdditionalUseType& b) {
    a.Swap(&b);
  }
  inline void Swap(AdditionalUseType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdditionalUseType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdditionalUseType* New() const final {
    return CreateMaybeMessage<AdditionalUseType>(nullptr);
  }

  AdditionalUseType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdditionalUseType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdditionalUseType& from);
  void MergeFrom(const AdditionalUseType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdditionalUseType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.AdditionalUseType";
  }
  protected:
  explicit AdditionalUseType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.AdditionalUseType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class AdditionalVideoType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.AdditionalVideoType) */ {
 public:
  inline AdditionalVideoType() : AdditionalVideoType(nullptr) {}
  virtual ~AdditionalVideoType();

  AdditionalVideoType(const AdditionalVideoType& from);
  AdditionalVideoType(AdditionalVideoType&& from) noexcept
    : AdditionalVideoType() {
    *this = ::std::move(from);
  }

  inline AdditionalVideoType& operator=(const AdditionalVideoType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdditionalVideoType& operator=(AdditionalVideoType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdditionalVideoType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdditionalVideoType* internal_default_instance() {
    return reinterpret_cast<const AdditionalVideoType*>(
               &_AdditionalVideoType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AdditionalVideoType& a, AdditionalVideoType& b) {
    a.Swap(&b);
  }
  inline void Swap(AdditionalVideoType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdditionalVideoType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdditionalVideoType* New() const final {
    return CreateMaybeMessage<AdditionalVideoType>(nullptr);
  }

  AdditionalVideoType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdditionalVideoType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdditionalVideoType& from);
  void MergeFrom(const AdditionalVideoType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdditionalVideoType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.AdditionalVideoType";
  }
  protected:
  explicit AdditionalVideoType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.AdditionalVideoType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class AdministratingRecordCompanyRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.AdministratingRecordCompanyRole) */ {
 public:
  inline AdministratingRecordCompanyRole() : AdministratingRecordCompanyRole(nullptr) {}
  virtual ~AdministratingRecordCompanyRole();

  AdministratingRecordCompanyRole(const AdministratingRecordCompanyRole& from);
  AdministratingRecordCompanyRole(AdministratingRecordCompanyRole&& from) noexcept
    : AdministratingRecordCompanyRole() {
    *this = ::std::move(from);
  }

  inline AdministratingRecordCompanyRole& operator=(const AdministratingRecordCompanyRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdministratingRecordCompanyRole& operator=(AdministratingRecordCompanyRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdministratingRecordCompanyRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdministratingRecordCompanyRole* internal_default_instance() {
    return reinterpret_cast<const AdministratingRecordCompanyRole*>(
               &_AdministratingRecordCompanyRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AdministratingRecordCompanyRole& a, AdministratingRecordCompanyRole& b) {
    a.Swap(&b);
  }
  inline void Swap(AdministratingRecordCompanyRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdministratingRecordCompanyRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdministratingRecordCompanyRole* New() const final {
    return CreateMaybeMessage<AdministratingRecordCompanyRole>(nullptr);
  }

  AdministratingRecordCompanyRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdministratingRecordCompanyRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdministratingRecordCompanyRole& from);
  void MergeFrom(const AdministratingRecordCompanyRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdministratingRecordCompanyRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.AdministratingRecordCompanyRole";
  }
  protected:
  explicit AdministratingRecordCompanyRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.AdministratingRecordCompanyRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class AffiliationType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.AffiliationType) */ {
 public:
  inline AffiliationType() : AffiliationType(nullptr) {}
  virtual ~AffiliationType();

  AffiliationType(const AffiliationType& from);
  AffiliationType(AffiliationType&& from) noexcept
    : AffiliationType() {
    *this = ::std::move(from);
  }

  inline AffiliationType& operator=(const AffiliationType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AffiliationType& operator=(AffiliationType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AffiliationType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AffiliationType* internal_default_instance() {
    return reinterpret_cast<const AffiliationType*>(
               &_AffiliationType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AffiliationType& a, AffiliationType& b) {
    a.Swap(&b);
  }
  inline void Swap(AffiliationType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AffiliationType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AffiliationType* New() const final {
    return CreateMaybeMessage<AffiliationType>(nullptr);
  }

  AffiliationType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AffiliationType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AffiliationType& from);
  void MergeFrom(const AffiliationType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AffiliationType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.AffiliationType";
  }
  protected:
  explicit AffiliationType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.AffiliationType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class AllTerritoryCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.AllTerritoryCode) */ {
 public:
  inline AllTerritoryCode() : AllTerritoryCode(nullptr) {}
  virtual ~AllTerritoryCode();

  AllTerritoryCode(const AllTerritoryCode& from);
  AllTerritoryCode(AllTerritoryCode&& from) noexcept
    : AllTerritoryCode() {
    *this = ::std::move(from);
  }

  inline AllTerritoryCode& operator=(const AllTerritoryCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllTerritoryCode& operator=(AllTerritoryCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AllTerritoryCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllTerritoryCode* internal_default_instance() {
    return reinterpret_cast<const AllTerritoryCode*>(
               &_AllTerritoryCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AllTerritoryCode& a, AllTerritoryCode& b) {
    a.Swap(&b);
  }
  inline void Swap(AllTerritoryCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllTerritoryCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllTerritoryCode* New() const final {
    return CreateMaybeMessage<AllTerritoryCode>(nullptr);
  }

  AllTerritoryCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllTerritoryCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AllTerritoryCode& from);
  void MergeFrom(const AllTerritoryCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllTerritoryCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.AllTerritoryCode";
  }
  protected:
  explicit AllTerritoryCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.AllTerritoryCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ArtistRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ArtistRole) */ {
 public:
  inline ArtistRole() : ArtistRole(nullptr) {}
  virtual ~ArtistRole();

  ArtistRole(const ArtistRole& from);
  ArtistRole(ArtistRole&& from) noexcept
    : ArtistRole() {
    *this = ::std::move(from);
  }

  inline ArtistRole& operator=(const ArtistRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtistRole& operator=(ArtistRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ArtistRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtistRole* internal_default_instance() {
    return reinterpret_cast<const ArtistRole*>(
               &_ArtistRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ArtistRole& a, ArtistRole& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtistRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtistRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ArtistRole* New() const final {
    return CreateMaybeMessage<ArtistRole>(nullptr);
  }

  ArtistRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ArtistRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ArtistRole& from);
  void MergeFrom(const ArtistRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtistRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ArtistRole";
  }
  protected:
  explicit ArtistRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ArtistRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ArtistType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ArtistType) */ {
 public:
  inline ArtistType() : ArtistType(nullptr) {}
  virtual ~ArtistType();

  ArtistType(const ArtistType& from);
  ArtistType(ArtistType&& from) noexcept
    : ArtistType() {
    *this = ::std::move(from);
  }

  inline ArtistType& operator=(const ArtistType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtistType& operator=(ArtistType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ArtistType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtistType* internal_default_instance() {
    return reinterpret_cast<const ArtistType*>(
               &_ArtistType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ArtistType& a, ArtistType& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtistType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtistType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ArtistType* New() const final {
    return CreateMaybeMessage<ArtistType>(nullptr);
  }

  ArtistType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ArtistType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ArtistType& from);
  void MergeFrom(const ArtistType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtistType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ArtistType";
  }
  protected:
  explicit ArtistType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ArtistType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class AspectRatioType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.AspectRatioType) */ {
 public:
  inline AspectRatioType() : AspectRatioType(nullptr) {}
  virtual ~AspectRatioType();

  AspectRatioType(const AspectRatioType& from);
  AspectRatioType(AspectRatioType&& from) noexcept
    : AspectRatioType() {
    *this = ::std::move(from);
  }

  inline AspectRatioType& operator=(const AspectRatioType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AspectRatioType& operator=(AspectRatioType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AspectRatioType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AspectRatioType* internal_default_instance() {
    return reinterpret_cast<const AspectRatioType*>(
               &_AspectRatioType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AspectRatioType& a, AspectRatioType& b) {
    a.Swap(&b);
  }
  inline void Swap(AspectRatioType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AspectRatioType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AspectRatioType* New() const final {
    return CreateMaybeMessage<AspectRatioType>(nullptr);
  }

  AspectRatioType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AspectRatioType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AspectRatioType& from);
  void MergeFrom(const AspectRatioType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AspectRatioType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.AspectRatioType";
  }
  protected:
  explicit AspectRatioType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.AspectRatioType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class AsserterType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.AsserterType) */ {
 public:
  inline AsserterType() : AsserterType(nullptr) {}
  virtual ~AsserterType();

  AsserterType(const AsserterType& from);
  AsserterType(AsserterType&& from) noexcept
    : AsserterType() {
    *this = ::std::move(from);
  }

  inline AsserterType& operator=(const AsserterType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsserterType& operator=(AsserterType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AsserterType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AsserterType* internal_default_instance() {
    return reinterpret_cast<const AsserterType*>(
               &_AsserterType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AsserterType& a, AsserterType& b) {
    a.Swap(&b);
  }
  inline void Swap(AsserterType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AsserterType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AsserterType* New() const final {
    return CreateMaybeMessage<AsserterType>(nullptr);
  }

  AsserterType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AsserterType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AsserterType& from);
  void MergeFrom(const AsserterType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AsserterType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.AsserterType";
  }
  protected:
  explicit AsserterType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.AsserterType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class AudioCodecType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.AudioCodecType) */ {
 public:
  inline AudioCodecType() : AudioCodecType(nullptr) {}
  virtual ~AudioCodecType();

  AudioCodecType(const AudioCodecType& from);
  AudioCodecType(AudioCodecType&& from) noexcept
    : AudioCodecType() {
    *this = ::std::move(from);
  }

  inline AudioCodecType& operator=(const AudioCodecType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioCodecType& operator=(AudioCodecType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioCodecType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioCodecType* internal_default_instance() {
    return reinterpret_cast<const AudioCodecType*>(
               &_AudioCodecType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AudioCodecType& a, AudioCodecType& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioCodecType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioCodecType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioCodecType* New() const final {
    return CreateMaybeMessage<AudioCodecType>(nullptr);
  }

  AudioCodecType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioCodecType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioCodecType& from);
  void MergeFrom(const AudioCodecType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioCodecType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.AudioCodecType";
  }
  protected:
  explicit AudioCodecType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.AudioCodecType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class AvsVersionId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.AvsVersionId) */ {
 public:
  inline AvsVersionId() : AvsVersionId(nullptr) {}
  virtual ~AvsVersionId();

  AvsVersionId(const AvsVersionId& from);
  AvsVersionId(AvsVersionId&& from) noexcept
    : AvsVersionId() {
    *this = ::std::move(from);
  }

  inline AvsVersionId& operator=(const AvsVersionId& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvsVersionId& operator=(AvsVersionId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AvsVersionId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AvsVersionId* internal_default_instance() {
    return reinterpret_cast<const AvsVersionId*>(
               &_AvsVersionId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AvsVersionId& a, AvsVersionId& b) {
    a.Swap(&b);
  }
  inline void Swap(AvsVersionId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvsVersionId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AvsVersionId* New() const final {
    return CreateMaybeMessage<AvsVersionId>(nullptr);
  }

  AvsVersionId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AvsVersionId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AvsVersionId& from);
  void MergeFrom(const AvsVersionId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvsVersionId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.AvsVersionId";
  }
  protected:
  explicit AvsVersionId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.AvsVersionId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class BinaryDataType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.BinaryDataType) */ {
 public:
  inline BinaryDataType() : BinaryDataType(nullptr) {}
  virtual ~BinaryDataType();

  BinaryDataType(const BinaryDataType& from);
  BinaryDataType(BinaryDataType&& from) noexcept
    : BinaryDataType() {
    *this = ::std::move(from);
  }

  inline BinaryDataType& operator=(const BinaryDataType& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryDataType& operator=(BinaryDataType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BinaryDataType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryDataType* internal_default_instance() {
    return reinterpret_cast<const BinaryDataType*>(
               &_BinaryDataType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BinaryDataType& a, BinaryDataType& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryDataType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryDataType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinaryDataType* New() const final {
    return CreateMaybeMessage<BinaryDataType>(nullptr);
  }

  BinaryDataType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinaryDataType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BinaryDataType& from);
  void MergeFrom(const BinaryDataType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryDataType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.BinaryDataType";
  }
  protected:
  explicit BinaryDataType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.BinaryDataType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class BusinessMusicalWorkContributorRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.BusinessMusicalWorkContributorRole) */ {
 public:
  inline BusinessMusicalWorkContributorRole() : BusinessMusicalWorkContributorRole(nullptr) {}
  virtual ~BusinessMusicalWorkContributorRole();

  BusinessMusicalWorkContributorRole(const BusinessMusicalWorkContributorRole& from);
  BusinessMusicalWorkContributorRole(BusinessMusicalWorkContributorRole&& from) noexcept
    : BusinessMusicalWorkContributorRole() {
    *this = ::std::move(from);
  }

  inline BusinessMusicalWorkContributorRole& operator=(const BusinessMusicalWorkContributorRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline BusinessMusicalWorkContributorRole& operator=(BusinessMusicalWorkContributorRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BusinessMusicalWorkContributorRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BusinessMusicalWorkContributorRole* internal_default_instance() {
    return reinterpret_cast<const BusinessMusicalWorkContributorRole*>(
               &_BusinessMusicalWorkContributorRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BusinessMusicalWorkContributorRole& a, BusinessMusicalWorkContributorRole& b) {
    a.Swap(&b);
  }
  inline void Swap(BusinessMusicalWorkContributorRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BusinessMusicalWorkContributorRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BusinessMusicalWorkContributorRole* New() const final {
    return CreateMaybeMessage<BusinessMusicalWorkContributorRole>(nullptr);
  }

  BusinessMusicalWorkContributorRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BusinessMusicalWorkContributorRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BusinessMusicalWorkContributorRole& from);
  void MergeFrom(const BusinessMusicalWorkContributorRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BusinessMusicalWorkContributorRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.BusinessMusicalWorkContributorRole";
  }
  protected:
  explicit BusinessMusicalWorkContributorRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.BusinessMusicalWorkContributorRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CarrierType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CarrierType) */ {
 public:
  inline CarrierType() : CarrierType(nullptr) {}
  virtual ~CarrierType();

  CarrierType(const CarrierType& from);
  CarrierType(CarrierType&& from) noexcept
    : CarrierType() {
    *this = ::std::move(from);
  }

  inline CarrierType& operator=(const CarrierType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarrierType& operator=(CarrierType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CarrierType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CarrierType* internal_default_instance() {
    return reinterpret_cast<const CarrierType*>(
               &_CarrierType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CarrierType& a, CarrierType& b) {
    a.Swap(&b);
  }
  inline void Swap(CarrierType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarrierType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CarrierType* New() const final {
    return CreateMaybeMessage<CarrierType>(nullptr);
  }

  CarrierType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CarrierType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CarrierType& from);
  void MergeFrom(const CarrierType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarrierType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CarrierType";
  }
  protected:
  explicit CarrierType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CarrierType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CatalogTransferType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CatalogTransferType) */ {
 public:
  inline CatalogTransferType() : CatalogTransferType(nullptr) {}
  virtual ~CatalogTransferType();

  CatalogTransferType(const CatalogTransferType& from);
  CatalogTransferType(CatalogTransferType&& from) noexcept
    : CatalogTransferType() {
    *this = ::std::move(from);
  }

  inline CatalogTransferType& operator=(const CatalogTransferType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CatalogTransferType& operator=(CatalogTransferType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CatalogTransferType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CatalogTransferType* internal_default_instance() {
    return reinterpret_cast<const CatalogTransferType*>(
               &_CatalogTransferType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CatalogTransferType& a, CatalogTransferType& b) {
    a.Swap(&b);
  }
  inline void Swap(CatalogTransferType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CatalogTransferType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CatalogTransferType* New() const final {
    return CreateMaybeMessage<CatalogTransferType>(nullptr);
  }

  CatalogTransferType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CatalogTransferType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CatalogTransferType& from);
  void MergeFrom(const CatalogTransferType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CatalogTransferType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CatalogTransferType";
  }
  protected:
  explicit CatalogTransferType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CatalogTransferType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CdProtectionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CdProtectionType) */ {
 public:
  inline CdProtectionType() : CdProtectionType(nullptr) {}
  virtual ~CdProtectionType();

  CdProtectionType(const CdProtectionType& from);
  CdProtectionType(CdProtectionType&& from) noexcept
    : CdProtectionType() {
    *this = ::std::move(from);
  }

  inline CdProtectionType& operator=(const CdProtectionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdProtectionType& operator=(CdProtectionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CdProtectionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdProtectionType* internal_default_instance() {
    return reinterpret_cast<const CdProtectionType*>(
               &_CdProtectionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CdProtectionType& a, CdProtectionType& b) {
    a.Swap(&b);
  }
  inline void Swap(CdProtectionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CdProtectionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdProtectionType* New() const final {
    return CreateMaybeMessage<CdProtectionType>(nullptr);
  }

  CdProtectionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdProtectionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CdProtectionType& from);
  void MergeFrom(const CdProtectionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CdProtectionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CdProtectionType";
  }
  protected:
  explicit CdProtectionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CdProtectionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CharacterType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CharacterType) */ {
 public:
  inline CharacterType() : CharacterType(nullptr) {}
  virtual ~CharacterType();

  CharacterType(const CharacterType& from);
  CharacterType(CharacterType&& from) noexcept
    : CharacterType() {
    *this = ::std::move(from);
  }

  inline CharacterType& operator=(const CharacterType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterType& operator=(CharacterType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CharacterType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CharacterType* internal_default_instance() {
    return reinterpret_cast<const CharacterType*>(
               &_CharacterType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CharacterType& a, CharacterType& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CharacterType* New() const final {
    return CreateMaybeMessage<CharacterType>(nullptr);
  }

  CharacterType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CharacterType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CharacterType& from);
  void MergeFrom(const CharacterType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CharacterType";
  }
  protected:
  explicit CharacterType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CharacterType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ClaimStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ClaimStatus) */ {
 public:
  inline ClaimStatus() : ClaimStatus(nullptr) {}
  virtual ~ClaimStatus();

  ClaimStatus(const ClaimStatus& from);
  ClaimStatus(ClaimStatus&& from) noexcept
    : ClaimStatus() {
    *this = ::std::move(from);
  }

  inline ClaimStatus& operator=(const ClaimStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClaimStatus& operator=(ClaimStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClaimStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClaimStatus* internal_default_instance() {
    return reinterpret_cast<const ClaimStatus*>(
               &_ClaimStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ClaimStatus& a, ClaimStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ClaimStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClaimStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClaimStatus* New() const final {
    return CreateMaybeMessage<ClaimStatus>(nullptr);
  }

  ClaimStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClaimStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClaimStatus& from);
  void MergeFrom(const ClaimStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClaimStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ClaimStatus";
  }
  protected:
  explicit ClaimStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ClaimStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ClassifiedGenre PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ClassifiedGenre) */ {
 public:
  inline ClassifiedGenre() : ClassifiedGenre(nullptr) {}
  virtual ~ClassifiedGenre();

  ClassifiedGenre(const ClassifiedGenre& from);
  ClassifiedGenre(ClassifiedGenre&& from) noexcept
    : ClassifiedGenre() {
    *this = ::std::move(from);
  }

  inline ClassifiedGenre& operator=(const ClassifiedGenre& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassifiedGenre& operator=(ClassifiedGenre&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClassifiedGenre& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClassifiedGenre* internal_default_instance() {
    return reinterpret_cast<const ClassifiedGenre*>(
               &_ClassifiedGenre_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ClassifiedGenre& a, ClassifiedGenre& b) {
    a.Swap(&b);
  }
  inline void Swap(ClassifiedGenre* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClassifiedGenre* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClassifiedGenre* New() const final {
    return CreateMaybeMessage<ClassifiedGenre>(nullptr);
  }

  ClassifiedGenre* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClassifiedGenre>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClassifiedGenre& from);
  void MergeFrom(const ClassifiedGenre& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassifiedGenre* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ClassifiedGenre";
  }
  protected:
  explicit ClassifiedGenre(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ClassifiedGenre)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CodingType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CodingType) */ {
 public:
  inline CodingType() : CodingType(nullptr) {}
  virtual ~CodingType();

  CodingType(const CodingType& from);
  CodingType(CodingType&& from) noexcept
    : CodingType() {
    *this = ::std::move(from);
  }

  inline CodingType& operator=(const CodingType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CodingType& operator=(CodingType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CodingType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CodingType* internal_default_instance() {
    return reinterpret_cast<const CodingType*>(
               &_CodingType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CodingType& a, CodingType& b) {
    a.Swap(&b);
  }
  inline void Swap(CodingType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CodingType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CodingType* New() const final {
    return CreateMaybeMessage<CodingType>(nullptr);
  }

  CodingType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CodingType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CodingType& from);
  void MergeFrom(const CodingType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CodingType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CodingType";
  }
  protected:
  explicit CodingType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CodingType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CommentaryNoteType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CommentaryNoteType) */ {
 public:
  inline CommentaryNoteType() : CommentaryNoteType(nullptr) {}
  virtual ~CommentaryNoteType();

  CommentaryNoteType(const CommentaryNoteType& from);
  CommentaryNoteType(CommentaryNoteType&& from) noexcept
    : CommentaryNoteType() {
    *this = ::std::move(from);
  }

  inline CommentaryNoteType& operator=(const CommentaryNoteType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommentaryNoteType& operator=(CommentaryNoteType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommentaryNoteType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommentaryNoteType* internal_default_instance() {
    return reinterpret_cast<const CommentaryNoteType*>(
               &_CommentaryNoteType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CommentaryNoteType& a, CommentaryNoteType& b) {
    a.Swap(&b);
  }
  inline void Swap(CommentaryNoteType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommentaryNoteType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommentaryNoteType* New() const final {
    return CreateMaybeMessage<CommentaryNoteType>(nullptr);
  }

  CommentaryNoteType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommentaryNoteType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommentaryNoteType& from);
  void MergeFrom(const CommentaryNoteType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommentaryNoteType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CommentaryNoteType";
  }
  protected:
  explicit CommentaryNoteType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CommentaryNoteType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CommercialModelType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CommercialModelType) */ {
 public:
  inline CommercialModelType() : CommercialModelType(nullptr) {}
  virtual ~CommercialModelType();

  CommercialModelType(const CommercialModelType& from);
  CommercialModelType(CommercialModelType&& from) noexcept
    : CommercialModelType() {
    *this = ::std::move(from);
  }

  inline CommercialModelType& operator=(const CommercialModelType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommercialModelType& operator=(CommercialModelType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommercialModelType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommercialModelType* internal_default_instance() {
    return reinterpret_cast<const CommercialModelType*>(
               &_CommercialModelType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CommercialModelType& a, CommercialModelType& b) {
    a.Swap(&b);
  }
  inline void Swap(CommercialModelType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommercialModelType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommercialModelType* New() const final {
    return CreateMaybeMessage<CommercialModelType>(nullptr);
  }

  CommercialModelType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommercialModelType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommercialModelType& from);
  void MergeFrom(const CommercialModelType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommercialModelType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CommercialModelType";
  }
  protected:
  explicit CommercialModelType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CommercialModelType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CommercialModelType_MWNL PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CommercialModelType_MWNL) */ {
 public:
  inline CommercialModelType_MWNL() : CommercialModelType_MWNL(nullptr) {}
  virtual ~CommercialModelType_MWNL();

  CommercialModelType_MWNL(const CommercialModelType_MWNL& from);
  CommercialModelType_MWNL(CommercialModelType_MWNL&& from) noexcept
    : CommercialModelType_MWNL() {
    *this = ::std::move(from);
  }

  inline CommercialModelType_MWNL& operator=(const CommercialModelType_MWNL& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommercialModelType_MWNL& operator=(CommercialModelType_MWNL&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommercialModelType_MWNL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommercialModelType_MWNL* internal_default_instance() {
    return reinterpret_cast<const CommercialModelType_MWNL*>(
               &_CommercialModelType_MWNL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CommercialModelType_MWNL& a, CommercialModelType_MWNL& b) {
    a.Swap(&b);
  }
  inline void Swap(CommercialModelType_MWNL* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommercialModelType_MWNL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommercialModelType_MWNL* New() const final {
    return CreateMaybeMessage<CommercialModelType_MWNL>(nullptr);
  }

  CommercialModelType_MWNL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommercialModelType_MWNL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommercialModelType_MWNL& from);
  void MergeFrom(const CommercialModelType_MWNL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommercialModelType_MWNL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CommercialModelType_MWNL";
  }
  protected:
  explicit CommercialModelType_MWNL(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CommercialModelType_MWNL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CompilationType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CompilationType) */ {
 public:
  inline CompilationType() : CompilationType(nullptr) {}
  virtual ~CompilationType();

  CompilationType(const CompilationType& from);
  CompilationType(CompilationType&& from) noexcept
    : CompilationType() {
    *this = ::std::move(from);
  }

  inline CompilationType& operator=(const CompilationType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompilationType& operator=(CompilationType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CompilationType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompilationType* internal_default_instance() {
    return reinterpret_cast<const CompilationType*>(
               &_CompilationType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CompilationType& a, CompilationType& b) {
    a.Swap(&b);
  }
  inline void Swap(CompilationType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompilationType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompilationType* New() const final {
    return CreateMaybeMessage<CompilationType>(nullptr);
  }

  CompilationType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompilationType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CompilationType& from);
  void MergeFrom(const CompilationType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompilationType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CompilationType";
  }
  protected:
  explicit CompilationType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CompilationType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CompositeMusicalWorkType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CompositeMusicalWorkType) */ {
 public:
  inline CompositeMusicalWorkType() : CompositeMusicalWorkType(nullptr) {}
  virtual ~CompositeMusicalWorkType();

  CompositeMusicalWorkType(const CompositeMusicalWorkType& from);
  CompositeMusicalWorkType(CompositeMusicalWorkType&& from) noexcept
    : CompositeMusicalWorkType() {
    *this = ::std::move(from);
  }

  inline CompositeMusicalWorkType& operator=(const CompositeMusicalWorkType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompositeMusicalWorkType& operator=(CompositeMusicalWorkType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CompositeMusicalWorkType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompositeMusicalWorkType* internal_default_instance() {
    return reinterpret_cast<const CompositeMusicalWorkType*>(
               &_CompositeMusicalWorkType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CompositeMusicalWorkType& a, CompositeMusicalWorkType& b) {
    a.Swap(&b);
  }
  inline void Swap(CompositeMusicalWorkType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompositeMusicalWorkType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompositeMusicalWorkType* New() const final {
    return CreateMaybeMessage<CompositeMusicalWorkType>(nullptr);
  }

  CompositeMusicalWorkType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompositeMusicalWorkType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CompositeMusicalWorkType& from);
  void MergeFrom(const CompositeMusicalWorkType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompositeMusicalWorkType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CompositeMusicalWorkType";
  }
  protected:
  explicit CompositeMusicalWorkType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CompositeMusicalWorkType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ContainerFormat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ContainerFormat) */ {
 public:
  inline ContainerFormat() : ContainerFormat(nullptr) {}
  virtual ~ContainerFormat();

  ContainerFormat(const ContainerFormat& from);
  ContainerFormat(ContainerFormat&& from) noexcept
    : ContainerFormat() {
    *this = ::std::move(from);
  }

  inline ContainerFormat& operator=(const ContainerFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContainerFormat& operator=(ContainerFormat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContainerFormat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerFormat* internal_default_instance() {
    return reinterpret_cast<const ContainerFormat*>(
               &_ContainerFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ContainerFormat& a, ContainerFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(ContainerFormat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContainerFormat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContainerFormat* New() const final {
    return CreateMaybeMessage<ContainerFormat>(nullptr);
  }

  ContainerFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContainerFormat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContainerFormat& from);
  void MergeFrom(const ContainerFormat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContainerFormat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ContainerFormat";
  }
  protected:
  explicit ContainerFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ContainerFormat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ContributorRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ContributorRole) */ {
 public:
  inline ContributorRole() : ContributorRole(nullptr) {}
  virtual ~ContributorRole();

  ContributorRole(const ContributorRole& from);
  ContributorRole(ContributorRole&& from) noexcept
    : ContributorRole() {
    *this = ::std::move(from);
  }

  inline ContributorRole& operator=(const ContributorRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContributorRole& operator=(ContributorRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContributorRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContributorRole* internal_default_instance() {
    return reinterpret_cast<const ContributorRole*>(
               &_ContributorRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ContributorRole& a, ContributorRole& b) {
    a.Swap(&b);
  }
  inline void Swap(ContributorRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContributorRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContributorRole* New() const final {
    return CreateMaybeMessage<ContributorRole>(nullptr);
  }

  ContributorRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContributorRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContributorRole& from);
  void MergeFrom(const ContributorRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContributorRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ContributorRole";
  }
  protected:
  explicit ContributorRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ContributorRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CreativeMusicalWorkContributorRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CreativeMusicalWorkContributorRole) */ {
 public:
  inline CreativeMusicalWorkContributorRole() : CreativeMusicalWorkContributorRole(nullptr) {}
  virtual ~CreativeMusicalWorkContributorRole();

  CreativeMusicalWorkContributorRole(const CreativeMusicalWorkContributorRole& from);
  CreativeMusicalWorkContributorRole(CreativeMusicalWorkContributorRole&& from) noexcept
    : CreativeMusicalWorkContributorRole() {
    *this = ::std::move(from);
  }

  inline CreativeMusicalWorkContributorRole& operator=(const CreativeMusicalWorkContributorRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreativeMusicalWorkContributorRole& operator=(CreativeMusicalWorkContributorRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreativeMusicalWorkContributorRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreativeMusicalWorkContributorRole* internal_default_instance() {
    return reinterpret_cast<const CreativeMusicalWorkContributorRole*>(
               &_CreativeMusicalWorkContributorRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CreativeMusicalWorkContributorRole& a, CreativeMusicalWorkContributorRole& b) {
    a.Swap(&b);
  }
  inline void Swap(CreativeMusicalWorkContributorRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreativeMusicalWorkContributorRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreativeMusicalWorkContributorRole* New() const final {
    return CreateMaybeMessage<CreativeMusicalWorkContributorRole>(nullptr);
  }

  CreativeMusicalWorkContributorRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreativeMusicalWorkContributorRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreativeMusicalWorkContributorRole& from);
  void MergeFrom(const CreativeMusicalWorkContributorRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreativeMusicalWorkContributorRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CreativeMusicalWorkContributorRole";
  }
  protected:
  explicit CreativeMusicalWorkContributorRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CreativeMusicalWorkContributorRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CueOrigin PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CueOrigin) */ {
 public:
  inline CueOrigin() : CueOrigin(nullptr) {}
  virtual ~CueOrigin();

  CueOrigin(const CueOrigin& from);
  CueOrigin(CueOrigin&& from) noexcept
    : CueOrigin() {
    *this = ::std::move(from);
  }

  inline CueOrigin& operator=(const CueOrigin& from) {
    CopyFrom(from);
    return *this;
  }
  inline CueOrigin& operator=(CueOrigin&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CueOrigin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CueOrigin* internal_default_instance() {
    return reinterpret_cast<const CueOrigin*>(
               &_CueOrigin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CueOrigin& a, CueOrigin& b) {
    a.Swap(&b);
  }
  inline void Swap(CueOrigin* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CueOrigin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CueOrigin* New() const final {
    return CreateMaybeMessage<CueOrigin>(nullptr);
  }

  CueOrigin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CueOrigin>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CueOrigin& from);
  void MergeFrom(const CueOrigin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CueOrigin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CueOrigin";
  }
  protected:
  explicit CueOrigin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CueOrigin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CueSheetType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CueSheetType) */ {
 public:
  inline CueSheetType() : CueSheetType(nullptr) {}
  virtual ~CueSheetType();

  CueSheetType(const CueSheetType& from);
  CueSheetType(CueSheetType&& from) noexcept
    : CueSheetType() {
    *this = ::std::move(from);
  }

  inline CueSheetType& operator=(const CueSheetType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CueSheetType& operator=(CueSheetType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CueSheetType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CueSheetType* internal_default_instance() {
    return reinterpret_cast<const CueSheetType*>(
               &_CueSheetType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CueSheetType& a, CueSheetType& b) {
    a.Swap(&b);
  }
  inline void Swap(CueSheetType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CueSheetType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CueSheetType* New() const final {
    return CreateMaybeMessage<CueSheetType>(nullptr);
  }

  CueSheetType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CueSheetType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CueSheetType& from);
  void MergeFrom(const CueSheetType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CueSheetType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CueSheetType";
  }
  protected:
  explicit CueSheetType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CueSheetType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CueUseType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CueUseType) */ {
 public:
  inline CueUseType() : CueUseType(nullptr) {}
  virtual ~CueUseType();

  CueUseType(const CueUseType& from);
  CueUseType(CueUseType&& from) noexcept
    : CueUseType() {
    *this = ::std::move(from);
  }

  inline CueUseType& operator=(const CueUseType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CueUseType& operator=(CueUseType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CueUseType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CueUseType* internal_default_instance() {
    return reinterpret_cast<const CueUseType*>(
               &_CueUseType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CueUseType& a, CueUseType& b) {
    a.Swap(&b);
  }
  inline void Swap(CueUseType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CueUseType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CueUseType* New() const final {
    return CreateMaybeMessage<CueUseType>(nullptr);
  }

  CueUseType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CueUseType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CueUseType& from);
  void MergeFrom(const CueUseType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CueUseType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CueUseType";
  }
  protected:
  explicit CueUseType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CueUseType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CurrencyCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CurrencyCode) */ {
 public:
  inline CurrencyCode() : CurrencyCode(nullptr) {}
  virtual ~CurrencyCode();

  CurrencyCode(const CurrencyCode& from);
  CurrencyCode(CurrencyCode&& from) noexcept
    : CurrencyCode() {
    *this = ::std::move(from);
  }

  inline CurrencyCode& operator=(const CurrencyCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrencyCode& operator=(CurrencyCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CurrencyCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CurrencyCode* internal_default_instance() {
    return reinterpret_cast<const CurrencyCode*>(
               &_CurrencyCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CurrencyCode& a, CurrencyCode& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrencyCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrencyCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CurrencyCode* New() const final {
    return CreateMaybeMessage<CurrencyCode>(nullptr);
  }

  CurrencyCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CurrencyCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CurrencyCode& from);
  void MergeFrom(const CurrencyCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrencyCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CurrencyCode";
  }
  protected:
  explicit CurrencyCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CurrencyCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class CurrentTerritoryCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.CurrentTerritoryCode) */ {
 public:
  inline CurrentTerritoryCode() : CurrentTerritoryCode(nullptr) {}
  virtual ~CurrentTerritoryCode();

  CurrentTerritoryCode(const CurrentTerritoryCode& from);
  CurrentTerritoryCode(CurrentTerritoryCode&& from) noexcept
    : CurrentTerritoryCode() {
    *this = ::std::move(from);
  }

  inline CurrentTerritoryCode& operator=(const CurrentTerritoryCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrentTerritoryCode& operator=(CurrentTerritoryCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CurrentTerritoryCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CurrentTerritoryCode* internal_default_instance() {
    return reinterpret_cast<const CurrentTerritoryCode*>(
               &_CurrentTerritoryCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CurrentTerritoryCode& a, CurrentTerritoryCode& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrentTerritoryCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrentTerritoryCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CurrentTerritoryCode* New() const final {
    return CreateMaybeMessage<CurrentTerritoryCode>(nullptr);
  }

  CurrentTerritoryCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CurrentTerritoryCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CurrentTerritoryCode& from);
  void MergeFrom(const CurrentTerritoryCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentTerritoryCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.CurrentTerritoryCode";
  }
  protected:
  explicit CurrentTerritoryCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.CurrentTerritoryCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DanceAndRhythmStyle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DanceAndRhythmStyle) */ {
 public:
  inline DanceAndRhythmStyle() : DanceAndRhythmStyle(nullptr) {}
  virtual ~DanceAndRhythmStyle();

  DanceAndRhythmStyle(const DanceAndRhythmStyle& from);
  DanceAndRhythmStyle(DanceAndRhythmStyle&& from) noexcept
    : DanceAndRhythmStyle() {
    *this = ::std::move(from);
  }

  inline DanceAndRhythmStyle& operator=(const DanceAndRhythmStyle& from) {
    CopyFrom(from);
    return *this;
  }
  inline DanceAndRhythmStyle& operator=(DanceAndRhythmStyle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DanceAndRhythmStyle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DanceAndRhythmStyle* internal_default_instance() {
    return reinterpret_cast<const DanceAndRhythmStyle*>(
               &_DanceAndRhythmStyle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(DanceAndRhythmStyle& a, DanceAndRhythmStyle& b) {
    a.Swap(&b);
  }
  inline void Swap(DanceAndRhythmStyle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DanceAndRhythmStyle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DanceAndRhythmStyle* New() const final {
    return CreateMaybeMessage<DanceAndRhythmStyle>(nullptr);
  }

  DanceAndRhythmStyle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DanceAndRhythmStyle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DanceAndRhythmStyle& from);
  void MergeFrom(const DanceAndRhythmStyle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DanceAndRhythmStyle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DanceAndRhythmStyle";
  }
  protected:
  explicit DanceAndRhythmStyle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DanceAndRhythmStyle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DataCarrierFormat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DataCarrierFormat) */ {
 public:
  inline DataCarrierFormat() : DataCarrierFormat(nullptr) {}
  virtual ~DataCarrierFormat();

  DataCarrierFormat(const DataCarrierFormat& from);
  DataCarrierFormat(DataCarrierFormat&& from) noexcept
    : DataCarrierFormat() {
    *this = ::std::move(from);
  }

  inline DataCarrierFormat& operator=(const DataCarrierFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataCarrierFormat& operator=(DataCarrierFormat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataCarrierFormat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataCarrierFormat* internal_default_instance() {
    return reinterpret_cast<const DataCarrierFormat*>(
               &_DataCarrierFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(DataCarrierFormat& a, DataCarrierFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(DataCarrierFormat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataCarrierFormat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataCarrierFormat* New() const final {
    return CreateMaybeMessage<DataCarrierFormat>(nullptr);
  }

  DataCarrierFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataCarrierFormat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataCarrierFormat& from);
  void MergeFrom(const DataCarrierFormat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataCarrierFormat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DataCarrierFormat";
  }
  protected:
  explicit DataCarrierFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DataCarrierFormat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DataCarrierType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DataCarrierType) */ {
 public:
  inline DataCarrierType() : DataCarrierType(nullptr) {}
  virtual ~DataCarrierType();

  DataCarrierType(const DataCarrierType& from);
  DataCarrierType(DataCarrierType&& from) noexcept
    : DataCarrierType() {
    *this = ::std::move(from);
  }

  inline DataCarrierType& operator=(const DataCarrierType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataCarrierType& operator=(DataCarrierType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataCarrierType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataCarrierType* internal_default_instance() {
    return reinterpret_cast<const DataCarrierType*>(
               &_DataCarrierType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(DataCarrierType& a, DataCarrierType& b) {
    a.Swap(&b);
  }
  inline void Swap(DataCarrierType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataCarrierType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataCarrierType* New() const final {
    return CreateMaybeMessage<DataCarrierType>(nullptr);
  }

  DataCarrierType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataCarrierType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataCarrierType& from);
  void MergeFrom(const DataCarrierType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataCarrierType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DataCarrierType";
  }
  protected:
  explicit DataCarrierType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DataCarrierType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DdexTerritoryCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DdexTerritoryCode) */ {
 public:
  inline DdexTerritoryCode() : DdexTerritoryCode(nullptr) {}
  virtual ~DdexTerritoryCode();

  DdexTerritoryCode(const DdexTerritoryCode& from);
  DdexTerritoryCode(DdexTerritoryCode&& from) noexcept
    : DdexTerritoryCode() {
    *this = ::std::move(from);
  }

  inline DdexTerritoryCode& operator=(const DdexTerritoryCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DdexTerritoryCode& operator=(DdexTerritoryCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DdexTerritoryCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DdexTerritoryCode* internal_default_instance() {
    return reinterpret_cast<const DdexTerritoryCode*>(
               &_DdexTerritoryCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DdexTerritoryCode& a, DdexTerritoryCode& b) {
    a.Swap(&b);
  }
  inline void Swap(DdexTerritoryCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DdexTerritoryCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DdexTerritoryCode* New() const final {
    return CreateMaybeMessage<DdexTerritoryCode>(nullptr);
  }

  DdexTerritoryCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DdexTerritoryCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DdexTerritoryCode& from);
  void MergeFrom(const DdexTerritoryCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DdexTerritoryCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DdexTerritoryCode";
  }
  protected:
  explicit DdexTerritoryCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DdexTerritoryCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DeprecatedCurrencyCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DeprecatedCurrencyCode) */ {
 public:
  inline DeprecatedCurrencyCode() : DeprecatedCurrencyCode(nullptr) {}
  virtual ~DeprecatedCurrencyCode();

  DeprecatedCurrencyCode(const DeprecatedCurrencyCode& from);
  DeprecatedCurrencyCode(DeprecatedCurrencyCode&& from) noexcept
    : DeprecatedCurrencyCode() {
    *this = ::std::move(from);
  }

  inline DeprecatedCurrencyCode& operator=(const DeprecatedCurrencyCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeprecatedCurrencyCode& operator=(DeprecatedCurrencyCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeprecatedCurrencyCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeprecatedCurrencyCode* internal_default_instance() {
    return reinterpret_cast<const DeprecatedCurrencyCode*>(
               &_DeprecatedCurrencyCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(DeprecatedCurrencyCode& a, DeprecatedCurrencyCode& b) {
    a.Swap(&b);
  }
  inline void Swap(DeprecatedCurrencyCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeprecatedCurrencyCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeprecatedCurrencyCode* New() const final {
    return CreateMaybeMessage<DeprecatedCurrencyCode>(nullptr);
  }

  DeprecatedCurrencyCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeprecatedCurrencyCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeprecatedCurrencyCode& from);
  void MergeFrom(const DeprecatedCurrencyCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeprecatedCurrencyCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DeprecatedCurrencyCode";
  }
  protected:
  explicit DeprecatedCurrencyCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DeprecatedCurrencyCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DeprecatedIsoTerritoryCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DeprecatedIsoTerritoryCode) */ {
 public:
  inline DeprecatedIsoTerritoryCode() : DeprecatedIsoTerritoryCode(nullptr) {}
  virtual ~DeprecatedIsoTerritoryCode();

  DeprecatedIsoTerritoryCode(const DeprecatedIsoTerritoryCode& from);
  DeprecatedIsoTerritoryCode(DeprecatedIsoTerritoryCode&& from) noexcept
    : DeprecatedIsoTerritoryCode() {
    *this = ::std::move(from);
  }

  inline DeprecatedIsoTerritoryCode& operator=(const DeprecatedIsoTerritoryCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeprecatedIsoTerritoryCode& operator=(DeprecatedIsoTerritoryCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeprecatedIsoTerritoryCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeprecatedIsoTerritoryCode* internal_default_instance() {
    return reinterpret_cast<const DeprecatedIsoTerritoryCode*>(
               &_DeprecatedIsoTerritoryCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(DeprecatedIsoTerritoryCode& a, DeprecatedIsoTerritoryCode& b) {
    a.Swap(&b);
  }
  inline void Swap(DeprecatedIsoTerritoryCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeprecatedIsoTerritoryCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeprecatedIsoTerritoryCode* New() const final {
    return CreateMaybeMessage<DeprecatedIsoTerritoryCode>(nullptr);
  }

  DeprecatedIsoTerritoryCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeprecatedIsoTerritoryCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeprecatedIsoTerritoryCode& from);
  void MergeFrom(const DeprecatedIsoTerritoryCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeprecatedIsoTerritoryCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DeprecatedIsoTerritoryCode";
  }
  protected:
  explicit DeprecatedIsoTerritoryCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DeprecatedIsoTerritoryCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DeprecatedReleaseType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DeprecatedReleaseType) */ {
 public:
  inline DeprecatedReleaseType() : DeprecatedReleaseType(nullptr) {}
  virtual ~DeprecatedReleaseType();

  DeprecatedReleaseType(const DeprecatedReleaseType& from);
  DeprecatedReleaseType(DeprecatedReleaseType&& from) noexcept
    : DeprecatedReleaseType() {
    *this = ::std::move(from);
  }

  inline DeprecatedReleaseType& operator=(const DeprecatedReleaseType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeprecatedReleaseType& operator=(DeprecatedReleaseType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeprecatedReleaseType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeprecatedReleaseType* internal_default_instance() {
    return reinterpret_cast<const DeprecatedReleaseType*>(
               &_DeprecatedReleaseType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(DeprecatedReleaseType& a, DeprecatedReleaseType& b) {
    a.Swap(&b);
  }
  inline void Swap(DeprecatedReleaseType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeprecatedReleaseType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeprecatedReleaseType* New() const final {
    return CreateMaybeMessage<DeprecatedReleaseType>(nullptr);
  }

  DeprecatedReleaseType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeprecatedReleaseType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeprecatedReleaseType& from);
  void MergeFrom(const DeprecatedReleaseType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeprecatedReleaseType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DeprecatedReleaseType";
  }
  protected:
  explicit DeprecatedReleaseType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DeprecatedReleaseType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DigitizationMode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DigitizationMode) */ {
 public:
  inline DigitizationMode() : DigitizationMode(nullptr) {}
  virtual ~DigitizationMode();

  DigitizationMode(const DigitizationMode& from);
  DigitizationMode(DigitizationMode&& from) noexcept
    : DigitizationMode() {
    *this = ::std::move(from);
  }

  inline DigitizationMode& operator=(const DigitizationMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigitizationMode& operator=(DigitizationMode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DigitizationMode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DigitizationMode* internal_default_instance() {
    return reinterpret_cast<const DigitizationMode*>(
               &_DigitizationMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(DigitizationMode& a, DigitizationMode& b) {
    a.Swap(&b);
  }
  inline void Swap(DigitizationMode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DigitizationMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DigitizationMode* New() const final {
    return CreateMaybeMessage<DigitizationMode>(nullptr);
  }

  DigitizationMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DigitizationMode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DigitizationMode& from);
  void MergeFrom(const DigitizationMode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigitizationMode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DigitizationMode";
  }
  protected:
  explicit DigitizationMode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DigitizationMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DisplayArtistRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DisplayArtistRole) */ {
 public:
  inline DisplayArtistRole() : DisplayArtistRole(nullptr) {}
  virtual ~DisplayArtistRole();

  DisplayArtistRole(const DisplayArtistRole& from);
  DisplayArtistRole(DisplayArtistRole&& from) noexcept
    : DisplayArtistRole() {
    *this = ::std::move(from);
  }

  inline DisplayArtistRole& operator=(const DisplayArtistRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisplayArtistRole& operator=(DisplayArtistRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DisplayArtistRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DisplayArtistRole* internal_default_instance() {
    return reinterpret_cast<const DisplayArtistRole*>(
               &_DisplayArtistRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(DisplayArtistRole& a, DisplayArtistRole& b) {
    a.Swap(&b);
  }
  inline void Swap(DisplayArtistRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisplayArtistRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DisplayArtistRole* New() const final {
    return CreateMaybeMessage<DisplayArtistRole>(nullptr);
  }

  DisplayArtistRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DisplayArtistRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DisplayArtistRole& from);
  void MergeFrom(const DisplayArtistRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisplayArtistRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DisplayArtistRole";
  }
  protected:
  explicit DisplayArtistRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DisplayArtistRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DistributionChannelType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DistributionChannelType) */ {
 public:
  inline DistributionChannelType() : DistributionChannelType(nullptr) {}
  virtual ~DistributionChannelType();

  DistributionChannelType(const DistributionChannelType& from);
  DistributionChannelType(DistributionChannelType&& from) noexcept
    : DistributionChannelType() {
    *this = ::std::move(from);
  }

  inline DistributionChannelType& operator=(const DistributionChannelType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistributionChannelType& operator=(DistributionChannelType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DistributionChannelType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DistributionChannelType* internal_default_instance() {
    return reinterpret_cast<const DistributionChannelType*>(
               &_DistributionChannelType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(DistributionChannelType& a, DistributionChannelType& b) {
    a.Swap(&b);
  }
  inline void Swap(DistributionChannelType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DistributionChannelType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DistributionChannelType* New() const final {
    return CreateMaybeMessage<DistributionChannelType>(nullptr);
  }

  DistributionChannelType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DistributionChannelType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DistributionChannelType& from);
  void MergeFrom(const DistributionChannelType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistributionChannelType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DistributionChannelType";
  }
  protected:
  explicit DistributionChannelType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DistributionChannelType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DocumentType_LoD PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DocumentType_LoD) */ {
 public:
  inline DocumentType_LoD() : DocumentType_LoD(nullptr) {}
  virtual ~DocumentType_LoD();

  DocumentType_LoD(const DocumentType_LoD& from);
  DocumentType_LoD(DocumentType_LoD&& from) noexcept
    : DocumentType_LoD() {
    *this = ::std::move(from);
  }

  inline DocumentType_LoD& operator=(const DocumentType_LoD& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentType_LoD& operator=(DocumentType_LoD&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DocumentType_LoD& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DocumentType_LoD* internal_default_instance() {
    return reinterpret_cast<const DocumentType_LoD*>(
               &_DocumentType_LoD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(DocumentType_LoD& a, DocumentType_LoD& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentType_LoD* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentType_LoD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DocumentType_LoD* New() const final {
    return CreateMaybeMessage<DocumentType_LoD>(nullptr);
  }

  DocumentType_LoD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DocumentType_LoD>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DocumentType_LoD& from);
  void MergeFrom(const DocumentType_LoD& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentType_LoD* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DocumentType_LoD";
  }
  protected:
  explicit DocumentType_LoD(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DocumentType_LoD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DocumentType_MWL PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DocumentType_MWL) */ {
 public:
  inline DocumentType_MWL() : DocumentType_MWL(nullptr) {}
  virtual ~DocumentType_MWL();

  DocumentType_MWL(const DocumentType_MWL& from);
  DocumentType_MWL(DocumentType_MWL&& from) noexcept
    : DocumentType_MWL() {
    *this = ::std::move(from);
  }

  inline DocumentType_MWL& operator=(const DocumentType_MWL& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentType_MWL& operator=(DocumentType_MWL&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DocumentType_MWL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DocumentType_MWL* internal_default_instance() {
    return reinterpret_cast<const DocumentType_MWL*>(
               &_DocumentType_MWL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(DocumentType_MWL& a, DocumentType_MWL& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentType_MWL* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentType_MWL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DocumentType_MWL* New() const final {
    return CreateMaybeMessage<DocumentType_MWL>(nullptr);
  }

  DocumentType_MWL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DocumentType_MWL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DocumentType_MWL& from);
  void MergeFrom(const DocumentType_MWL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentType_MWL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DocumentType_MWL";
  }
  protected:
  explicit DocumentType_MWL(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DocumentType_MWL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DpidStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DpidStatus) */ {
 public:
  inline DpidStatus() : DpidStatus(nullptr) {}
  virtual ~DpidStatus();

  DpidStatus(const DpidStatus& from);
  DpidStatus(DpidStatus&& from) noexcept
    : DpidStatus() {
    *this = ::std::move(from);
  }

  inline DpidStatus& operator=(const DpidStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DpidStatus& operator=(DpidStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DpidStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DpidStatus* internal_default_instance() {
    return reinterpret_cast<const DpidStatus*>(
               &_DpidStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(DpidStatus& a, DpidStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(DpidStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DpidStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DpidStatus* New() const final {
    return CreateMaybeMessage<DpidStatus>(nullptr);
  }

  DpidStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DpidStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DpidStatus& from);
  void MergeFrom(const DpidStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DpidStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DpidStatus";
  }
  protected:
  explicit DpidStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DpidStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class DrmEnforcementType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.DrmEnforcementType) */ {
 public:
  inline DrmEnforcementType() : DrmEnforcementType(nullptr) {}
  virtual ~DrmEnforcementType();

  DrmEnforcementType(const DrmEnforcementType& from);
  DrmEnforcementType(DrmEnforcementType&& from) noexcept
    : DrmEnforcementType() {
    *this = ::std::move(from);
  }

  inline DrmEnforcementType& operator=(const DrmEnforcementType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrmEnforcementType& operator=(DrmEnforcementType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DrmEnforcementType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DrmEnforcementType* internal_default_instance() {
    return reinterpret_cast<const DrmEnforcementType*>(
               &_DrmEnforcementType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(DrmEnforcementType& a, DrmEnforcementType& b) {
    a.Swap(&b);
  }
  inline void Swap(DrmEnforcementType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrmEnforcementType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DrmEnforcementType* New() const final {
    return CreateMaybeMessage<DrmEnforcementType>(nullptr);
  }

  DrmEnforcementType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DrmEnforcementType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DrmEnforcementType& from);
  void MergeFrom(const DrmEnforcementType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrmEnforcementType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.DrmEnforcementType";
  }
  protected:
  explicit DrmEnforcementType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.DrmEnforcementType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ElementConfiguration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ElementConfiguration) */ {
 public:
  inline ElementConfiguration() : ElementConfiguration(nullptr) {}
  virtual ~ElementConfiguration();

  ElementConfiguration(const ElementConfiguration& from);
  ElementConfiguration(ElementConfiguration&& from) noexcept
    : ElementConfiguration() {
    *this = ::std::move(from);
  }

  inline ElementConfiguration& operator=(const ElementConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementConfiguration& operator=(ElementConfiguration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ElementConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ElementConfiguration* internal_default_instance() {
    return reinterpret_cast<const ElementConfiguration*>(
               &_ElementConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ElementConfiguration& a, ElementConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(ElementConfiguration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ElementConfiguration* New() const final {
    return CreateMaybeMessage<ElementConfiguration>(nullptr);
  }

  ElementConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ElementConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ElementConfiguration& from);
  void MergeFrom(const ElementConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElementConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ElementConfiguration";
  }
  protected:
  explicit ElementConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ElementConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ElementDesignation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ElementDesignation) */ {
 public:
  inline ElementDesignation() : ElementDesignation(nullptr) {}
  virtual ~ElementDesignation();

  ElementDesignation(const ElementDesignation& from);
  ElementDesignation(ElementDesignation&& from) noexcept
    : ElementDesignation() {
    *this = ::std::move(from);
  }

  inline ElementDesignation& operator=(const ElementDesignation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementDesignation& operator=(ElementDesignation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ElementDesignation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ElementDesignation* internal_default_instance() {
    return reinterpret_cast<const ElementDesignation*>(
               &_ElementDesignation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(ElementDesignation& a, ElementDesignation& b) {
    a.Swap(&b);
  }
  inline void Swap(ElementDesignation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementDesignation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ElementDesignation* New() const final {
    return CreateMaybeMessage<ElementDesignation>(nullptr);
  }

  ElementDesignation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ElementDesignation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ElementDesignation& from);
  void MergeFrom(const ElementDesignation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElementDesignation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ElementDesignation";
  }
  protected:
  explicit ElementDesignation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ElementDesignation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class EncodingType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.EncodingType) */ {
 public:
  inline EncodingType() : EncodingType(nullptr) {}
  virtual ~EncodingType();

  EncodingType(const EncodingType& from);
  EncodingType(EncodingType&& from) noexcept
    : EncodingType() {
    *this = ::std::move(from);
  }

  inline EncodingType& operator=(const EncodingType& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncodingType& operator=(EncodingType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EncodingType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EncodingType* internal_default_instance() {
    return reinterpret_cast<const EncodingType*>(
               &_EncodingType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(EncodingType& a, EncodingType& b) {
    a.Swap(&b);
  }
  inline void Swap(EncodingType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncodingType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EncodingType* New() const final {
    return CreateMaybeMessage<EncodingType>(nullptr);
  }

  EncodingType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EncodingType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EncodingType& from);
  void MergeFrom(const EncodingType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncodingType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.EncodingType";
  }
  protected:
  explicit EncodingType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.EncodingType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class EquipmentType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.EquipmentType) */ {
 public:
  inline EquipmentType() : EquipmentType(nullptr) {}
  virtual ~EquipmentType();

  EquipmentType(const EquipmentType& from);
  EquipmentType(EquipmentType&& from) noexcept
    : EquipmentType() {
    *this = ::std::move(from);
  }

  inline EquipmentType& operator=(const EquipmentType& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentType& operator=(EquipmentType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EquipmentType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EquipmentType* internal_default_instance() {
    return reinterpret_cast<const EquipmentType*>(
               &_EquipmentType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(EquipmentType& a, EquipmentType& b) {
    a.Swap(&b);
  }
  inline void Swap(EquipmentType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EquipmentType* New() const final {
    return CreateMaybeMessage<EquipmentType>(nullptr);
  }

  EquipmentType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EquipmentType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EquipmentType& from);
  void MergeFrom(const EquipmentType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EquipmentType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.EquipmentType";
  }
  protected:
  explicit EquipmentType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.EquipmentType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ErnMessageType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ErnMessageType) */ {
 public:
  inline ErnMessageType() : ErnMessageType(nullptr) {}
  virtual ~ErnMessageType();

  ErnMessageType(const ErnMessageType& from);
  ErnMessageType(ErnMessageType&& from) noexcept
    : ErnMessageType() {
    *this = ::std::move(from);
  }

  inline ErnMessageType& operator=(const ErnMessageType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErnMessageType& operator=(ErnMessageType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ErnMessageType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErnMessageType* internal_default_instance() {
    return reinterpret_cast<const ErnMessageType*>(
               &_ErnMessageType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ErnMessageType& a, ErnMessageType& b) {
    a.Swap(&b);
  }
  inline void Swap(ErnMessageType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErnMessageType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErnMessageType* New() const final {
    return CreateMaybeMessage<ErnMessageType>(nullptr);
  }

  ErnMessageType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErnMessageType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ErnMessageType& from);
  void MergeFrom(const ErnMessageType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErnMessageType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ErnMessageType";
  }
  protected:
  explicit ErnMessageType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ErnMessageType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ErnTestMessageType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ErnTestMessageType) */ {
 public:
  inline ErnTestMessageType() : ErnTestMessageType(nullptr) {}
  virtual ~ErnTestMessageType();

  ErnTestMessageType(const ErnTestMessageType& from);
  ErnTestMessageType(ErnTestMessageType&& from) noexcept
    : ErnTestMessageType() {
    *this = ::std::move(from);
  }

  inline ErnTestMessageType& operator=(const ErnTestMessageType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErnTestMessageType& operator=(ErnTestMessageType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ErnTestMessageType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErnTestMessageType* internal_default_instance() {
    return reinterpret_cast<const ErnTestMessageType*>(
               &_ErnTestMessageType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(ErnTestMessageType& a, ErnTestMessageType& b) {
    a.Swap(&b);
  }
  inline void Swap(ErnTestMessageType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErnTestMessageType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErnTestMessageType* New() const final {
    return CreateMaybeMessage<ErnTestMessageType>(nullptr);
  }

  ErnTestMessageType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErnTestMessageType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ErnTestMessageType& from);
  void MergeFrom(const ErnTestMessageType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErnTestMessageType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ErnTestMessageType";
  }
  protected:
  explicit ErnTestMessageType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ErnTestMessageType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ErncFileStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ErncFileStatus) */ {
 public:
  inline ErncFileStatus() : ErncFileStatus(nullptr) {}
  virtual ~ErncFileStatus();

  ErncFileStatus(const ErncFileStatus& from);
  ErncFileStatus(ErncFileStatus&& from) noexcept
    : ErncFileStatus() {
    *this = ::std::move(from);
  }

  inline ErncFileStatus& operator=(const ErncFileStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErncFileStatus& operator=(ErncFileStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ErncFileStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErncFileStatus* internal_default_instance() {
    return reinterpret_cast<const ErncFileStatus*>(
               &_ErncFileStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ErncFileStatus& a, ErncFileStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ErncFileStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErncFileStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErncFileStatus* New() const final {
    return CreateMaybeMessage<ErncFileStatus>(nullptr);
  }

  ErncFileStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErncFileStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ErncFileStatus& from);
  void MergeFrom(const ErncFileStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErncFileStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ErncFileStatus";
  }
  protected:
  explicit ErncFileStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ErncFileStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ErncProposedActionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ErncProposedActionType) */ {
 public:
  inline ErncProposedActionType() : ErncProposedActionType(nullptr) {}
  virtual ~ErncProposedActionType();

  ErncProposedActionType(const ErncProposedActionType& from);
  ErncProposedActionType(ErncProposedActionType&& from) noexcept
    : ErncProposedActionType() {
    *this = ::std::move(from);
  }

  inline ErncProposedActionType& operator=(const ErncProposedActionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErncProposedActionType& operator=(ErncProposedActionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ErncProposedActionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErncProposedActionType* internal_default_instance() {
    return reinterpret_cast<const ErncProposedActionType*>(
               &_ErncProposedActionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ErncProposedActionType& a, ErncProposedActionType& b) {
    a.Swap(&b);
  }
  inline void Swap(ErncProposedActionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErncProposedActionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErncProposedActionType* New() const final {
    return CreateMaybeMessage<ErncProposedActionType>(nullptr);
  }

  ErncProposedActionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErncProposedActionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ErncProposedActionType& from);
  void MergeFrom(const ErncProposedActionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErncProposedActionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ErncProposedActionType";
  }
  protected:
  explicit ErncProposedActionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ErncProposedActionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ErrorSeverity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ErrorSeverity) */ {
 public:
  inline ErrorSeverity() : ErrorSeverity(nullptr) {}
  virtual ~ErrorSeverity();

  ErrorSeverity(const ErrorSeverity& from);
  ErrorSeverity(ErrorSeverity&& from) noexcept
    : ErrorSeverity() {
    *this = ::std::move(from);
  }

  inline ErrorSeverity& operator=(const ErrorSeverity& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorSeverity& operator=(ErrorSeverity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ErrorSeverity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorSeverity* internal_default_instance() {
    return reinterpret_cast<const ErrorSeverity*>(
               &_ErrorSeverity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(ErrorSeverity& a, ErrorSeverity& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorSeverity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorSeverity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrorSeverity* New() const final {
    return CreateMaybeMessage<ErrorSeverity>(nullptr);
  }

  ErrorSeverity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrorSeverity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ErrorSeverity& from);
  void MergeFrom(const ErrorSeverity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorSeverity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ErrorSeverity";
  }
  protected:
  explicit ErrorSeverity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ErrorSeverity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ErrorType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ErrorType) */ {
 public:
  inline ErrorType() : ErrorType(nullptr) {}
  virtual ~ErrorType();

  ErrorType(const ErrorType& from);
  ErrorType(ErrorType&& from) noexcept
    : ErrorType() {
    *this = ::std::move(from);
  }

  inline ErrorType& operator=(const ErrorType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorType& operator=(ErrorType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ErrorType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorType* internal_default_instance() {
    return reinterpret_cast<const ErrorType*>(
               &_ErrorType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(ErrorType& a, ErrorType& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrorType* New() const final {
    return CreateMaybeMessage<ErrorType>(nullptr);
  }

  ErrorType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrorType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ErrorType& from);
  void MergeFrom(const ErrorType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ErrorType";
  }
  protected:
  explicit ErrorType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ErrorType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ExceptionReason PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ExceptionReason) */ {
 public:
  inline ExceptionReason() : ExceptionReason(nullptr) {}
  virtual ~ExceptionReason();

  ExceptionReason(const ExceptionReason& from);
  ExceptionReason(ExceptionReason&& from) noexcept
    : ExceptionReason() {
    *this = ::std::move(from);
  }

  inline ExceptionReason& operator=(const ExceptionReason& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExceptionReason& operator=(ExceptionReason&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExceptionReason& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExceptionReason* internal_default_instance() {
    return reinterpret_cast<const ExceptionReason*>(
               &_ExceptionReason_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(ExceptionReason& a, ExceptionReason& b) {
    a.Swap(&b);
  }
  inline void Swap(ExceptionReason* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExceptionReason* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExceptionReason* New() const final {
    return CreateMaybeMessage<ExceptionReason>(nullptr);
  }

  ExceptionReason* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExceptionReason>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExceptionReason& from);
  void MergeFrom(const ExceptionReason& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExceptionReason* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ExceptionReason";
  }
  protected:
  explicit ExceptionReason(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ExceptionReason)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ExpressionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ExpressionType) */ {
 public:
  inline ExpressionType() : ExpressionType(nullptr) {}
  virtual ~ExpressionType();

  ExpressionType(const ExpressionType& from);
  ExpressionType(ExpressionType&& from) noexcept
    : ExpressionType() {
    *this = ::std::move(from);
  }

  inline ExpressionType& operator=(const ExpressionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpressionType& operator=(ExpressionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExpressionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExpressionType* internal_default_instance() {
    return reinterpret_cast<const ExpressionType*>(
               &_ExpressionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(ExpressionType& a, ExpressionType& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpressionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpressionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExpressionType* New() const final {
    return CreateMaybeMessage<ExpressionType>(nullptr);
  }

  ExpressionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExpressionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExpressionType& from);
  void MergeFrom(const ExpressionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpressionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ExpressionType";
  }
  protected:
  explicit ExpressionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ExpressionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ExternallyLinkedResourceType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ExternallyLinkedResourceType) */ {
 public:
  inline ExternallyLinkedResourceType() : ExternallyLinkedResourceType(nullptr) {}
  virtual ~ExternallyLinkedResourceType();

  ExternallyLinkedResourceType(const ExternallyLinkedResourceType& from);
  ExternallyLinkedResourceType(ExternallyLinkedResourceType&& from) noexcept
    : ExternallyLinkedResourceType() {
    *this = ::std::move(from);
  }

  inline ExternallyLinkedResourceType& operator=(const ExternallyLinkedResourceType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternallyLinkedResourceType& operator=(ExternallyLinkedResourceType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExternallyLinkedResourceType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExternallyLinkedResourceType* internal_default_instance() {
    return reinterpret_cast<const ExternallyLinkedResourceType*>(
               &_ExternallyLinkedResourceType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(ExternallyLinkedResourceType& a, ExternallyLinkedResourceType& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternallyLinkedResourceType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternallyLinkedResourceType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExternallyLinkedResourceType* New() const final {
    return CreateMaybeMessage<ExternallyLinkedResourceType>(nullptr);
  }

  ExternallyLinkedResourceType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExternallyLinkedResourceType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExternallyLinkedResourceType& from);
  void MergeFrom(const ExternallyLinkedResourceType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternallyLinkedResourceType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ExternallyLinkedResourceType";
  }
  protected:
  explicit ExternallyLinkedResourceType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ExternallyLinkedResourceType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class FileType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.FileType) */ {
 public:
  inline FileType() : FileType(nullptr) {}
  virtual ~FileType();

  FileType(const FileType& from);
  FileType(FileType&& from) noexcept
    : FileType() {
    *this = ::std::move(from);
  }

  inline FileType& operator=(const FileType& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileType& operator=(FileType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileType* internal_default_instance() {
    return reinterpret_cast<const FileType*>(
               &_FileType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(FileType& a, FileType& b) {
    a.Swap(&b);
  }
  inline void Swap(FileType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileType* New() const final {
    return CreateMaybeMessage<FileType>(nullptr);
  }

  FileType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileType& from);
  void MergeFrom(const FileType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.FileType";
  }
  protected:
  explicit FileType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.FileType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class FingerprintAlgorithmType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.FingerprintAlgorithmType) */ {
 public:
  inline FingerprintAlgorithmType() : FingerprintAlgorithmType(nullptr) {}
  virtual ~FingerprintAlgorithmType();

  FingerprintAlgorithmType(const FingerprintAlgorithmType& from);
  FingerprintAlgorithmType(FingerprintAlgorithmType&& from) noexcept
    : FingerprintAlgorithmType() {
    *this = ::std::move(from);
  }

  inline FingerprintAlgorithmType& operator=(const FingerprintAlgorithmType& from) {
    CopyFrom(from);
    return *this;
  }
  inline FingerprintAlgorithmType& operator=(FingerprintAlgorithmType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FingerprintAlgorithmType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FingerprintAlgorithmType* internal_default_instance() {
    return reinterpret_cast<const FingerprintAlgorithmType*>(
               &_FingerprintAlgorithmType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(FingerprintAlgorithmType& a, FingerprintAlgorithmType& b) {
    a.Swap(&b);
  }
  inline void Swap(FingerprintAlgorithmType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FingerprintAlgorithmType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FingerprintAlgorithmType* New() const final {
    return CreateMaybeMessage<FingerprintAlgorithmType>(nullptr);
  }

  FingerprintAlgorithmType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FingerprintAlgorithmType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FingerprintAlgorithmType& from);
  void MergeFrom(const FingerprintAlgorithmType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FingerprintAlgorithmType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.FingerprintAlgorithmType";
  }
  protected:
  explicit FingerprintAlgorithmType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.FingerprintAlgorithmType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class Form PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.Form) */ {
 public:
  inline Form() : Form(nullptr) {}
  virtual ~Form();

  Form(const Form& from);
  Form(Form&& from) noexcept
    : Form() {
    *this = ::std::move(from);
  }

  inline Form& operator=(const Form& from) {
    CopyFrom(from);
    return *this;
  }
  inline Form& operator=(Form&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Form& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Form* internal_default_instance() {
    return reinterpret_cast<const Form*>(
               &_Form_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(Form& a, Form& b) {
    a.Swap(&b);
  }
  inline void Swap(Form* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Form* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Form* New() const final {
    return CreateMaybeMessage<Form>(nullptr);
  }

  Form* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Form>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Form& from);
  void MergeFrom(const Form& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Form* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.Form";
  }
  protected:
  explicit Form(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.Form)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class FrameRate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.FrameRate) */ {
 public:
  inline FrameRate() : FrameRate(nullptr) {}
  virtual ~FrameRate();

  FrameRate(const FrameRate& from);
  FrameRate(FrameRate&& from) noexcept
    : FrameRate() {
    *this = ::std::move(from);
  }

  inline FrameRate& operator=(const FrameRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameRate& operator=(FrameRate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FrameRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameRate* internal_default_instance() {
    return reinterpret_cast<const FrameRate*>(
               &_FrameRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(FrameRate& a, FrameRate& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameRate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameRate* New() const final {
    return CreateMaybeMessage<FrameRate>(nullptr);
  }

  FrameRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameRate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FrameRate& from);
  void MergeFrom(const FrameRate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.FrameRate";
  }
  protected:
  explicit FrameRate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.FrameRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class Gender PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.Gender) */ {
 public:
  inline Gender() : Gender(nullptr) {}
  virtual ~Gender();

  Gender(const Gender& from);
  Gender(Gender&& from) noexcept
    : Gender() {
    *this = ::std::move(from);
  }

  inline Gender& operator=(const Gender& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gender& operator=(Gender&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Gender& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Gender* internal_default_instance() {
    return reinterpret_cast<const Gender*>(
               &_Gender_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(Gender& a, Gender& b) {
    a.Swap(&b);
  }
  inline void Swap(Gender* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gender* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Gender* New() const final {
    return CreateMaybeMessage<Gender>(nullptr);
  }

  Gender* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Gender>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Gender& from);
  void MergeFrom(const Gender& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gender* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.Gender";
  }
  protected:
  explicit Gender(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.Gender)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class GoverningAgreementType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.GoverningAgreementType) */ {
 public:
  inline GoverningAgreementType() : GoverningAgreementType(nullptr) {}
  virtual ~GoverningAgreementType();

  GoverningAgreementType(const GoverningAgreementType& from);
  GoverningAgreementType(GoverningAgreementType&& from) noexcept
    : GoverningAgreementType() {
    *this = ::std::move(from);
  }

  inline GoverningAgreementType& operator=(const GoverningAgreementType& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoverningAgreementType& operator=(GoverningAgreementType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GoverningAgreementType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GoverningAgreementType* internal_default_instance() {
    return reinterpret_cast<const GoverningAgreementType*>(
               &_GoverningAgreementType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(GoverningAgreementType& a, GoverningAgreementType& b) {
    a.Swap(&b);
  }
  inline void Swap(GoverningAgreementType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoverningAgreementType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GoverningAgreementType* New() const final {
    return CreateMaybeMessage<GoverningAgreementType>(nullptr);
  }

  GoverningAgreementType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GoverningAgreementType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GoverningAgreementType& from);
  void MergeFrom(const GoverningAgreementType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GoverningAgreementType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.GoverningAgreementType";
  }
  protected:
  explicit GoverningAgreementType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.GoverningAgreementType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class HashSumAlgorithmType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.HashSumAlgorithmType) */ {
 public:
  inline HashSumAlgorithmType() : HashSumAlgorithmType(nullptr) {}
  virtual ~HashSumAlgorithmType();

  HashSumAlgorithmType(const HashSumAlgorithmType& from);
  HashSumAlgorithmType(HashSumAlgorithmType&& from) noexcept
    : HashSumAlgorithmType() {
    *this = ::std::move(from);
  }

  inline HashSumAlgorithmType& operator=(const HashSumAlgorithmType& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashSumAlgorithmType& operator=(HashSumAlgorithmType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HashSumAlgorithmType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HashSumAlgorithmType* internal_default_instance() {
    return reinterpret_cast<const HashSumAlgorithmType*>(
               &_HashSumAlgorithmType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(HashSumAlgorithmType& a, HashSumAlgorithmType& b) {
    a.Swap(&b);
  }
  inline void Swap(HashSumAlgorithmType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashSumAlgorithmType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HashSumAlgorithmType* New() const final {
    return CreateMaybeMessage<HashSumAlgorithmType>(nullptr);
  }

  HashSumAlgorithmType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HashSumAlgorithmType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HashSumAlgorithmType& from);
  void MergeFrom(const HashSumAlgorithmType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashSumAlgorithmType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.HashSumAlgorithmType";
  }
  protected:
  explicit HashSumAlgorithmType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.HashSumAlgorithmType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ImageCodecType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ImageCodecType) */ {
 public:
  inline ImageCodecType() : ImageCodecType(nullptr) {}
  virtual ~ImageCodecType();

  ImageCodecType(const ImageCodecType& from);
  ImageCodecType(ImageCodecType&& from) noexcept
    : ImageCodecType() {
    *this = ::std::move(from);
  }

  inline ImageCodecType& operator=(const ImageCodecType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageCodecType& operator=(ImageCodecType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageCodecType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageCodecType* internal_default_instance() {
    return reinterpret_cast<const ImageCodecType*>(
               &_ImageCodecType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(ImageCodecType& a, ImageCodecType& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageCodecType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageCodecType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageCodecType* New() const final {
    return CreateMaybeMessage<ImageCodecType>(nullptr);
  }

  ImageCodecType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageCodecType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageCodecType& from);
  void MergeFrom(const ImageCodecType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageCodecType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ImageCodecType";
  }
  protected:
  explicit ImageCodecType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ImageCodecType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ImageType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ImageType) */ {
 public:
  inline ImageType() : ImageType(nullptr) {}
  virtual ~ImageType();

  ImageType(const ImageType& from);
  ImageType(ImageType&& from) noexcept
    : ImageType() {
    *this = ::std::move(from);
  }

  inline ImageType& operator=(const ImageType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageType& operator=(ImageType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageType* internal_default_instance() {
    return reinterpret_cast<const ImageType*>(
               &_ImageType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(ImageType& a, ImageType& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageType* New() const final {
    return CreateMaybeMessage<ImageType>(nullptr);
  }

  ImageType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageType& from);
  void MergeFrom(const ImageType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ImageType";
  }
  protected:
  explicit ImageType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ImageType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class InstrumentType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.InstrumentType) */ {
 public:
  inline InstrumentType() : InstrumentType(nullptr) {}
  virtual ~InstrumentType();

  InstrumentType(const InstrumentType& from);
  InstrumentType(InstrumentType&& from) noexcept
    : InstrumentType() {
    *this = ::std::move(from);
  }

  inline InstrumentType& operator=(const InstrumentType& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentType& operator=(InstrumentType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InstrumentType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InstrumentType* internal_default_instance() {
    return reinterpret_cast<const InstrumentType*>(
               &_InstrumentType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(InstrumentType& a, InstrumentType& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstrumentType* New() const final {
    return CreateMaybeMessage<InstrumentType>(nullptr);
  }

  InstrumentType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstrumentType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InstrumentType& from);
  void MergeFrom(const InstrumentType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.InstrumentType";
  }
  protected:
  explicit InstrumentType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.InstrumentType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class Iso639Part12LanguageCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.Iso639Part12LanguageCode) */ {
 public:
  inline Iso639Part12LanguageCode() : Iso639Part12LanguageCode(nullptr) {}
  virtual ~Iso639Part12LanguageCode();

  Iso639Part12LanguageCode(const Iso639Part12LanguageCode& from);
  Iso639Part12LanguageCode(Iso639Part12LanguageCode&& from) noexcept
    : Iso639Part12LanguageCode() {
    *this = ::std::move(from);
  }

  inline Iso639Part12LanguageCode& operator=(const Iso639Part12LanguageCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Iso639Part12LanguageCode& operator=(Iso639Part12LanguageCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Iso639Part12LanguageCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Iso639Part12LanguageCode* internal_default_instance() {
    return reinterpret_cast<const Iso639Part12LanguageCode*>(
               &_Iso639Part12LanguageCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(Iso639Part12LanguageCode& a, Iso639Part12LanguageCode& b) {
    a.Swap(&b);
  }
  inline void Swap(Iso639Part12LanguageCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Iso639Part12LanguageCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Iso639Part12LanguageCode* New() const final {
    return CreateMaybeMessage<Iso639Part12LanguageCode>(nullptr);
  }

  Iso639Part12LanguageCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Iso639Part12LanguageCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Iso639Part12LanguageCode& from);
  void MergeFrom(const Iso639Part12LanguageCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Iso639Part12LanguageCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.Iso639Part12LanguageCode";
  }
  protected:
  explicit Iso639Part12LanguageCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.Iso639Part12LanguageCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class Iso639Part3LanguageCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.Iso639Part3LanguageCode) */ {
 public:
  inline Iso639Part3LanguageCode() : Iso639Part3LanguageCode(nullptr) {}
  virtual ~Iso639Part3LanguageCode();

  Iso639Part3LanguageCode(const Iso639Part3LanguageCode& from);
  Iso639Part3LanguageCode(Iso639Part3LanguageCode&& from) noexcept
    : Iso639Part3LanguageCode() {
    *this = ::std::move(from);
  }

  inline Iso639Part3LanguageCode& operator=(const Iso639Part3LanguageCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Iso639Part3LanguageCode& operator=(Iso639Part3LanguageCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Iso639Part3LanguageCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Iso639Part3LanguageCode* internal_default_instance() {
    return reinterpret_cast<const Iso639Part3LanguageCode*>(
               &_Iso639Part3LanguageCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(Iso639Part3LanguageCode& a, Iso639Part3LanguageCode& b) {
    a.Swap(&b);
  }
  inline void Swap(Iso639Part3LanguageCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Iso639Part3LanguageCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Iso639Part3LanguageCode* New() const final {
    return CreateMaybeMessage<Iso639Part3LanguageCode>(nullptr);
  }

  Iso639Part3LanguageCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Iso639Part3LanguageCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Iso639Part3LanguageCode& from);
  void MergeFrom(const Iso639Part3LanguageCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Iso639Part3LanguageCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.Iso639Part3LanguageCode";
  }
  protected:
  explicit Iso639Part3LanguageCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.Iso639Part3LanguageCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class IsoCurrencyCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.IsoCurrencyCode) */ {
 public:
  inline IsoCurrencyCode() : IsoCurrencyCode(nullptr) {}
  virtual ~IsoCurrencyCode();

  IsoCurrencyCode(const IsoCurrencyCode& from);
  IsoCurrencyCode(IsoCurrencyCode&& from) noexcept
    : IsoCurrencyCode() {
    *this = ::std::move(from);
  }

  inline IsoCurrencyCode& operator=(const IsoCurrencyCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsoCurrencyCode& operator=(IsoCurrencyCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IsoCurrencyCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsoCurrencyCode* internal_default_instance() {
    return reinterpret_cast<const IsoCurrencyCode*>(
               &_IsoCurrencyCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(IsoCurrencyCode& a, IsoCurrencyCode& b) {
    a.Swap(&b);
  }
  inline void Swap(IsoCurrencyCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsoCurrencyCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IsoCurrencyCode* New() const final {
    return CreateMaybeMessage<IsoCurrencyCode>(nullptr);
  }

  IsoCurrencyCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IsoCurrencyCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IsoCurrencyCode& from);
  void MergeFrom(const IsoCurrencyCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsoCurrencyCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.IsoCurrencyCode";
  }
  protected:
  explicit IsoCurrencyCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.IsoCurrencyCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class IsoLanguageCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.IsoLanguageCode) */ {
 public:
  inline IsoLanguageCode() : IsoLanguageCode(nullptr) {}
  virtual ~IsoLanguageCode();

  IsoLanguageCode(const IsoLanguageCode& from);
  IsoLanguageCode(IsoLanguageCode&& from) noexcept
    : IsoLanguageCode() {
    *this = ::std::move(from);
  }

  inline IsoLanguageCode& operator=(const IsoLanguageCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsoLanguageCode& operator=(IsoLanguageCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IsoLanguageCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsoLanguageCode* internal_default_instance() {
    return reinterpret_cast<const IsoLanguageCode*>(
               &_IsoLanguageCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(IsoLanguageCode& a, IsoLanguageCode& b) {
    a.Swap(&b);
  }
  inline void Swap(IsoLanguageCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsoLanguageCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IsoLanguageCode* New() const final {
    return CreateMaybeMessage<IsoLanguageCode>(nullptr);
  }

  IsoLanguageCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IsoLanguageCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IsoLanguageCode& from);
  void MergeFrom(const IsoLanguageCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsoLanguageCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.IsoLanguageCode";
  }
  protected:
  explicit IsoLanguageCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.IsoLanguageCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class IsoTerritoryCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.IsoTerritoryCode) */ {
 public:
  inline IsoTerritoryCode() : IsoTerritoryCode(nullptr) {}
  virtual ~IsoTerritoryCode();

  IsoTerritoryCode(const IsoTerritoryCode& from);
  IsoTerritoryCode(IsoTerritoryCode&& from) noexcept
    : IsoTerritoryCode() {
    *this = ::std::move(from);
  }

  inline IsoTerritoryCode& operator=(const IsoTerritoryCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsoTerritoryCode& operator=(IsoTerritoryCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IsoTerritoryCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsoTerritoryCode* internal_default_instance() {
    return reinterpret_cast<const IsoTerritoryCode*>(
               &_IsoTerritoryCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(IsoTerritoryCode& a, IsoTerritoryCode& b) {
    a.Swap(&b);
  }
  inline void Swap(IsoTerritoryCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsoTerritoryCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IsoTerritoryCode* New() const final {
    return CreateMaybeMessage<IsoTerritoryCode>(nullptr);
  }

  IsoTerritoryCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IsoTerritoryCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IsoTerritoryCode& from);
  void MergeFrom(const IsoTerritoryCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsoTerritoryCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.IsoTerritoryCode";
  }
  protected:
  explicit IsoTerritoryCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.IsoTerritoryCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class LabelNameType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.LabelNameType) */ {
 public:
  inline LabelNameType() : LabelNameType(nullptr) {}
  virtual ~LabelNameType();

  LabelNameType(const LabelNameType& from);
  LabelNameType(LabelNameType&& from) noexcept
    : LabelNameType() {
    *this = ::std::move(from);
  }

  inline LabelNameType& operator=(const LabelNameType& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelNameType& operator=(LabelNameType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LabelNameType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LabelNameType* internal_default_instance() {
    return reinterpret_cast<const LabelNameType*>(
               &_LabelNameType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(LabelNameType& a, LabelNameType& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelNameType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelNameType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LabelNameType* New() const final {
    return CreateMaybeMessage<LabelNameType>(nullptr);
  }

  LabelNameType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LabelNameType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LabelNameType& from);
  void MergeFrom(const LabelNameType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelNameType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.LabelNameType";
  }
  protected:
  explicit LabelNameType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.LabelNameType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class LabelType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.LabelType) */ {
 public:
  inline LabelType() : LabelType(nullptr) {}
  virtual ~LabelType();

  LabelType(const LabelType& from);
  LabelType(LabelType&& from) noexcept
    : LabelType() {
    *this = ::std::move(from);
  }

  inline LabelType& operator=(const LabelType& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelType& operator=(LabelType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LabelType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LabelType* internal_default_instance() {
    return reinterpret_cast<const LabelType*>(
               &_LabelType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(LabelType& a, LabelType& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LabelType* New() const final {
    return CreateMaybeMessage<LabelType>(nullptr);
  }

  LabelType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LabelType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LabelType& from);
  void MergeFrom(const LabelType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.LabelType";
  }
  protected:
  explicit LabelType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.LabelType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class LanguageLocalizationType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.LanguageLocalizationType) */ {
 public:
  inline LanguageLocalizationType() : LanguageLocalizationType(nullptr) {}
  virtual ~LanguageLocalizationType();

  LanguageLocalizationType(const LanguageLocalizationType& from);
  LanguageLocalizationType(LanguageLocalizationType&& from) noexcept
    : LanguageLocalizationType() {
    *this = ::std::move(from);
  }

  inline LanguageLocalizationType& operator=(const LanguageLocalizationType& from) {
    CopyFrom(from);
    return *this;
  }
  inline LanguageLocalizationType& operator=(LanguageLocalizationType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LanguageLocalizationType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LanguageLocalizationType* internal_default_instance() {
    return reinterpret_cast<const LanguageLocalizationType*>(
               &_LanguageLocalizationType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(LanguageLocalizationType& a, LanguageLocalizationType& b) {
    a.Swap(&b);
  }
  inline void Swap(LanguageLocalizationType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LanguageLocalizationType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LanguageLocalizationType* New() const final {
    return CreateMaybeMessage<LanguageLocalizationType>(nullptr);
  }

  LanguageLocalizationType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LanguageLocalizationType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LanguageLocalizationType& from);
  void MergeFrom(const LanguageLocalizationType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LanguageLocalizationType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.LanguageLocalizationType";
  }
  protected:
  explicit LanguageLocalizationType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.LanguageLocalizationType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class LicenseRecord PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.LicenseRecord) */ {
 public:
  inline LicenseRecord() : LicenseRecord(nullptr) {}
  virtual ~LicenseRecord();

  LicenseRecord(const LicenseRecord& from);
  LicenseRecord(LicenseRecord&& from) noexcept
    : LicenseRecord() {
    *this = ::std::move(from);
  }

  inline LicenseRecord& operator=(const LicenseRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline LicenseRecord& operator=(LicenseRecord&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LicenseRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LicenseRecord* internal_default_instance() {
    return reinterpret_cast<const LicenseRecord*>(
               &_LicenseRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(LicenseRecord& a, LicenseRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(LicenseRecord* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LicenseRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LicenseRecord* New() const final {
    return CreateMaybeMessage<LicenseRecord>(nullptr);
  }

  LicenseRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LicenseRecord>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LicenseRecord& from);
  void MergeFrom(const LicenseRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LicenseRecord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.LicenseRecord";
  }
  protected:
  explicit LicenseRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.LicenseRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class LicenseRefusalReason PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.LicenseRefusalReason) */ {
 public:
  inline LicenseRefusalReason() : LicenseRefusalReason(nullptr) {}
  virtual ~LicenseRefusalReason();

  LicenseRefusalReason(const LicenseRefusalReason& from);
  LicenseRefusalReason(LicenseRefusalReason&& from) noexcept
    : LicenseRefusalReason() {
    *this = ::std::move(from);
  }

  inline LicenseRefusalReason& operator=(const LicenseRefusalReason& from) {
    CopyFrom(from);
    return *this;
  }
  inline LicenseRefusalReason& operator=(LicenseRefusalReason&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LicenseRefusalReason& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LicenseRefusalReason* internal_default_instance() {
    return reinterpret_cast<const LicenseRefusalReason*>(
               &_LicenseRefusalReason_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(LicenseRefusalReason& a, LicenseRefusalReason& b) {
    a.Swap(&b);
  }
  inline void Swap(LicenseRefusalReason* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LicenseRefusalReason* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LicenseRefusalReason* New() const final {
    return CreateMaybeMessage<LicenseRefusalReason>(nullptr);
  }

  LicenseRefusalReason* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LicenseRefusalReason>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LicenseRefusalReason& from);
  void MergeFrom(const LicenseRefusalReason& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LicenseRefusalReason* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.LicenseRefusalReason";
  }
  protected:
  explicit LicenseRefusalReason(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.LicenseRefusalReason)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class LicenseRejectionReason PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.LicenseRejectionReason) */ {
 public:
  inline LicenseRejectionReason() : LicenseRejectionReason(nullptr) {}
  virtual ~LicenseRejectionReason();

  LicenseRejectionReason(const LicenseRejectionReason& from);
  LicenseRejectionReason(LicenseRejectionReason&& from) noexcept
    : LicenseRejectionReason() {
    *this = ::std::move(from);
  }

  inline LicenseRejectionReason& operator=(const LicenseRejectionReason& from) {
    CopyFrom(from);
    return *this;
  }
  inline LicenseRejectionReason& operator=(LicenseRejectionReason&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LicenseRejectionReason& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LicenseRejectionReason* internal_default_instance() {
    return reinterpret_cast<const LicenseRejectionReason*>(
               &_LicenseRejectionReason_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(LicenseRejectionReason& a, LicenseRejectionReason& b) {
    a.Swap(&b);
  }
  inline void Swap(LicenseRejectionReason* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LicenseRejectionReason* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LicenseRejectionReason* New() const final {
    return CreateMaybeMessage<LicenseRejectionReason>(nullptr);
  }

  LicenseRejectionReason* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LicenseRejectionReason>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LicenseRejectionReason& from);
  void MergeFrom(const LicenseRejectionReason& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LicenseRejectionReason* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.LicenseRejectionReason";
  }
  protected:
  explicit LicenseRejectionReason(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.LicenseRejectionReason)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class LinkAcknowledgementStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.LinkAcknowledgementStatus) */ {
 public:
  inline LinkAcknowledgementStatus() : LinkAcknowledgementStatus(nullptr) {}
  virtual ~LinkAcknowledgementStatus();

  LinkAcknowledgementStatus(const LinkAcknowledgementStatus& from);
  LinkAcknowledgementStatus(LinkAcknowledgementStatus&& from) noexcept
    : LinkAcknowledgementStatus() {
    *this = ::std::move(from);
  }

  inline LinkAcknowledgementStatus& operator=(const LinkAcknowledgementStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinkAcknowledgementStatus& operator=(LinkAcknowledgementStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LinkAcknowledgementStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinkAcknowledgementStatus* internal_default_instance() {
    return reinterpret_cast<const LinkAcknowledgementStatus*>(
               &_LinkAcknowledgementStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(LinkAcknowledgementStatus& a, LinkAcknowledgementStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(LinkAcknowledgementStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinkAcknowledgementStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LinkAcknowledgementStatus* New() const final {
    return CreateMaybeMessage<LinkAcknowledgementStatus>(nullptr);
  }

  LinkAcknowledgementStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LinkAcknowledgementStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LinkAcknowledgementStatus& from);
  void MergeFrom(const LinkAcknowledgementStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkAcknowledgementStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.LinkAcknowledgementStatus";
  }
  protected:
  explicit LinkAcknowledgementStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.LinkAcknowledgementStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class LinkDescription PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.LinkDescription) */ {
 public:
  inline LinkDescription() : LinkDescription(nullptr) {}
  virtual ~LinkDescription();

  LinkDescription(const LinkDescription& from);
  LinkDescription(LinkDescription&& from) noexcept
    : LinkDescription() {
    *this = ::std::move(from);
  }

  inline LinkDescription& operator=(const LinkDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinkDescription& operator=(LinkDescription&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LinkDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinkDescription* internal_default_instance() {
    return reinterpret_cast<const LinkDescription*>(
               &_LinkDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(LinkDescription& a, LinkDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(LinkDescription* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinkDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LinkDescription* New() const final {
    return CreateMaybeMessage<LinkDescription>(nullptr);
  }

  LinkDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LinkDescription>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LinkDescription& from);
  void MergeFrom(const LinkDescription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkDescription* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.LinkDescription";
  }
  protected:
  explicit LinkDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.LinkDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class LyricsType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.LyricsType) */ {
 public:
  inline LyricsType() : LyricsType(nullptr) {}
  virtual ~LyricsType();

  LyricsType(const LyricsType& from);
  LyricsType(LyricsType&& from) noexcept
    : LyricsType() {
    *this = ::std::move(from);
  }

  inline LyricsType& operator=(const LyricsType& from) {
    CopyFrom(from);
    return *this;
  }
  inline LyricsType& operator=(LyricsType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LyricsType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LyricsType* internal_default_instance() {
    return reinterpret_cast<const LyricsType*>(
               &_LyricsType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(LyricsType& a, LyricsType& b) {
    a.Swap(&b);
  }
  inline void Swap(LyricsType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LyricsType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LyricsType* New() const final {
    return CreateMaybeMessage<LyricsType>(nullptr);
  }

  LyricsType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LyricsType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LyricsType& from);
  void MergeFrom(const LyricsType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LyricsType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.LyricsType";
  }
  protected:
  explicit LyricsType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.LyricsType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MembershipType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MembershipType) */ {
 public:
  inline MembershipType() : MembershipType(nullptr) {}
  virtual ~MembershipType();

  MembershipType(const MembershipType& from);
  MembershipType(MembershipType&& from) noexcept
    : MembershipType() {
    *this = ::std::move(from);
  }

  inline MembershipType& operator=(const MembershipType& from) {
    CopyFrom(from);
    return *this;
  }
  inline MembershipType& operator=(MembershipType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MembershipType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MembershipType* internal_default_instance() {
    return reinterpret_cast<const MembershipType*>(
               &_MembershipType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(MembershipType& a, MembershipType& b) {
    a.Swap(&b);
  }
  inline void Swap(MembershipType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MembershipType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MembershipType* New() const final {
    return CreateMaybeMessage<MembershipType>(nullptr);
  }

  MembershipType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MembershipType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MembershipType& from);
  void MergeFrom(const MembershipType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MembershipType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MembershipType";
  }
  protected:
  explicit MembershipType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MembershipType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MessageActionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MessageActionType) */ {
 public:
  inline MessageActionType() : MessageActionType(nullptr) {}
  virtual ~MessageActionType();

  MessageActionType(const MessageActionType& from);
  MessageActionType(MessageActionType&& from) noexcept
    : MessageActionType() {
    *this = ::std::move(from);
  }

  inline MessageActionType& operator=(const MessageActionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageActionType& operator=(MessageActionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessageActionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageActionType* internal_default_instance() {
    return reinterpret_cast<const MessageActionType*>(
               &_MessageActionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(MessageActionType& a, MessageActionType& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageActionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageActionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageActionType* New() const final {
    return CreateMaybeMessage<MessageActionType>(nullptr);
  }

  MessageActionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageActionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessageActionType& from);
  void MergeFrom(const MessageActionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageActionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MessageActionType";
  }
  protected:
  explicit MessageActionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MessageActionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MessageControlType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MessageControlType) */ {
 public:
  inline MessageControlType() : MessageControlType(nullptr) {}
  virtual ~MessageControlType();

  MessageControlType(const MessageControlType& from);
  MessageControlType(MessageControlType&& from) noexcept
    : MessageControlType() {
    *this = ::std::move(from);
  }

  inline MessageControlType& operator=(const MessageControlType& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageControlType& operator=(MessageControlType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessageControlType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageControlType* internal_default_instance() {
    return reinterpret_cast<const MessageControlType*>(
               &_MessageControlType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(MessageControlType& a, MessageControlType& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageControlType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageControlType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageControlType* New() const final {
    return CreateMaybeMessage<MessageControlType>(nullptr);
  }

  MessageControlType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageControlType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessageControlType& from);
  void MergeFrom(const MessageControlType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageControlType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MessageControlType";
  }
  protected:
  explicit MessageControlType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MessageControlType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MessagePurpose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MessagePurpose) */ {
 public:
  inline MessagePurpose() : MessagePurpose(nullptr) {}
  virtual ~MessagePurpose();

  MessagePurpose(const MessagePurpose& from);
  MessagePurpose(MessagePurpose&& from) noexcept
    : MessagePurpose() {
    *this = ::std::move(from);
  }

  inline MessagePurpose& operator=(const MessagePurpose& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessagePurpose& operator=(MessagePurpose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessagePurpose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessagePurpose* internal_default_instance() {
    return reinterpret_cast<const MessagePurpose*>(
               &_MessagePurpose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(MessagePurpose& a, MessagePurpose& b) {
    a.Swap(&b);
  }
  inline void Swap(MessagePurpose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessagePurpose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessagePurpose* New() const final {
    return CreateMaybeMessage<MessagePurpose>(nullptr);
  }

  MessagePurpose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessagePurpose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessagePurpose& from);
  void MergeFrom(const MessagePurpose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessagePurpose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MessagePurpose";
  }
  protected:
  explicit MessagePurpose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MessagePurpose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MessageType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MessageType) */ {
 public:
  inline MessageType() : MessageType(nullptr) {}
  virtual ~MessageType();

  MessageType(const MessageType& from);
  MessageType(MessageType&& from) noexcept
    : MessageType() {
    *this = ::std::move(from);
  }

  inline MessageType& operator=(const MessageType& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageType& operator=(MessageType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessageType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageType* internal_default_instance() {
    return reinterpret_cast<const MessageType*>(
               &_MessageType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(MessageType& a, MessageType& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageType* New() const final {
    return CreateMaybeMessage<MessageType>(nullptr);
  }

  MessageType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessageType& from);
  void MergeFrom(const MessageType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MessageType";
  }
  protected:
  explicit MessageType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MessageType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MetadataSourceType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MetadataSourceType) */ {
 public:
  inline MetadataSourceType() : MetadataSourceType(nullptr) {}
  virtual ~MetadataSourceType();

  MetadataSourceType(const MetadataSourceType& from);
  MetadataSourceType(MetadataSourceType&& from) noexcept
    : MetadataSourceType() {
    *this = ::std::move(from);
  }

  inline MetadataSourceType& operator=(const MetadataSourceType& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetadataSourceType& operator=(MetadataSourceType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MetadataSourceType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MetadataSourceType* internal_default_instance() {
    return reinterpret_cast<const MetadataSourceType*>(
               &_MetadataSourceType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(MetadataSourceType& a, MetadataSourceType& b) {
    a.Swap(&b);
  }
  inline void Swap(MetadataSourceType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetadataSourceType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MetadataSourceType* New() const final {
    return CreateMaybeMessage<MetadataSourceType>(nullptr);
  }

  MetadataSourceType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MetadataSourceType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MetadataSourceType& from);
  void MergeFrom(const MetadataSourceType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetadataSourceType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MetadataSourceType";
  }
  protected:
  explicit MetadataSourceType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MetadataSourceType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MissingLinkReason PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MissingLinkReason) */ {
 public:
  inline MissingLinkReason() : MissingLinkReason(nullptr) {}
  virtual ~MissingLinkReason();

  MissingLinkReason(const MissingLinkReason& from);
  MissingLinkReason(MissingLinkReason&& from) noexcept
    : MissingLinkReason() {
    *this = ::std::move(from);
  }

  inline MissingLinkReason& operator=(const MissingLinkReason& from) {
    CopyFrom(from);
    return *this;
  }
  inline MissingLinkReason& operator=(MissingLinkReason&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MissingLinkReason& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MissingLinkReason* internal_default_instance() {
    return reinterpret_cast<const MissingLinkReason*>(
               &_MissingLinkReason_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(MissingLinkReason& a, MissingLinkReason& b) {
    a.Swap(&b);
  }
  inline void Swap(MissingLinkReason* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MissingLinkReason* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MissingLinkReason* New() const final {
    return CreateMaybeMessage<MissingLinkReason>(nullptr);
  }

  MissingLinkReason* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MissingLinkReason>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MissingLinkReason& from);
  void MergeFrom(const MissingLinkReason& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MissingLinkReason* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MissingLinkReason";
  }
  protected:
  explicit MissingLinkReason(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MissingLinkReason)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MlcMessageType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MlcMessageType) */ {
 public:
  inline MlcMessageType() : MlcMessageType(nullptr) {}
  virtual ~MlcMessageType();

  MlcMessageType(const MlcMessageType& from);
  MlcMessageType(MlcMessageType&& from) noexcept
    : MlcMessageType() {
    *this = ::std::move(from);
  }

  inline MlcMessageType& operator=(const MlcMessageType& from) {
    CopyFrom(from);
    return *this;
  }
  inline MlcMessageType& operator=(MlcMessageType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MlcMessageType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MlcMessageType* internal_default_instance() {
    return reinterpret_cast<const MlcMessageType*>(
               &_MlcMessageType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(MlcMessageType& a, MlcMessageType& b) {
    a.Swap(&b);
  }
  inline void Swap(MlcMessageType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MlcMessageType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MlcMessageType* New() const final {
    return CreateMaybeMessage<MlcMessageType>(nullptr);
  }

  MlcMessageType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MlcMessageType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MlcMessageType& from);
  void MergeFrom(const MlcMessageType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlcMessageType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MlcMessageType";
  }
  protected:
  explicit MlcMessageType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MlcMessageType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class Mode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.Mode) */ {
 public:
  inline Mode() : Mode(nullptr) {}
  virtual ~Mode();

  Mode(const Mode& from);
  Mode(Mode&& from) noexcept
    : Mode() {
    *this = ::std::move(from);
  }

  inline Mode& operator=(const Mode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mode& operator=(Mode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Mode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mode* internal_default_instance() {
    return reinterpret_cast<const Mode*>(
               &_Mode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(Mode& a, Mode& b) {
    a.Swap(&b);
  }
  inline void Swap(Mode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Mode* New() const final {
    return CreateMaybeMessage<Mode>(nullptr);
  }

  Mode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Mode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Mode& from);
  void MergeFrom(const Mode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.Mode";
  }
  protected:
  explicit Mode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.Mode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MoodType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MoodType) */ {
 public:
  inline MoodType() : MoodType(nullptr) {}
  virtual ~MoodType();

  MoodType(const MoodType& from);
  MoodType(MoodType&& from) noexcept
    : MoodType() {
    *this = ::std::move(from);
  }

  inline MoodType& operator=(const MoodType& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoodType& operator=(MoodType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoodType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoodType* internal_default_instance() {
    return reinterpret_cast<const MoodType*>(
               &_MoodType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(MoodType& a, MoodType& b) {
    a.Swap(&b);
  }
  inline void Swap(MoodType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoodType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoodType* New() const final {
    return CreateMaybeMessage<MoodType>(nullptr);
  }

  MoodType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoodType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoodType& from);
  void MergeFrom(const MoodType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoodType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MoodType";
  }
  protected:
  explicit MoodType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MoodType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MusicalWorkContributorRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MusicalWorkContributorRole) */ {
 public:
  inline MusicalWorkContributorRole() : MusicalWorkContributorRole(nullptr) {}
  virtual ~MusicalWorkContributorRole();

  MusicalWorkContributorRole(const MusicalWorkContributorRole& from);
  MusicalWorkContributorRole(MusicalWorkContributorRole&& from) noexcept
    : MusicalWorkContributorRole() {
    *this = ::std::move(from);
  }

  inline MusicalWorkContributorRole& operator=(const MusicalWorkContributorRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline MusicalWorkContributorRole& operator=(MusicalWorkContributorRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MusicalWorkContributorRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MusicalWorkContributorRole* internal_default_instance() {
    return reinterpret_cast<const MusicalWorkContributorRole*>(
               &_MusicalWorkContributorRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(MusicalWorkContributorRole& a, MusicalWorkContributorRole& b) {
    a.Swap(&b);
  }
  inline void Swap(MusicalWorkContributorRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MusicalWorkContributorRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MusicalWorkContributorRole* New() const final {
    return CreateMaybeMessage<MusicalWorkContributorRole>(nullptr);
  }

  MusicalWorkContributorRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MusicalWorkContributorRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MusicalWorkContributorRole& from);
  void MergeFrom(const MusicalWorkContributorRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MusicalWorkContributorRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MusicalWorkContributorRole";
  }
  protected:
  explicit MusicalWorkContributorRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MusicalWorkContributorRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MusicalWorkType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MusicalWorkType) */ {
 public:
  inline MusicalWorkType() : MusicalWorkType(nullptr) {}
  virtual ~MusicalWorkType();

  MusicalWorkType(const MusicalWorkType& from);
  MusicalWorkType(MusicalWorkType&& from) noexcept
    : MusicalWorkType() {
    *this = ::std::move(from);
  }

  inline MusicalWorkType& operator=(const MusicalWorkType& from) {
    CopyFrom(from);
    return *this;
  }
  inline MusicalWorkType& operator=(MusicalWorkType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MusicalWorkType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MusicalWorkType* internal_default_instance() {
    return reinterpret_cast<const MusicalWorkType*>(
               &_MusicalWorkType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(MusicalWorkType& a, MusicalWorkType& b) {
    a.Swap(&b);
  }
  inline void Swap(MusicalWorkType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MusicalWorkType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MusicalWorkType* New() const final {
    return CreateMaybeMessage<MusicalWorkType>(nullptr);
  }

  MusicalWorkType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MusicalWorkType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MusicalWorkType& from);
  void MergeFrom(const MusicalWorkType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MusicalWorkType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MusicalWorkType";
  }
  protected:
  explicit MusicalWorkType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MusicalWorkType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MwnlFileStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MwnlFileStatus) */ {
 public:
  inline MwnlFileStatus() : MwnlFileStatus(nullptr) {}
  virtual ~MwnlFileStatus();

  MwnlFileStatus(const MwnlFileStatus& from);
  MwnlFileStatus(MwnlFileStatus&& from) noexcept
    : MwnlFileStatus() {
    *this = ::std::move(from);
  }

  inline MwnlFileStatus& operator=(const MwnlFileStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline MwnlFileStatus& operator=(MwnlFileStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MwnlFileStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MwnlFileStatus* internal_default_instance() {
    return reinterpret_cast<const MwnlFileStatus*>(
               &_MwnlFileStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(MwnlFileStatus& a, MwnlFileStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(MwnlFileStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MwnlFileStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MwnlFileStatus* New() const final {
    return CreateMaybeMessage<MwnlFileStatus>(nullptr);
  }

  MwnlFileStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MwnlFileStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MwnlFileStatus& from);
  void MergeFrom(const MwnlFileStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MwnlFileStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MwnlFileStatus";
  }
  protected:
  explicit MwnlFileStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MwnlFileStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class MwnlProposedActionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.MwnlProposedActionType) */ {
 public:
  inline MwnlProposedActionType() : MwnlProposedActionType(nullptr) {}
  virtual ~MwnlProposedActionType();

  MwnlProposedActionType(const MwnlProposedActionType& from);
  MwnlProposedActionType(MwnlProposedActionType&& from) noexcept
    : MwnlProposedActionType() {
    *this = ::std::move(from);
  }

  inline MwnlProposedActionType& operator=(const MwnlProposedActionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline MwnlProposedActionType& operator=(MwnlProposedActionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MwnlProposedActionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MwnlProposedActionType* internal_default_instance() {
    return reinterpret_cast<const MwnlProposedActionType*>(
               &_MwnlProposedActionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(MwnlProposedActionType& a, MwnlProposedActionType& b) {
    a.Swap(&b);
  }
  inline void Swap(MwnlProposedActionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MwnlProposedActionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MwnlProposedActionType* New() const final {
    return CreateMaybeMessage<MwnlProposedActionType>(nullptr);
  }

  MwnlProposedActionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MwnlProposedActionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MwnlProposedActionType& from);
  void MergeFrom(const MwnlProposedActionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MwnlProposedActionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.MwnlProposedActionType";
  }
  protected:
  explicit MwnlProposedActionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.MwnlProposedActionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class NewStudioRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.NewStudioRole) */ {
 public:
  inline NewStudioRole() : NewStudioRole(nullptr) {}
  virtual ~NewStudioRole();

  NewStudioRole(const NewStudioRole& from);
  NewStudioRole(NewStudioRole&& from) noexcept
    : NewStudioRole() {
    *this = ::std::move(from);
  }

  inline NewStudioRole& operator=(const NewStudioRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewStudioRole& operator=(NewStudioRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewStudioRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewStudioRole* internal_default_instance() {
    return reinterpret_cast<const NewStudioRole*>(
               &_NewStudioRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(NewStudioRole& a, NewStudioRole& b) {
    a.Swap(&b);
  }
  inline void Swap(NewStudioRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewStudioRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewStudioRole* New() const final {
    return CreateMaybeMessage<NewStudioRole>(nullptr);
  }

  NewStudioRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewStudioRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewStudioRole& from);
  void MergeFrom(const NewStudioRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewStudioRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.NewStudioRole";
  }
  protected:
  explicit NewStudioRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.NewStudioRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class OperatingSystemType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.OperatingSystemType) */ {
 public:
  inline OperatingSystemType() : OperatingSystemType(nullptr) {}
  virtual ~OperatingSystemType();

  OperatingSystemType(const OperatingSystemType& from);
  OperatingSystemType(OperatingSystemType&& from) noexcept
    : OperatingSystemType() {
    *this = ::std::move(from);
  }

  inline OperatingSystemType& operator=(const OperatingSystemType& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperatingSystemType& operator=(OperatingSystemType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OperatingSystemType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperatingSystemType* internal_default_instance() {
    return reinterpret_cast<const OperatingSystemType*>(
               &_OperatingSystemType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(OperatingSystemType& a, OperatingSystemType& b) {
    a.Swap(&b);
  }
  inline void Swap(OperatingSystemType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperatingSystemType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OperatingSystemType* New() const final {
    return CreateMaybeMessage<OperatingSystemType>(nullptr);
  }

  OperatingSystemType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OperatingSystemType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OperatingSystemType& from);
  void MergeFrom(const OperatingSystemType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperatingSystemType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.OperatingSystemType";
  }
  protected:
  explicit OperatingSystemType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.OperatingSystemType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class PLineType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.PLineType) */ {
 public:
  inline PLineType() : PLineType(nullptr) {}
  virtual ~PLineType();

  PLineType(const PLineType& from);
  PLineType(PLineType&& from) noexcept
    : PLineType() {
    *this = ::std::move(from);
  }

  inline PLineType& operator=(const PLineType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PLineType& operator=(PLineType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PLineType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PLineType* internal_default_instance() {
    return reinterpret_cast<const PLineType*>(
               &_PLineType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(PLineType& a, PLineType& b) {
    a.Swap(&b);
  }
  inline void Swap(PLineType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PLineType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PLineType* New() const final {
    return CreateMaybeMessage<PLineType>(nullptr);
  }

  PLineType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PLineType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PLineType& from);
  void MergeFrom(const PLineType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PLineType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.PLineType";
  }
  protected:
  explicit PLineType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.PLineType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ParentalWarningType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ParentalWarningType) */ {
 public:
  inline ParentalWarningType() : ParentalWarningType(nullptr) {}
  virtual ~ParentalWarningType();

  ParentalWarningType(const ParentalWarningType& from);
  ParentalWarningType(ParentalWarningType&& from) noexcept
    : ParentalWarningType() {
    *this = ::std::move(from);
  }

  inline ParentalWarningType& operator=(const ParentalWarningType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParentalWarningType& operator=(ParentalWarningType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ParentalWarningType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParentalWarningType* internal_default_instance() {
    return reinterpret_cast<const ParentalWarningType*>(
               &_ParentalWarningType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(ParentalWarningType& a, ParentalWarningType& b) {
    a.Swap(&b);
  }
  inline void Swap(ParentalWarningType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParentalWarningType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ParentalWarningType* New() const final {
    return CreateMaybeMessage<ParentalWarningType>(nullptr);
  }

  ParentalWarningType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ParentalWarningType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ParentalWarningType& from);
  void MergeFrom(const ParentalWarningType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParentalWarningType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ParentalWarningType";
  }
  protected:
  explicit ParentalWarningType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ParentalWarningType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class PartyRelationshipType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.PartyRelationshipType) */ {
 public:
  inline PartyRelationshipType() : PartyRelationshipType(nullptr) {}
  virtual ~PartyRelationshipType();

  PartyRelationshipType(const PartyRelationshipType& from);
  PartyRelationshipType(PartyRelationshipType&& from) noexcept
    : PartyRelationshipType() {
    *this = ::std::move(from);
  }

  inline PartyRelationshipType& operator=(const PartyRelationshipType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyRelationshipType& operator=(PartyRelationshipType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartyRelationshipType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartyRelationshipType* internal_default_instance() {
    return reinterpret_cast<const PartyRelationshipType*>(
               &_PartyRelationshipType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(PartyRelationshipType& a, PartyRelationshipType& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyRelationshipType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyRelationshipType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartyRelationshipType* New() const final {
    return CreateMaybeMessage<PartyRelationshipType>(nullptr);
  }

  PartyRelationshipType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartyRelationshipType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartyRelationshipType& from);
  void MergeFrom(const PartyRelationshipType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyRelationshipType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.PartyRelationshipType";
  }
  protected:
  explicit PartyRelationshipType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.PartyRelationshipType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class PercentageType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.PercentageType) */ {
 public:
  inline PercentageType() : PercentageType(nullptr) {}
  virtual ~PercentageType();

  PercentageType(const PercentageType& from);
  PercentageType(PercentageType&& from) noexcept
    : PercentageType() {
    *this = ::std::move(from);
  }

  inline PercentageType& operator=(const PercentageType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PercentageType& operator=(PercentageType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PercentageType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PercentageType* internal_default_instance() {
    return reinterpret_cast<const PercentageType*>(
               &_PercentageType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(PercentageType& a, PercentageType& b) {
    a.Swap(&b);
  }
  inline void Swap(PercentageType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PercentageType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PercentageType* New() const final {
    return CreateMaybeMessage<PercentageType>(nullptr);
  }

  PercentageType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PercentageType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PercentageType& from);
  void MergeFrom(const PercentageType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PercentageType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.PercentageType";
  }
  protected:
  explicit PercentageType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.PercentageType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class Period PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.Period) */ {
 public:
  inline Period() : Period(nullptr) {}
  virtual ~Period();

  Period(const Period& from);
  Period(Period&& from) noexcept
    : Period() {
    *this = ::std::move(from);
  }

  inline Period& operator=(const Period& from) {
    CopyFrom(from);
    return *this;
  }
  inline Period& operator=(Period&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Period& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Period* internal_default_instance() {
    return reinterpret_cast<const Period*>(
               &_Period_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(Period& a, Period& b) {
    a.Swap(&b);
  }
  inline void Swap(Period* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Period* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Period* New() const final {
    return CreateMaybeMessage<Period>(nullptr);
  }

  Period* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Period>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Period& from);
  void MergeFrom(const Period& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Period* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.Period";
  }
  protected:
  explicit Period(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.Period)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class PhysicalCarrierType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.PhysicalCarrierType) */ {
 public:
  inline PhysicalCarrierType() : PhysicalCarrierType(nullptr) {}
  virtual ~PhysicalCarrierType();

  PhysicalCarrierType(const PhysicalCarrierType& from);
  PhysicalCarrierType(PhysicalCarrierType&& from) noexcept
    : PhysicalCarrierType() {
    *this = ::std::move(from);
  }

  inline PhysicalCarrierType& operator=(const PhysicalCarrierType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicalCarrierType& operator=(PhysicalCarrierType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PhysicalCarrierType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhysicalCarrierType* internal_default_instance() {
    return reinterpret_cast<const PhysicalCarrierType*>(
               &_PhysicalCarrierType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(PhysicalCarrierType& a, PhysicalCarrierType& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicalCarrierType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhysicalCarrierType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhysicalCarrierType* New() const final {
    return CreateMaybeMessage<PhysicalCarrierType>(nullptr);
  }

  PhysicalCarrierType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhysicalCarrierType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PhysicalCarrierType& from);
  void MergeFrom(const PhysicalCarrierType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicalCarrierType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.PhysicalCarrierType";
  }
  protected:
  explicit PhysicalCarrierType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.PhysicalCarrierType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class PriceInformationType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.PriceInformationType) */ {
 public:
  inline PriceInformationType() : PriceInformationType(nullptr) {}
  virtual ~PriceInformationType();

  PriceInformationType(const PriceInformationType& from);
  PriceInformationType(PriceInformationType&& from) noexcept
    : PriceInformationType() {
    *this = ::std::move(from);
  }

  inline PriceInformationType& operator=(const PriceInformationType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceInformationType& operator=(PriceInformationType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PriceInformationType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PriceInformationType* internal_default_instance() {
    return reinterpret_cast<const PriceInformationType*>(
               &_PriceInformationType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(PriceInformationType& a, PriceInformationType& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceInformationType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceInformationType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PriceInformationType* New() const final {
    return CreateMaybeMessage<PriceInformationType>(nullptr);
  }

  PriceInformationType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PriceInformationType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PriceInformationType& from);
  void MergeFrom(const PriceInformationType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceInformationType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.PriceInformationType";
  }
  protected:
  explicit PriceInformationType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.PriceInformationType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ProductType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ProductType) */ {
 public:
  inline ProductType() : ProductType(nullptr) {}
  virtual ~ProductType();

  ProductType(const ProductType& from);
  ProductType(ProductType&& from) noexcept
    : ProductType() {
    *this = ::std::move(from);
  }

  inline ProductType& operator=(const ProductType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductType& operator=(ProductType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProductType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProductType* internal_default_instance() {
    return reinterpret_cast<const ProductType*>(
               &_ProductType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(ProductType& a, ProductType& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProductType* New() const final {
    return CreateMaybeMessage<ProductType>(nullptr);
  }

  ProductType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProductType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProductType& from);
  void MergeFrom(const ProductType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ProductType";
  }
  protected:
  explicit ProductType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ProductType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ProfileId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ProfileId) */ {
 public:
  inline ProfileId() : ProfileId(nullptr) {}
  virtual ~ProfileId();

  ProfileId(const ProfileId& from);
  ProfileId(ProfileId&& from) noexcept
    : ProfileId() {
    *this = ::std::move(from);
  }

  inline ProfileId& operator=(const ProfileId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileId& operator=(ProfileId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProfileId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProfileId* internal_default_instance() {
    return reinterpret_cast<const ProfileId*>(
               &_ProfileId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(ProfileId& a, ProfileId& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProfileId* New() const final {
    return CreateMaybeMessage<ProfileId>(nullptr);
  }

  ProfileId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProfileId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProfileId& from);
  void MergeFrom(const ProfileId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ProfileId";
  }
  protected:
  explicit ProfileId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ProfileId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class Purpose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.Purpose) */ {
 public:
  inline Purpose() : Purpose(nullptr) {}
  virtual ~Purpose();

  Purpose(const Purpose& from);
  Purpose(Purpose&& from) noexcept
    : Purpose() {
    *this = ::std::move(from);
  }

  inline Purpose& operator=(const Purpose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Purpose& operator=(Purpose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Purpose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Purpose* internal_default_instance() {
    return reinterpret_cast<const Purpose*>(
               &_Purpose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(Purpose& a, Purpose& b) {
    a.Swap(&b);
  }
  inline void Swap(Purpose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Purpose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Purpose* New() const final {
    return CreateMaybeMessage<Purpose>(nullptr);
  }

  Purpose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Purpose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Purpose& from);
  void MergeFrom(const Purpose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Purpose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.Purpose";
  }
  protected:
  explicit Purpose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.Purpose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RatingAgency PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RatingAgency) */ {
 public:
  inline RatingAgency() : RatingAgency(nullptr) {}
  virtual ~RatingAgency();

  RatingAgency(const RatingAgency& from);
  RatingAgency(RatingAgency&& from) noexcept
    : RatingAgency() {
    *this = ::std::move(from);
  }

  inline RatingAgency& operator=(const RatingAgency& from) {
    CopyFrom(from);
    return *this;
  }
  inline RatingAgency& operator=(RatingAgency&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RatingAgency& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RatingAgency* internal_default_instance() {
    return reinterpret_cast<const RatingAgency*>(
               &_RatingAgency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(RatingAgency& a, RatingAgency& b) {
    a.Swap(&b);
  }
  inline void Swap(RatingAgency* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RatingAgency* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RatingAgency* New() const final {
    return CreateMaybeMessage<RatingAgency>(nullptr);
  }

  RatingAgency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RatingAgency>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RatingAgency& from);
  void MergeFrom(const RatingAgency& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RatingAgency* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RatingAgency";
  }
  protected:
  explicit RatingAgency(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RatingAgency)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RatingReason PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RatingReason) */ {
 public:
  inline RatingReason() : RatingReason(nullptr) {}
  virtual ~RatingReason();

  RatingReason(const RatingReason& from);
  RatingReason(RatingReason&& from) noexcept
    : RatingReason() {
    *this = ::std::move(from);
  }

  inline RatingReason& operator=(const RatingReason& from) {
    CopyFrom(from);
    return *this;
  }
  inline RatingReason& operator=(RatingReason&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RatingReason& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RatingReason* internal_default_instance() {
    return reinterpret_cast<const RatingReason*>(
               &_RatingReason_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(RatingReason& a, RatingReason& b) {
    a.Swap(&b);
  }
  inline void Swap(RatingReason* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RatingReason* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RatingReason* New() const final {
    return CreateMaybeMessage<RatingReason>(nullptr);
  }

  RatingReason* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RatingReason>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RatingReason& from);
  void MergeFrom(const RatingReason& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RatingReason* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RatingReason";
  }
  protected:
  explicit RatingReason(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RatingReason)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RecipientRevenueType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RecipientRevenueType) */ {
 public:
  inline RecipientRevenueType() : RecipientRevenueType(nullptr) {}
  virtual ~RecipientRevenueType();

  RecipientRevenueType(const RecipientRevenueType& from);
  RecipientRevenueType(RecipientRevenueType&& from) noexcept
    : RecipientRevenueType() {
    *this = ::std::move(from);
  }

  inline RecipientRevenueType& operator=(const RecipientRevenueType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecipientRevenueType& operator=(RecipientRevenueType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecipientRevenueType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecipientRevenueType* internal_default_instance() {
    return reinterpret_cast<const RecipientRevenueType*>(
               &_RecipientRevenueType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(RecipientRevenueType& a, RecipientRevenueType& b) {
    a.Swap(&b);
  }
  inline void Swap(RecipientRevenueType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecipientRevenueType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecipientRevenueType* New() const final {
    return CreateMaybeMessage<RecipientRevenueType>(nullptr);
  }

  RecipientRevenueType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecipientRevenueType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecipientRevenueType& from);
  void MergeFrom(const RecipientRevenueType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecipientRevenueType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RecipientRevenueType";
  }
  protected:
  explicit RecipientRevenueType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RecipientRevenueType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RecordingMode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RecordingMode) */ {
 public:
  inline RecordingMode() : RecordingMode(nullptr) {}
  virtual ~RecordingMode();

  RecordingMode(const RecordingMode& from);
  RecordingMode(RecordingMode&& from) noexcept
    : RecordingMode() {
    *this = ::std::move(from);
  }

  inline RecordingMode& operator=(const RecordingMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordingMode& operator=(RecordingMode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecordingMode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordingMode* internal_default_instance() {
    return reinterpret_cast<const RecordingMode*>(
               &_RecordingMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(RecordingMode& a, RecordingMode& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordingMode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordingMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecordingMode* New() const final {
    return CreateMaybeMessage<RecordingMode>(nullptr);
  }

  RecordingMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecordingMode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecordingMode& from);
  void MergeFrom(const RecordingMode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordingMode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RecordingMode";
  }
  protected:
  explicit RecordingMode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RecordingMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RecordingPartType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RecordingPartType) */ {
 public:
  inline RecordingPartType() : RecordingPartType(nullptr) {}
  virtual ~RecordingPartType();

  RecordingPartType(const RecordingPartType& from);
  RecordingPartType(RecordingPartType&& from) noexcept
    : RecordingPartType() {
    *this = ::std::move(from);
  }

  inline RecordingPartType& operator=(const RecordingPartType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordingPartType& operator=(RecordingPartType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecordingPartType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordingPartType* internal_default_instance() {
    return reinterpret_cast<const RecordingPartType*>(
               &_RecordingPartType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(RecordingPartType& a, RecordingPartType& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordingPartType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordingPartType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecordingPartType* New() const final {
    return CreateMaybeMessage<RecordingPartType>(nullptr);
  }

  RecordingPartType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecordingPartType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecordingPartType& from);
  void MergeFrom(const RecordingPartType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordingPartType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RecordingPartType";
  }
  protected:
  explicit RecordingPartType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RecordingPartType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReferenceCreation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ReferenceCreation) */ {
 public:
  inline ReferenceCreation() : ReferenceCreation(nullptr) {}
  virtual ~ReferenceCreation();

  ReferenceCreation(const ReferenceCreation& from);
  ReferenceCreation(ReferenceCreation&& from) noexcept
    : ReferenceCreation() {
    *this = ::std::move(from);
  }

  inline ReferenceCreation& operator=(const ReferenceCreation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceCreation& operator=(ReferenceCreation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReferenceCreation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReferenceCreation* internal_default_instance() {
    return reinterpret_cast<const ReferenceCreation*>(
               &_ReferenceCreation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(ReferenceCreation& a, ReferenceCreation& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceCreation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceCreation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReferenceCreation* New() const final {
    return CreateMaybeMessage<ReferenceCreation>(nullptr);
  }

  ReferenceCreation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceCreation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReferenceCreation& from);
  void MergeFrom(const ReferenceCreation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceCreation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ReferenceCreation";
  }
  protected:
  explicit ReferenceCreation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ReferenceCreation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReferenceUnit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ReferenceUnit) */ {
 public:
  inline ReferenceUnit() : ReferenceUnit(nullptr) {}
  virtual ~ReferenceUnit();

  ReferenceUnit(const ReferenceUnit& from);
  ReferenceUnit(ReferenceUnit&& from) noexcept
    : ReferenceUnit() {
    *this = ::std::move(from);
  }

  inline ReferenceUnit& operator=(const ReferenceUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceUnit& operator=(ReferenceUnit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReferenceUnit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReferenceUnit* internal_default_instance() {
    return reinterpret_cast<const ReferenceUnit*>(
               &_ReferenceUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(ReferenceUnit& a, ReferenceUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceUnit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceUnit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReferenceUnit* New() const final {
    return CreateMaybeMessage<ReferenceUnit>(nullptr);
  }

  ReferenceUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceUnit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReferenceUnit& from);
  void MergeFrom(const ReferenceUnit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceUnit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ReferenceUnit";
  }
  protected:
  explicit ReferenceUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ReferenceUnit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RegistrationStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RegistrationStatus) */ {
 public:
  inline RegistrationStatus() : RegistrationStatus(nullptr) {}
  virtual ~RegistrationStatus();

  RegistrationStatus(const RegistrationStatus& from);
  RegistrationStatus(RegistrationStatus&& from) noexcept
    : RegistrationStatus() {
    *this = ::std::move(from);
  }

  inline RegistrationStatus& operator=(const RegistrationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationStatus& operator=(RegistrationStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegistrationStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegistrationStatus* internal_default_instance() {
    return reinterpret_cast<const RegistrationStatus*>(
               &_RegistrationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(RegistrationStatus& a, RegistrationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistrationStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegistrationStatus* New() const final {
    return CreateMaybeMessage<RegistrationStatus>(nullptr);
  }

  RegistrationStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegistrationStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegistrationStatus& from);
  void MergeFrom(const RegistrationStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistrationStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RegistrationStatus";
  }
  protected:
  explicit RegistrationStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RegistrationStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RelatedResourceType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RelatedResourceType) */ {
 public:
  inline RelatedResourceType() : RelatedResourceType(nullptr) {}
  virtual ~RelatedResourceType();

  RelatedResourceType(const RelatedResourceType& from);
  RelatedResourceType(RelatedResourceType&& from) noexcept
    : RelatedResourceType() {
    *this = ::std::move(from);
  }

  inline RelatedResourceType& operator=(const RelatedResourceType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelatedResourceType& operator=(RelatedResourceType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RelatedResourceType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelatedResourceType* internal_default_instance() {
    return reinterpret_cast<const RelatedResourceType*>(
               &_RelatedResourceType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(RelatedResourceType& a, RelatedResourceType& b) {
    a.Swap(&b);
  }
  inline void Swap(RelatedResourceType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelatedResourceType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelatedResourceType* New() const final {
    return CreateMaybeMessage<RelatedResourceType>(nullptr);
  }

  RelatedResourceType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelatedResourceType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RelatedResourceType& from);
  void MergeFrom(const RelatedResourceType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelatedResourceType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RelatedResourceType";
  }
  protected:
  explicit RelatedResourceType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RelatedResourceType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RelationalRelator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RelationalRelator) */ {
 public:
  inline RelationalRelator() : RelationalRelator(nullptr) {}
  virtual ~RelationalRelator();

  RelationalRelator(const RelationalRelator& from);
  RelationalRelator(RelationalRelator&& from) noexcept
    : RelationalRelator() {
    *this = ::std::move(from);
  }

  inline RelationalRelator& operator=(const RelationalRelator& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationalRelator& operator=(RelationalRelator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RelationalRelator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelationalRelator* internal_default_instance() {
    return reinterpret_cast<const RelationalRelator*>(
               &_RelationalRelator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(RelationalRelator& a, RelationalRelator& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationalRelator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationalRelator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelationalRelator* New() const final {
    return CreateMaybeMessage<RelationalRelator>(nullptr);
  }

  RelationalRelator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelationalRelator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RelationalRelator& from);
  void MergeFrom(const RelationalRelator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationalRelator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RelationalRelator";
  }
  protected:
  explicit RelationalRelator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RelationalRelator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseProfileVariantVersionId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ReleaseProfileVariantVersionId) */ {
 public:
  inline ReleaseProfileVariantVersionId() : ReleaseProfileVariantVersionId(nullptr) {}
  virtual ~ReleaseProfileVariantVersionId();

  ReleaseProfileVariantVersionId(const ReleaseProfileVariantVersionId& from);
  ReleaseProfileVariantVersionId(ReleaseProfileVariantVersionId&& from) noexcept
    : ReleaseProfileVariantVersionId() {
    *this = ::std::move(from);
  }

  inline ReleaseProfileVariantVersionId& operator=(const ReleaseProfileVariantVersionId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseProfileVariantVersionId& operator=(ReleaseProfileVariantVersionId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReleaseProfileVariantVersionId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseProfileVariantVersionId* internal_default_instance() {
    return reinterpret_cast<const ReleaseProfileVariantVersionId*>(
               &_ReleaseProfileVariantVersionId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(ReleaseProfileVariantVersionId& a, ReleaseProfileVariantVersionId& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseProfileVariantVersionId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseProfileVariantVersionId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseProfileVariantVersionId* New() const final {
    return CreateMaybeMessage<ReleaseProfileVariantVersionId>(nullptr);
  }

  ReleaseProfileVariantVersionId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseProfileVariantVersionId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReleaseProfileVariantVersionId& from);
  void MergeFrom(const ReleaseProfileVariantVersionId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseProfileVariantVersionId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ReleaseProfileVariantVersionId";
  }
  protected:
  explicit ReleaseProfileVariantVersionId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ReleaseProfileVariantVersionId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseProfileVersionId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ReleaseProfileVersionId) */ {
 public:
  inline ReleaseProfileVersionId() : ReleaseProfileVersionId(nullptr) {}
  virtual ~ReleaseProfileVersionId();

  ReleaseProfileVersionId(const ReleaseProfileVersionId& from);
  ReleaseProfileVersionId(ReleaseProfileVersionId&& from) noexcept
    : ReleaseProfileVersionId() {
    *this = ::std::move(from);
  }

  inline ReleaseProfileVersionId& operator=(const ReleaseProfileVersionId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseProfileVersionId& operator=(ReleaseProfileVersionId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReleaseProfileVersionId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseProfileVersionId* internal_default_instance() {
    return reinterpret_cast<const ReleaseProfileVersionId*>(
               &_ReleaseProfileVersionId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(ReleaseProfileVersionId& a, ReleaseProfileVersionId& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseProfileVersionId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseProfileVersionId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseProfileVersionId* New() const final {
    return CreateMaybeMessage<ReleaseProfileVersionId>(nullptr);
  }

  ReleaseProfileVersionId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseProfileVersionId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReleaseProfileVersionId& from);
  void MergeFrom(const ReleaseProfileVersionId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseProfileVersionId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ReleaseProfileVersionId";
  }
  protected:
  explicit ReleaseProfileVersionId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ReleaseProfileVersionId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseRelationshipType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ReleaseRelationshipType) */ {
 public:
  inline ReleaseRelationshipType() : ReleaseRelationshipType(nullptr) {}
  virtual ~ReleaseRelationshipType();

  ReleaseRelationshipType(const ReleaseRelationshipType& from);
  ReleaseRelationshipType(ReleaseRelationshipType&& from) noexcept
    : ReleaseRelationshipType() {
    *this = ::std::move(from);
  }

  inline ReleaseRelationshipType& operator=(const ReleaseRelationshipType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseRelationshipType& operator=(ReleaseRelationshipType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReleaseRelationshipType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseRelationshipType* internal_default_instance() {
    return reinterpret_cast<const ReleaseRelationshipType*>(
               &_ReleaseRelationshipType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(ReleaseRelationshipType& a, ReleaseRelationshipType& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseRelationshipType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseRelationshipType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseRelationshipType* New() const final {
    return CreateMaybeMessage<ReleaseRelationshipType>(nullptr);
  }

  ReleaseRelationshipType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseRelationshipType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReleaseRelationshipType& from);
  void MergeFrom(const ReleaseRelationshipType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseRelationshipType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ReleaseRelationshipType";
  }
  protected:
  explicit ReleaseRelationshipType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ReleaseRelationshipType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseResourceType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ReleaseResourceType) */ {
 public:
  inline ReleaseResourceType() : ReleaseResourceType(nullptr) {}
  virtual ~ReleaseResourceType();

  ReleaseResourceType(const ReleaseResourceType& from);
  ReleaseResourceType(ReleaseResourceType&& from) noexcept
    : ReleaseResourceType() {
    *this = ::std::move(from);
  }

  inline ReleaseResourceType& operator=(const ReleaseResourceType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseResourceType& operator=(ReleaseResourceType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReleaseResourceType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseResourceType* internal_default_instance() {
    return reinterpret_cast<const ReleaseResourceType*>(
               &_ReleaseResourceType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(ReleaseResourceType& a, ReleaseResourceType& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseResourceType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseResourceType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseResourceType* New() const final {
    return CreateMaybeMessage<ReleaseResourceType>(nullptr);
  }

  ReleaseResourceType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseResourceType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReleaseResourceType& from);
  void MergeFrom(const ReleaseResourceType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseResourceType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ReleaseResourceType";
  }
  protected:
  explicit ReleaseResourceType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ReleaseResourceType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ReleaseType) */ {
 public:
  inline ReleaseType() : ReleaseType(nullptr) {}
  virtual ~ReleaseType();

  ReleaseType(const ReleaseType& from);
  ReleaseType(ReleaseType&& from) noexcept
    : ReleaseType() {
    *this = ::std::move(from);
  }

  inline ReleaseType& operator=(const ReleaseType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseType& operator=(ReleaseType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReleaseType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseType* internal_default_instance() {
    return reinterpret_cast<const ReleaseType*>(
               &_ReleaseType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(ReleaseType& a, ReleaseType& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseType* New() const final {
    return CreateMaybeMessage<ReleaseType>(nullptr);
  }

  ReleaseType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReleaseType& from);
  void MergeFrom(const ReleaseType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ReleaseType";
  }
  protected:
  explicit ReleaseType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ReleaseType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseType_ERN4 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ReleaseType_ERN4) */ {
 public:
  inline ReleaseType_ERN4() : ReleaseType_ERN4(nullptr) {}
  virtual ~ReleaseType_ERN4();

  ReleaseType_ERN4(const ReleaseType_ERN4& from);
  ReleaseType_ERN4(ReleaseType_ERN4&& from) noexcept
    : ReleaseType_ERN4() {
    *this = ::std::move(from);
  }

  inline ReleaseType_ERN4& operator=(const ReleaseType_ERN4& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseType_ERN4& operator=(ReleaseType_ERN4&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReleaseType_ERN4& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseType_ERN4* internal_default_instance() {
    return reinterpret_cast<const ReleaseType_ERN4*>(
               &_ReleaseType_ERN4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(ReleaseType_ERN4& a, ReleaseType_ERN4& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseType_ERN4* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseType_ERN4* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseType_ERN4* New() const final {
    return CreateMaybeMessage<ReleaseType_ERN4>(nullptr);
  }

  ReleaseType_ERN4* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseType_ERN4>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReleaseType_ERN4& from);
  void MergeFrom(const ReleaseType_ERN4& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseType_ERN4* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ReleaseType_ERN4";
  }
  protected:
  explicit ReleaseType_ERN4(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ReleaseType_ERN4)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseType_MCNOTIF PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ReleaseType_MCNOTIF) */ {
 public:
  inline ReleaseType_MCNOTIF() : ReleaseType_MCNOTIF(nullptr) {}
  virtual ~ReleaseType_MCNOTIF();

  ReleaseType_MCNOTIF(const ReleaseType_MCNOTIF& from);
  ReleaseType_MCNOTIF(ReleaseType_MCNOTIF&& from) noexcept
    : ReleaseType_MCNOTIF() {
    *this = ::std::move(from);
  }

  inline ReleaseType_MCNOTIF& operator=(const ReleaseType_MCNOTIF& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseType_MCNOTIF& operator=(ReleaseType_MCNOTIF&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReleaseType_MCNOTIF& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseType_MCNOTIF* internal_default_instance() {
    return reinterpret_cast<const ReleaseType_MCNOTIF*>(
               &_ReleaseType_MCNOTIF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(ReleaseType_MCNOTIF& a, ReleaseType_MCNOTIF& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseType_MCNOTIF* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseType_MCNOTIF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseType_MCNOTIF* New() const final {
    return CreateMaybeMessage<ReleaseType_MCNOTIF>(nullptr);
  }

  ReleaseType_MCNOTIF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseType_MCNOTIF>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReleaseType_MCNOTIF& from);
  void MergeFrom(const ReleaseType_MCNOTIF& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseType_MCNOTIF* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ReleaseType_MCNOTIF";
  }
  protected:
  explicit ReleaseType_MCNOTIF(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ReleaseType_MCNOTIF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RequestMessagePurpose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RequestMessagePurpose) */ {
 public:
  inline RequestMessagePurpose() : RequestMessagePurpose(nullptr) {}
  virtual ~RequestMessagePurpose();

  RequestMessagePurpose(const RequestMessagePurpose& from);
  RequestMessagePurpose(RequestMessagePurpose&& from) noexcept
    : RequestMessagePurpose() {
    *this = ::std::move(from);
  }

  inline RequestMessagePurpose& operator=(const RequestMessagePurpose& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestMessagePurpose& operator=(RequestMessagePurpose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestMessagePurpose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestMessagePurpose* internal_default_instance() {
    return reinterpret_cast<const RequestMessagePurpose*>(
               &_RequestMessagePurpose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(RequestMessagePurpose& a, RequestMessagePurpose& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestMessagePurpose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestMessagePurpose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestMessagePurpose* New() const final {
    return CreateMaybeMessage<RequestMessagePurpose>(nullptr);
  }

  RequestMessagePurpose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestMessagePurpose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestMessagePurpose& from);
  void MergeFrom(const RequestMessagePurpose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestMessagePurpose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RequestMessagePurpose";
  }
  protected:
  explicit RequestMessagePurpose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RequestMessagePurpose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RequestReason PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RequestReason) */ {
 public:
  inline RequestReason() : RequestReason(nullptr) {}
  virtual ~RequestReason();

  RequestReason(const RequestReason& from);
  RequestReason(RequestReason&& from) noexcept
    : RequestReason() {
    *this = ::std::move(from);
  }

  inline RequestReason& operator=(const RequestReason& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestReason& operator=(RequestReason&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestReason& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestReason* internal_default_instance() {
    return reinterpret_cast<const RequestReason*>(
               &_RequestReason_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(RequestReason& a, RequestReason& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestReason* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestReason* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestReason* New() const final {
    return CreateMaybeMessage<RequestReason>(nullptr);
  }

  RequestReason* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestReason>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestReason& from);
  void MergeFrom(const RequestReason& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestReason* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RequestReason";
  }
  protected:
  explicit RequestReason(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RequestReason)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ResourceContributorRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ResourceContributorRole) */ {
 public:
  inline ResourceContributorRole() : ResourceContributorRole(nullptr) {}
  virtual ~ResourceContributorRole();

  ResourceContributorRole(const ResourceContributorRole& from);
  ResourceContributorRole(ResourceContributorRole&& from) noexcept
    : ResourceContributorRole() {
    *this = ::std::move(from);
  }

  inline ResourceContributorRole& operator=(const ResourceContributorRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceContributorRole& operator=(ResourceContributorRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResourceContributorRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceContributorRole* internal_default_instance() {
    return reinterpret_cast<const ResourceContributorRole*>(
               &_ResourceContributorRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(ResourceContributorRole& a, ResourceContributorRole& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceContributorRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceContributorRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceContributorRole* New() const final {
    return CreateMaybeMessage<ResourceContributorRole>(nullptr);
  }

  ResourceContributorRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceContributorRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResourceContributorRole& from);
  void MergeFrom(const ResourceContributorRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceContributorRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ResourceContributorRole";
  }
  protected:
  explicit ResourceContributorRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ResourceContributorRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ResourceGroupType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ResourceGroupType) */ {
 public:
  inline ResourceGroupType() : ResourceGroupType(nullptr) {}
  virtual ~ResourceGroupType();

  ResourceGroupType(const ResourceGroupType& from);
  ResourceGroupType(ResourceGroupType&& from) noexcept
    : ResourceGroupType() {
    *this = ::std::move(from);
  }

  inline ResourceGroupType& operator=(const ResourceGroupType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceGroupType& operator=(ResourceGroupType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResourceGroupType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceGroupType* internal_default_instance() {
    return reinterpret_cast<const ResourceGroupType*>(
               &_ResourceGroupType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(ResourceGroupType& a, ResourceGroupType& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceGroupType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceGroupType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceGroupType* New() const final {
    return CreateMaybeMessage<ResourceGroupType>(nullptr);
  }

  ResourceGroupType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceGroupType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResourceGroupType& from);
  void MergeFrom(const ResourceGroupType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceGroupType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ResourceGroupType";
  }
  protected:
  explicit ResourceGroupType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ResourceGroupType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ResourceRelationshipType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ResourceRelationshipType) */ {
 public:
  inline ResourceRelationshipType() : ResourceRelationshipType(nullptr) {}
  virtual ~ResourceRelationshipType();

  ResourceRelationshipType(const ResourceRelationshipType& from);
  ResourceRelationshipType(ResourceRelationshipType&& from) noexcept
    : ResourceRelationshipType() {
    *this = ::std::move(from);
  }

  inline ResourceRelationshipType& operator=(const ResourceRelationshipType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceRelationshipType& operator=(ResourceRelationshipType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResourceRelationshipType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceRelationshipType* internal_default_instance() {
    return reinterpret_cast<const ResourceRelationshipType*>(
               &_ResourceRelationshipType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(ResourceRelationshipType& a, ResourceRelationshipType& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceRelationshipType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceRelationshipType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceRelationshipType* New() const final {
    return CreateMaybeMessage<ResourceRelationshipType>(nullptr);
  }

  ResourceRelationshipType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceRelationshipType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResourceRelationshipType& from);
  void MergeFrom(const ResourceRelationshipType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceRelationshipType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ResourceRelationshipType";
  }
  protected:
  explicit ResourceRelationshipType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ResourceRelationshipType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ResourceType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ResourceType) */ {
 public:
  inline ResourceType() : ResourceType(nullptr) {}
  virtual ~ResourceType();

  ResourceType(const ResourceType& from);
  ResourceType(ResourceType&& from) noexcept
    : ResourceType() {
    *this = ::std::move(from);
  }

  inline ResourceType& operator=(const ResourceType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceType& operator=(ResourceType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResourceType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceType* internal_default_instance() {
    return reinterpret_cast<const ResourceType*>(
               &_ResourceType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(ResourceType& a, ResourceType& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceType* New() const final {
    return CreateMaybeMessage<ResourceType>(nullptr);
  }

  ResourceType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResourceType& from);
  void MergeFrom(const ResourceType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ResourceType";
  }
  protected:
  explicit ResourceType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ResourceType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ResourceType_MCNOTIF PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ResourceType_MCNOTIF) */ {
 public:
  inline ResourceType_MCNOTIF() : ResourceType_MCNOTIF(nullptr) {}
  virtual ~ResourceType_MCNOTIF();

  ResourceType_MCNOTIF(const ResourceType_MCNOTIF& from);
  ResourceType_MCNOTIF(ResourceType_MCNOTIF&& from) noexcept
    : ResourceType_MCNOTIF() {
    *this = ::std::move(from);
  }

  inline ResourceType_MCNOTIF& operator=(const ResourceType_MCNOTIF& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceType_MCNOTIF& operator=(ResourceType_MCNOTIF&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResourceType_MCNOTIF& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceType_MCNOTIF* internal_default_instance() {
    return reinterpret_cast<const ResourceType_MCNOTIF*>(
               &_ResourceType_MCNOTIF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(ResourceType_MCNOTIF& a, ResourceType_MCNOTIF& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceType_MCNOTIF* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceType_MCNOTIF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceType_MCNOTIF* New() const final {
    return CreateMaybeMessage<ResourceType_MCNOTIF>(nullptr);
  }

  ResourceType_MCNOTIF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceType_MCNOTIF>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResourceType_MCNOTIF& from);
  void MergeFrom(const ResourceType_MCNOTIF& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceType_MCNOTIF* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ResourceType_MCNOTIF";
  }
  protected:
  explicit ResourceType_MCNOTIF(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ResourceType_MCNOTIF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ResourceWorkRelationshipType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ResourceWorkRelationshipType) */ {
 public:
  inline ResourceWorkRelationshipType() : ResourceWorkRelationshipType(nullptr) {}
  virtual ~ResourceWorkRelationshipType();

  ResourceWorkRelationshipType(const ResourceWorkRelationshipType& from);
  ResourceWorkRelationshipType(ResourceWorkRelationshipType&& from) noexcept
    : ResourceWorkRelationshipType() {
    *this = ::std::move(from);
  }

  inline ResourceWorkRelationshipType& operator=(const ResourceWorkRelationshipType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceWorkRelationshipType& operator=(ResourceWorkRelationshipType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResourceWorkRelationshipType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceWorkRelationshipType* internal_default_instance() {
    return reinterpret_cast<const ResourceWorkRelationshipType*>(
               &_ResourceWorkRelationshipType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(ResourceWorkRelationshipType& a, ResourceWorkRelationshipType& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceWorkRelationshipType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceWorkRelationshipType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceWorkRelationshipType* New() const final {
    return CreateMaybeMessage<ResourceWorkRelationshipType>(nullptr);
  }

  ResourceWorkRelationshipType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceWorkRelationshipType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResourceWorkRelationshipType& from);
  void MergeFrom(const ResourceWorkRelationshipType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceWorkRelationshipType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ResourceWorkRelationshipType";
  }
  protected:
  explicit ResourceWorkRelationshipType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ResourceWorkRelationshipType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RevenueSourceType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RevenueSourceType) */ {
 public:
  inline RevenueSourceType() : RevenueSourceType(nullptr) {}
  virtual ~RevenueSourceType();

  RevenueSourceType(const RevenueSourceType& from);
  RevenueSourceType(RevenueSourceType&& from) noexcept
    : RevenueSourceType() {
    *this = ::std::move(from);
  }

  inline RevenueSourceType& operator=(const RevenueSourceType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevenueSourceType& operator=(RevenueSourceType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RevenueSourceType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RevenueSourceType* internal_default_instance() {
    return reinterpret_cast<const RevenueSourceType*>(
               &_RevenueSourceType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  friend void swap(RevenueSourceType& a, RevenueSourceType& b) {
    a.Swap(&b);
  }
  inline void Swap(RevenueSourceType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevenueSourceType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RevenueSourceType* New() const final {
    return CreateMaybeMessage<RevenueSourceType>(nullptr);
  }

  RevenueSourceType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RevenueSourceType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RevenueSourceType& from);
  void MergeFrom(const RevenueSourceType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RevenueSourceType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RevenueSourceType";
  }
  protected:
  explicit RevenueSourceType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RevenueSourceType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RightShareType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RightShareType) */ {
 public:
  inline RightShareType() : RightShareType(nullptr) {}
  virtual ~RightShareType();

  RightShareType(const RightShareType& from);
  RightShareType(RightShareType&& from) noexcept
    : RightShareType() {
    *this = ::std::move(from);
  }

  inline RightShareType& operator=(const RightShareType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightShareType& operator=(RightShareType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightShareType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightShareType* internal_default_instance() {
    return reinterpret_cast<const RightShareType*>(
               &_RightShareType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  friend void swap(RightShareType& a, RightShareType& b) {
    a.Swap(&b);
  }
  inline void Swap(RightShareType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightShareType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightShareType* New() const final {
    return CreateMaybeMessage<RightShareType>(nullptr);
  }

  RightShareType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightShareType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightShareType& from);
  void MergeFrom(const RightShareType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightShareType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RightShareType";
  }
  protected:
  explicit RightShareType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RightShareType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RightsClaimPolicyType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RightsClaimPolicyType) */ {
 public:
  inline RightsClaimPolicyType() : RightsClaimPolicyType(nullptr) {}
  virtual ~RightsClaimPolicyType();

  RightsClaimPolicyType(const RightsClaimPolicyType& from);
  RightsClaimPolicyType(RightsClaimPolicyType&& from) noexcept
    : RightsClaimPolicyType() {
    *this = ::std::move(from);
  }

  inline RightsClaimPolicyType& operator=(const RightsClaimPolicyType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightsClaimPolicyType& operator=(RightsClaimPolicyType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightsClaimPolicyType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightsClaimPolicyType* internal_default_instance() {
    return reinterpret_cast<const RightsClaimPolicyType*>(
               &_RightsClaimPolicyType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  friend void swap(RightsClaimPolicyType& a, RightsClaimPolicyType& b) {
    a.Swap(&b);
  }
  inline void Swap(RightsClaimPolicyType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightsClaimPolicyType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightsClaimPolicyType* New() const final {
    return CreateMaybeMessage<RightsClaimPolicyType>(nullptr);
  }

  RightsClaimPolicyType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightsClaimPolicyType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightsClaimPolicyType& from);
  void MergeFrom(const RightsClaimPolicyType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightsClaimPolicyType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RightsClaimPolicyType";
  }
  protected:
  explicit RightsClaimPolicyType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RightsClaimPolicyType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RightsClaimStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RightsClaimStatus) */ {
 public:
  inline RightsClaimStatus() : RightsClaimStatus(nullptr) {}
  virtual ~RightsClaimStatus();

  RightsClaimStatus(const RightsClaimStatus& from);
  RightsClaimStatus(RightsClaimStatus&& from) noexcept
    : RightsClaimStatus() {
    *this = ::std::move(from);
  }

  inline RightsClaimStatus& operator=(const RightsClaimStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightsClaimStatus& operator=(RightsClaimStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightsClaimStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightsClaimStatus* internal_default_instance() {
    return reinterpret_cast<const RightsClaimStatus*>(
               &_RightsClaimStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    139;

  friend void swap(RightsClaimStatus& a, RightsClaimStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RightsClaimStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightsClaimStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightsClaimStatus* New() const final {
    return CreateMaybeMessage<RightsClaimStatus>(nullptr);
  }

  RightsClaimStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightsClaimStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightsClaimStatus& from);
  void MergeFrom(const RightsClaimStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightsClaimStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RightsClaimStatus";
  }
  protected:
  explicit RightsClaimStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RightsClaimStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RightsControllerRole PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RightsControllerRole) */ {
 public:
  inline RightsControllerRole() : RightsControllerRole(nullptr) {}
  virtual ~RightsControllerRole();

  RightsControllerRole(const RightsControllerRole& from);
  RightsControllerRole(RightsControllerRole&& from) noexcept
    : RightsControllerRole() {
    *this = ::std::move(from);
  }

  inline RightsControllerRole& operator=(const RightsControllerRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightsControllerRole& operator=(RightsControllerRole&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightsControllerRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightsControllerRole* internal_default_instance() {
    return reinterpret_cast<const RightsControllerRole*>(
               &_RightsControllerRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    140;

  friend void swap(RightsControllerRole& a, RightsControllerRole& b) {
    a.Swap(&b);
  }
  inline void Swap(RightsControllerRole* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightsControllerRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightsControllerRole* New() const final {
    return CreateMaybeMessage<RightsControllerRole>(nullptr);
  }

  RightsControllerRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightsControllerRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightsControllerRole& from);
  void MergeFrom(const RightsControllerRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightsControllerRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RightsControllerRole";
  }
  protected:
  explicit RightsControllerRole(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RightsControllerRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RightsControllerType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RightsControllerType) */ {
 public:
  inline RightsControllerType() : RightsControllerType(nullptr) {}
  virtual ~RightsControllerType();

  RightsControllerType(const RightsControllerType& from);
  RightsControllerType(RightsControllerType&& from) noexcept
    : RightsControllerType() {
    *this = ::std::move(from);
  }

  inline RightsControllerType& operator=(const RightsControllerType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightsControllerType& operator=(RightsControllerType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightsControllerType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightsControllerType* internal_default_instance() {
    return reinterpret_cast<const RightsControllerType*>(
               &_RightsControllerType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    141;

  friend void swap(RightsControllerType& a, RightsControllerType& b) {
    a.Swap(&b);
  }
  inline void Swap(RightsControllerType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightsControllerType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightsControllerType* New() const final {
    return CreateMaybeMessage<RightsControllerType>(nullptr);
  }

  RightsControllerType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightsControllerType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightsControllerType& from);
  void MergeFrom(const RightsControllerType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightsControllerType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RightsControllerType";
  }
  protected:
  explicit RightsControllerType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RightsControllerType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RightsCoverage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RightsCoverage) */ {
 public:
  inline RightsCoverage() : RightsCoverage(nullptr) {}
  virtual ~RightsCoverage();

  RightsCoverage(const RightsCoverage& from);
  RightsCoverage(RightsCoverage&& from) noexcept
    : RightsCoverage() {
    *this = ::std::move(from);
  }

  inline RightsCoverage& operator=(const RightsCoverage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightsCoverage& operator=(RightsCoverage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightsCoverage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightsCoverage* internal_default_instance() {
    return reinterpret_cast<const RightsCoverage*>(
               &_RightsCoverage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    142;

  friend void swap(RightsCoverage& a, RightsCoverage& b) {
    a.Swap(&b);
  }
  inline void Swap(RightsCoverage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightsCoverage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightsCoverage* New() const final {
    return CreateMaybeMessage<RightsCoverage>(nullptr);
  }

  RightsCoverage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightsCoverage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightsCoverage& from);
  void MergeFrom(const RightsCoverage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightsCoverage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RightsCoverage";
  }
  protected:
  explicit RightsCoverage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RightsCoverage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RightsCoverage_MWNL PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RightsCoverage_MWNL) */ {
 public:
  inline RightsCoverage_MWNL() : RightsCoverage_MWNL(nullptr) {}
  virtual ~RightsCoverage_MWNL();

  RightsCoverage_MWNL(const RightsCoverage_MWNL& from);
  RightsCoverage_MWNL(RightsCoverage_MWNL&& from) noexcept
    : RightsCoverage_MWNL() {
    *this = ::std::move(from);
  }

  inline RightsCoverage_MWNL& operator=(const RightsCoverage_MWNL& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightsCoverage_MWNL& operator=(RightsCoverage_MWNL&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightsCoverage_MWNL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightsCoverage_MWNL* internal_default_instance() {
    return reinterpret_cast<const RightsCoverage_MWNL*>(
               &_RightsCoverage_MWNL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    143;

  friend void swap(RightsCoverage_MWNL& a, RightsCoverage_MWNL& b) {
    a.Swap(&b);
  }
  inline void Swap(RightsCoverage_MWNL* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightsCoverage_MWNL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightsCoverage_MWNL* New() const final {
    return CreateMaybeMessage<RightsCoverage_MWNL>(nullptr);
  }

  RightsCoverage_MWNL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightsCoverage_MWNL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightsCoverage_MWNL& from);
  void MergeFrom(const RightsCoverage_MWNL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightsCoverage_MWNL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RightsCoverage_MWNL";
  }
  protected:
  explicit RightsCoverage_MWNL(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RightsCoverage_MWNL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RightsStatementProfile PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RightsStatementProfile) */ {
 public:
  inline RightsStatementProfile() : RightsStatementProfile(nullptr) {}
  virtual ~RightsStatementProfile();

  RightsStatementProfile(const RightsStatementProfile& from);
  RightsStatementProfile(RightsStatementProfile&& from) noexcept
    : RightsStatementProfile() {
    *this = ::std::move(from);
  }

  inline RightsStatementProfile& operator=(const RightsStatementProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightsStatementProfile& operator=(RightsStatementProfile&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RightsStatementProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RightsStatementProfile* internal_default_instance() {
    return reinterpret_cast<const RightsStatementProfile*>(
               &_RightsStatementProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    144;

  friend void swap(RightsStatementProfile& a, RightsStatementProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(RightsStatementProfile* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightsStatementProfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RightsStatementProfile* New() const final {
    return CreateMaybeMessage<RightsStatementProfile>(nullptr);
  }

  RightsStatementProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RightsStatementProfile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RightsStatementProfile& from);
  void MergeFrom(const RightsStatementProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightsStatementProfile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RightsStatementProfile";
  }
  protected:
  explicit RightsStatementProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RightsStatementProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RootChordNote PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RootChordNote) */ {
 public:
  inline RootChordNote() : RootChordNote(nullptr) {}
  virtual ~RootChordNote();

  RootChordNote(const RootChordNote& from);
  RootChordNote(RootChordNote&& from) noexcept
    : RootChordNote() {
    *this = ::std::move(from);
  }

  inline RootChordNote& operator=(const RootChordNote& from) {
    CopyFrom(from);
    return *this;
  }
  inline RootChordNote& operator=(RootChordNote&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RootChordNote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RootChordNote* internal_default_instance() {
    return reinterpret_cast<const RootChordNote*>(
               &_RootChordNote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    145;

  friend void swap(RootChordNote& a, RootChordNote& b) {
    a.Swap(&b);
  }
  inline void Swap(RootChordNote* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RootChordNote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RootChordNote* New() const final {
    return CreateMaybeMessage<RootChordNote>(nullptr);
  }

  RootChordNote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RootChordNote>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RootChordNote& from);
  void MergeFrom(const RootChordNote& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RootChordNote* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RootChordNote";
  }
  protected:
  explicit RootChordNote(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RootChordNote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RootChordQuality PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RootChordQuality) */ {
 public:
  inline RootChordQuality() : RootChordQuality(nullptr) {}
  virtual ~RootChordQuality();

  RootChordQuality(const RootChordQuality& from);
  RootChordQuality(RootChordQuality&& from) noexcept
    : RootChordQuality() {
    *this = ::std::move(from);
  }

  inline RootChordQuality& operator=(const RootChordQuality& from) {
    CopyFrom(from);
    return *this;
  }
  inline RootChordQuality& operator=(RootChordQuality&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RootChordQuality& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RootChordQuality* internal_default_instance() {
    return reinterpret_cast<const RootChordQuality*>(
               &_RootChordQuality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    146;

  friend void swap(RootChordQuality& a, RootChordQuality& b) {
    a.Swap(&b);
  }
  inline void Swap(RootChordQuality* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RootChordQuality* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RootChordQuality* New() const final {
    return CreateMaybeMessage<RootChordQuality>(nullptr);
  }

  RootChordQuality* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RootChordQuality>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RootChordQuality& from);
  void MergeFrom(const RootChordQuality& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RootChordQuality* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RootChordQuality";
  }
  protected:
  explicit RootChordQuality(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RootChordQuality)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RoyaltyRateCalculationType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RoyaltyRateCalculationType) */ {
 public:
  inline RoyaltyRateCalculationType() : RoyaltyRateCalculationType(nullptr) {}
  virtual ~RoyaltyRateCalculationType();

  RoyaltyRateCalculationType(const RoyaltyRateCalculationType& from);
  RoyaltyRateCalculationType(RoyaltyRateCalculationType&& from) noexcept
    : RoyaltyRateCalculationType() {
    *this = ::std::move(from);
  }

  inline RoyaltyRateCalculationType& operator=(const RoyaltyRateCalculationType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoyaltyRateCalculationType& operator=(RoyaltyRateCalculationType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoyaltyRateCalculationType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoyaltyRateCalculationType* internal_default_instance() {
    return reinterpret_cast<const RoyaltyRateCalculationType*>(
               &_RoyaltyRateCalculationType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    147;

  friend void swap(RoyaltyRateCalculationType& a, RoyaltyRateCalculationType& b) {
    a.Swap(&b);
  }
  inline void Swap(RoyaltyRateCalculationType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoyaltyRateCalculationType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoyaltyRateCalculationType* New() const final {
    return CreateMaybeMessage<RoyaltyRateCalculationType>(nullptr);
  }

  RoyaltyRateCalculationType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoyaltyRateCalculationType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoyaltyRateCalculationType& from);
  void MergeFrom(const RoyaltyRateCalculationType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoyaltyRateCalculationType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RoyaltyRateCalculationType";
  }
  protected:
  explicit RoyaltyRateCalculationType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RoyaltyRateCalculationType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class RoyaltyRateType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.RoyaltyRateType) */ {
 public:
  inline RoyaltyRateType() : RoyaltyRateType(nullptr) {}
  virtual ~RoyaltyRateType();

  RoyaltyRateType(const RoyaltyRateType& from);
  RoyaltyRateType(RoyaltyRateType&& from) noexcept
    : RoyaltyRateType() {
    *this = ::std::move(from);
  }

  inline RoyaltyRateType& operator=(const RoyaltyRateType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoyaltyRateType& operator=(RoyaltyRateType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoyaltyRateType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoyaltyRateType* internal_default_instance() {
    return reinterpret_cast<const RoyaltyRateType*>(
               &_RoyaltyRateType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    148;

  friend void swap(RoyaltyRateType& a, RoyaltyRateType& b) {
    a.Swap(&b);
  }
  inline void Swap(RoyaltyRateType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoyaltyRateType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoyaltyRateType* New() const final {
    return CreateMaybeMessage<RoyaltyRateType>(nullptr);
  }

  RoyaltyRateType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoyaltyRateType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoyaltyRateType& from);
  void MergeFrom(const RoyaltyRateType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoyaltyRateType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.RoyaltyRateType";
  }
  protected:
  explicit RoyaltyRateType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.RoyaltyRateType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class SessionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.SessionType) */ {
 public:
  inline SessionType() : SessionType(nullptr) {}
  virtual ~SessionType();

  SessionType(const SessionType& from);
  SessionType(SessionType&& from) noexcept
    : SessionType() {
    *this = ::std::move(from);
  }

  inline SessionType& operator=(const SessionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionType& operator=(SessionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionType* internal_default_instance() {
    return reinterpret_cast<const SessionType*>(
               &_SessionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    149;

  friend void swap(SessionType& a, SessionType& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionType* New() const final {
    return CreateMaybeMessage<SessionType>(nullptr);
  }

  SessionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionType& from);
  void MergeFrom(const SessionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.SessionType";
  }
  protected:
  explicit SessionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.SessionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class SheetMusicCodecType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.SheetMusicCodecType) */ {
 public:
  inline SheetMusicCodecType() : SheetMusicCodecType(nullptr) {}
  virtual ~SheetMusicCodecType();

  SheetMusicCodecType(const SheetMusicCodecType& from);
  SheetMusicCodecType(SheetMusicCodecType&& from) noexcept
    : SheetMusicCodecType() {
    *this = ::std::move(from);
  }

  inline SheetMusicCodecType& operator=(const SheetMusicCodecType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SheetMusicCodecType& operator=(SheetMusicCodecType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SheetMusicCodecType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SheetMusicCodecType* internal_default_instance() {
    return reinterpret_cast<const SheetMusicCodecType*>(
               &_SheetMusicCodecType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    150;

  friend void swap(SheetMusicCodecType& a, SheetMusicCodecType& b) {
    a.Swap(&b);
  }
  inline void Swap(SheetMusicCodecType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SheetMusicCodecType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SheetMusicCodecType* New() const final {
    return CreateMaybeMessage<SheetMusicCodecType>(nullptr);
  }

  SheetMusicCodecType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SheetMusicCodecType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SheetMusicCodecType& from);
  void MergeFrom(const SheetMusicCodecType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SheetMusicCodecType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.SheetMusicCodecType";
  }
  protected:
  explicit SheetMusicCodecType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.SheetMusicCodecType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class SheetMusicType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.SheetMusicType) */ {
 public:
  inline SheetMusicType() : SheetMusicType(nullptr) {}
  virtual ~SheetMusicType();

  SheetMusicType(const SheetMusicType& from);
  SheetMusicType(SheetMusicType&& from) noexcept
    : SheetMusicType() {
    *this = ::std::move(from);
  }

  inline SheetMusicType& operator=(const SheetMusicType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SheetMusicType& operator=(SheetMusicType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SheetMusicType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SheetMusicType* internal_default_instance() {
    return reinterpret_cast<const SheetMusicType*>(
               &_SheetMusicType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    151;

  friend void swap(SheetMusicType& a, SheetMusicType& b) {
    a.Swap(&b);
  }
  inline void Swap(SheetMusicType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SheetMusicType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SheetMusicType* New() const final {
    return CreateMaybeMessage<SheetMusicType>(nullptr);
  }

  SheetMusicType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SheetMusicType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SheetMusicType& from);
  void MergeFrom(const SheetMusicType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SheetMusicType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.SheetMusicType";
  }
  protected:
  explicit SheetMusicType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.SheetMusicType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class SoftwareType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.SoftwareType) */ {
 public:
  inline SoftwareType() : SoftwareType(nullptr) {}
  virtual ~SoftwareType();

  SoftwareType(const SoftwareType& from);
  SoftwareType(SoftwareType&& from) noexcept
    : SoftwareType() {
    *this = ::std::move(from);
  }

  inline SoftwareType& operator=(const SoftwareType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoftwareType& operator=(SoftwareType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SoftwareType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SoftwareType* internal_default_instance() {
    return reinterpret_cast<const SoftwareType*>(
               &_SoftwareType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    152;

  friend void swap(SoftwareType& a, SoftwareType& b) {
    a.Swap(&b);
  }
  inline void Swap(SoftwareType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoftwareType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SoftwareType* New() const final {
    return CreateMaybeMessage<SoftwareType>(nullptr);
  }

  SoftwareType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SoftwareType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SoftwareType& from);
  void MergeFrom(const SoftwareType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoftwareType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.SoftwareType";
  }
  protected:
  explicit SoftwareType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.SoftwareType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class SoundRecordingType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.SoundRecordingType) */ {
 public:
  inline SoundRecordingType() : SoundRecordingType(nullptr) {}
  virtual ~SoundRecordingType();

  SoundRecordingType(const SoundRecordingType& from);
  SoundRecordingType(SoundRecordingType&& from) noexcept
    : SoundRecordingType() {
    *this = ::std::move(from);
  }

  inline SoundRecordingType& operator=(const SoundRecordingType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoundRecordingType& operator=(SoundRecordingType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SoundRecordingType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SoundRecordingType* internal_default_instance() {
    return reinterpret_cast<const SoundRecordingType*>(
               &_SoundRecordingType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    153;

  friend void swap(SoundRecordingType& a, SoundRecordingType& b) {
    a.Swap(&b);
  }
  inline void Swap(SoundRecordingType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoundRecordingType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SoundRecordingType* New() const final {
    return CreateMaybeMessage<SoundRecordingType>(nullptr);
  }

  SoundRecordingType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SoundRecordingType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SoundRecordingType& from);
  void MergeFrom(const SoundRecordingType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoundRecordingType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.SoundRecordingType";
  }
  protected:
  explicit SoundRecordingType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.SoundRecordingType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class Status PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  virtual ~Status();

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    154;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(nullptr);
  }

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class SubGenre PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.SubGenre) */ {
 public:
  inline SubGenre() : SubGenre(nullptr) {}
  virtual ~SubGenre();

  SubGenre(const SubGenre& from);
  SubGenre(SubGenre&& from) noexcept
    : SubGenre() {
    *this = ::std::move(from);
  }

  inline SubGenre& operator=(const SubGenre& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubGenre& operator=(SubGenre&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubGenre& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubGenre* internal_default_instance() {
    return reinterpret_cast<const SubGenre*>(
               &_SubGenre_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    155;

  friend void swap(SubGenre& a, SubGenre& b) {
    a.Swap(&b);
  }
  inline void Swap(SubGenre* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubGenre* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubGenre* New() const final {
    return CreateMaybeMessage<SubGenre>(nullptr);
  }

  SubGenre* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubGenre>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubGenre& from);
  void MergeFrom(const SubGenre& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubGenre* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.SubGenre";
  }
  protected:
  explicit SubGenre(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.SubGenre)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class SubTitleType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.SubTitleType) */ {
 public:
  inline SubTitleType() : SubTitleType(nullptr) {}
  virtual ~SubTitleType();

  SubTitleType(const SubTitleType& from);
  SubTitleType(SubTitleType&& from) noexcept
    : SubTitleType() {
    *this = ::std::move(from);
  }

  inline SubTitleType& operator=(const SubTitleType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubTitleType& operator=(SubTitleType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubTitleType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubTitleType* internal_default_instance() {
    return reinterpret_cast<const SubTitleType*>(
               &_SubTitleType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    156;

  friend void swap(SubTitleType& a, SubTitleType& b) {
    a.Swap(&b);
  }
  inline void Swap(SubTitleType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubTitleType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubTitleType* New() const final {
    return CreateMaybeMessage<SubTitleType>(nullptr);
  }

  SubTitleType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubTitleType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubTitleType& from);
  void MergeFrom(const SubTitleType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubTitleType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.SubTitleType";
  }
  protected:
  explicit SubTitleType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.SubTitleType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class SupplyChainStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.SupplyChainStatus) */ {
 public:
  inline SupplyChainStatus() : SupplyChainStatus(nullptr) {}
  virtual ~SupplyChainStatus();

  SupplyChainStatus(const SupplyChainStatus& from);
  SupplyChainStatus(SupplyChainStatus&& from) noexcept
    : SupplyChainStatus() {
    *this = ::std::move(from);
  }

  inline SupplyChainStatus& operator=(const SupplyChainStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupplyChainStatus& operator=(SupplyChainStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SupplyChainStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SupplyChainStatus* internal_default_instance() {
    return reinterpret_cast<const SupplyChainStatus*>(
               &_SupplyChainStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    157;

  friend void swap(SupplyChainStatus& a, SupplyChainStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SupplyChainStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupplyChainStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SupplyChainStatus* New() const final {
    return CreateMaybeMessage<SupplyChainStatus>(nullptr);
  }

  SupplyChainStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SupplyChainStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SupplyChainStatus& from);
  void MergeFrom(const SupplyChainStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SupplyChainStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.SupplyChainStatus";
  }
  protected:
  explicit SupplyChainStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.SupplyChainStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class Tempo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.Tempo) */ {
 public:
  inline Tempo() : Tempo(nullptr) {}
  virtual ~Tempo();

  Tempo(const Tempo& from);
  Tempo(Tempo&& from) noexcept
    : Tempo() {
    *this = ::std::move(from);
  }

  inline Tempo& operator=(const Tempo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tempo& operator=(Tempo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Tempo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tempo* internal_default_instance() {
    return reinterpret_cast<const Tempo*>(
               &_Tempo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    158;

  friend void swap(Tempo& a, Tempo& b) {
    a.Swap(&b);
  }
  inline void Swap(Tempo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tempo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tempo* New() const final {
    return CreateMaybeMessage<Tempo>(nullptr);
  }

  Tempo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tempo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Tempo& from);
  void MergeFrom(const Tempo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tempo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.Tempo";
  }
  protected:
  explicit Tempo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.Tempo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class TerritoryCodeType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.TerritoryCodeType) */ {
 public:
  inline TerritoryCodeType() : TerritoryCodeType(nullptr) {}
  virtual ~TerritoryCodeType();

  TerritoryCodeType(const TerritoryCodeType& from);
  TerritoryCodeType(TerritoryCodeType&& from) noexcept
    : TerritoryCodeType() {
    *this = ::std::move(from);
  }

  inline TerritoryCodeType& operator=(const TerritoryCodeType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerritoryCodeType& operator=(TerritoryCodeType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TerritoryCodeType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TerritoryCodeType* internal_default_instance() {
    return reinterpret_cast<const TerritoryCodeType*>(
               &_TerritoryCodeType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    159;

  friend void swap(TerritoryCodeType& a, TerritoryCodeType& b) {
    a.Swap(&b);
  }
  inline void Swap(TerritoryCodeType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerritoryCodeType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TerritoryCodeType* New() const final {
    return CreateMaybeMessage<TerritoryCodeType>(nullptr);
  }

  TerritoryCodeType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TerritoryCodeType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TerritoryCodeType& from);
  void MergeFrom(const TerritoryCodeType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerritoryCodeType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.TerritoryCodeType";
  }
  protected:
  explicit TerritoryCodeType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.TerritoryCodeType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class TerritoryCodeTypeIncludingDeprecatedCodes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.TerritoryCodeTypeIncludingDeprecatedCodes) */ {
 public:
  inline TerritoryCodeTypeIncludingDeprecatedCodes() : TerritoryCodeTypeIncludingDeprecatedCodes(nullptr) {}
  virtual ~TerritoryCodeTypeIncludingDeprecatedCodes();

  TerritoryCodeTypeIncludingDeprecatedCodes(const TerritoryCodeTypeIncludingDeprecatedCodes& from);
  TerritoryCodeTypeIncludingDeprecatedCodes(TerritoryCodeTypeIncludingDeprecatedCodes&& from) noexcept
    : TerritoryCodeTypeIncludingDeprecatedCodes() {
    *this = ::std::move(from);
  }

  inline TerritoryCodeTypeIncludingDeprecatedCodes& operator=(const TerritoryCodeTypeIncludingDeprecatedCodes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerritoryCodeTypeIncludingDeprecatedCodes& operator=(TerritoryCodeTypeIncludingDeprecatedCodes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TerritoryCodeTypeIncludingDeprecatedCodes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TerritoryCodeTypeIncludingDeprecatedCodes* internal_default_instance() {
    return reinterpret_cast<const TerritoryCodeTypeIncludingDeprecatedCodes*>(
               &_TerritoryCodeTypeIncludingDeprecatedCodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    160;

  friend void swap(TerritoryCodeTypeIncludingDeprecatedCodes& a, TerritoryCodeTypeIncludingDeprecatedCodes& b) {
    a.Swap(&b);
  }
  inline void Swap(TerritoryCodeTypeIncludingDeprecatedCodes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerritoryCodeTypeIncludingDeprecatedCodes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TerritoryCodeTypeIncludingDeprecatedCodes* New() const final {
    return CreateMaybeMessage<TerritoryCodeTypeIncludingDeprecatedCodes>(nullptr);
  }

  TerritoryCodeTypeIncludingDeprecatedCodes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TerritoryCodeTypeIncludingDeprecatedCodes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TerritoryCodeTypeIncludingDeprecatedCodes& from);
  void MergeFrom(const TerritoryCodeTypeIncludingDeprecatedCodes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerritoryCodeTypeIncludingDeprecatedCodes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.TerritoryCodeTypeIncludingDeprecatedCodes";
  }
  protected:
  explicit TerritoryCodeTypeIncludingDeprecatedCodes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.TerritoryCodeTypeIncludingDeprecatedCodes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class TextCodecType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.TextCodecType) */ {
 public:
  inline TextCodecType() : TextCodecType(nullptr) {}
  virtual ~TextCodecType();

  TextCodecType(const TextCodecType& from);
  TextCodecType(TextCodecType&& from) noexcept
    : TextCodecType() {
    *this = ::std::move(from);
  }

  inline TextCodecType& operator=(const TextCodecType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextCodecType& operator=(TextCodecType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TextCodecType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextCodecType* internal_default_instance() {
    return reinterpret_cast<const TextCodecType*>(
               &_TextCodecType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    161;

  friend void swap(TextCodecType& a, TextCodecType& b) {
    a.Swap(&b);
  }
  inline void Swap(TextCodecType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextCodecType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextCodecType* New() const final {
    return CreateMaybeMessage<TextCodecType>(nullptr);
  }

  TextCodecType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextCodecType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TextCodecType& from);
  void MergeFrom(const TextCodecType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextCodecType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.TextCodecType";
  }
  protected:
  explicit TextCodecType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.TextCodecType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class TextType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.TextType) */ {
 public:
  inline TextType() : TextType(nullptr) {}
  virtual ~TextType();

  TextType(const TextType& from);
  TextType(TextType&& from) noexcept
    : TextType() {
    *this = ::std::move(from);
  }

  inline TextType& operator=(const TextType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextType& operator=(TextType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TextType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextType* internal_default_instance() {
    return reinterpret_cast<const TextType*>(
               &_TextType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    162;

  friend void swap(TextType& a, TextType& b) {
    a.Swap(&b);
  }
  inline void Swap(TextType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextType* New() const final {
    return CreateMaybeMessage<TextType>(nullptr);
  }

  TextType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TextType& from);
  void MergeFrom(const TextType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.TextType";
  }
  protected:
  explicit TextType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.TextType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class TextType_ATOM PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.TextType_ATOM) */ {
 public:
  inline TextType_ATOM() : TextType_ATOM(nullptr) {}
  virtual ~TextType_ATOM();

  TextType_ATOM(const TextType_ATOM& from);
  TextType_ATOM(TextType_ATOM&& from) noexcept
    : TextType_ATOM() {
    *this = ::std::move(from);
  }

  inline TextType_ATOM& operator=(const TextType_ATOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextType_ATOM& operator=(TextType_ATOM&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TextType_ATOM& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextType_ATOM* internal_default_instance() {
    return reinterpret_cast<const TextType_ATOM*>(
               &_TextType_ATOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    163;

  friend void swap(TextType_ATOM& a, TextType_ATOM& b) {
    a.Swap(&b);
  }
  inline void Swap(TextType_ATOM* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextType_ATOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextType_ATOM* New() const final {
    return CreateMaybeMessage<TextType_ATOM>(nullptr);
  }

  TextType_ATOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextType_ATOM>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TextType_ATOM& from);
  void MergeFrom(const TextType_ATOM& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextType_ATOM* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.TextType_ATOM";
  }
  protected:
  explicit TextType_ATOM(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.TextType_ATOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class Theme PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.Theme) */ {
 public:
  inline Theme() : Theme(nullptr) {}
  virtual ~Theme();

  Theme(const Theme& from);
  Theme(Theme&& from) noexcept
    : Theme() {
    *this = ::std::move(from);
  }

  inline Theme& operator=(const Theme& from) {
    CopyFrom(from);
    return *this;
  }
  inline Theme& operator=(Theme&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Theme& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Theme* internal_default_instance() {
    return reinterpret_cast<const Theme*>(
               &_Theme_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    164;

  friend void swap(Theme& a, Theme& b) {
    a.Swap(&b);
  }
  inline void Swap(Theme* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Theme* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Theme* New() const final {
    return CreateMaybeMessage<Theme>(nullptr);
  }

  Theme* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Theme>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Theme& from);
  void MergeFrom(const Theme& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Theme* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.Theme";
  }
  protected:
  explicit Theme(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.Theme)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class ThemeType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.ThemeType) */ {
 public:
  inline ThemeType() : ThemeType(nullptr) {}
  virtual ~ThemeType();

  ThemeType(const ThemeType& from);
  ThemeType(ThemeType&& from) noexcept
    : ThemeType() {
    *this = ::std::move(from);
  }

  inline ThemeType& operator=(const ThemeType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThemeType& operator=(ThemeType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ThemeType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThemeType* internal_default_instance() {
    return reinterpret_cast<const ThemeType*>(
               &_ThemeType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    165;

  friend void swap(ThemeType& a, ThemeType& b) {
    a.Swap(&b);
  }
  inline void Swap(ThemeType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThemeType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThemeType* New() const final {
    return CreateMaybeMessage<ThemeType>(nullptr);
  }

  ThemeType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThemeType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThemeType& from);
  void MergeFrom(const ThemeType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThemeType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.ThemeType";
  }
  protected:
  explicit ThemeType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.ThemeType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class TimecodeType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.TimecodeType) */ {
 public:
  inline TimecodeType() : TimecodeType(nullptr) {}
  virtual ~TimecodeType();

  TimecodeType(const TimecodeType& from);
  TimecodeType(TimecodeType&& from) noexcept
    : TimecodeType() {
    *this = ::std::move(from);
  }

  inline TimecodeType& operator=(const TimecodeType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimecodeType& operator=(TimecodeType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TimecodeType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimecodeType* internal_default_instance() {
    return reinterpret_cast<const TimecodeType*>(
               &_TimecodeType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    166;

  friend void swap(TimecodeType& a, TimecodeType& b) {
    a.Swap(&b);
  }
  inline void Swap(TimecodeType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimecodeType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimecodeType* New() const final {
    return CreateMaybeMessage<TimecodeType>(nullptr);
  }

  TimecodeType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimecodeType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimecodeType& from);
  void MergeFrom(const TimecodeType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimecodeType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.TimecodeType";
  }
  protected:
  explicit TimecodeType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.TimecodeType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class TisTerritoryCode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.TisTerritoryCode) */ {
 public:
  inline TisTerritoryCode() : TisTerritoryCode(nullptr) {}
  virtual ~TisTerritoryCode();

  TisTerritoryCode(const TisTerritoryCode& from);
  TisTerritoryCode(TisTerritoryCode&& from) noexcept
    : TisTerritoryCode() {
    *this = ::std::move(from);
  }

  inline TisTerritoryCode& operator=(const TisTerritoryCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TisTerritoryCode& operator=(TisTerritoryCode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TisTerritoryCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TisTerritoryCode* internal_default_instance() {
    return reinterpret_cast<const TisTerritoryCode*>(
               &_TisTerritoryCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    167;

  friend void swap(TisTerritoryCode& a, TisTerritoryCode& b) {
    a.Swap(&b);
  }
  inline void Swap(TisTerritoryCode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TisTerritoryCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TisTerritoryCode* New() const final {
    return CreateMaybeMessage<TisTerritoryCode>(nullptr);
  }

  TisTerritoryCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TisTerritoryCode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TisTerritoryCode& from);
  void MergeFrom(const TisTerritoryCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TisTerritoryCode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.TisTerritoryCode";
  }
  protected:
  explicit TisTerritoryCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.TisTerritoryCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class TitleType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.TitleType) */ {
 public:
  inline TitleType() : TitleType(nullptr) {}
  virtual ~TitleType();

  TitleType(const TitleType& from);
  TitleType(TitleType&& from) noexcept
    : TitleType() {
    *this = ::std::move(from);
  }

  inline TitleType& operator=(const TitleType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TitleType& operator=(TitleType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TitleType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TitleType* internal_default_instance() {
    return reinterpret_cast<const TitleType*>(
               &_TitleType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    168;

  friend void swap(TitleType& a, TitleType& b) {
    a.Swap(&b);
  }
  inline void Swap(TitleType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TitleType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TitleType* New() const final {
    return CreateMaybeMessage<TitleType>(nullptr);
  }

  TitleType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TitleType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TitleType& from);
  void MergeFrom(const TitleType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TitleType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.TitleType";
  }
  protected:
  explicit TitleType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.TitleType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class TransferCategory PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.TransferCategory) */ {
 public:
  inline TransferCategory() : TransferCategory(nullptr) {}
  virtual ~TransferCategory();

  TransferCategory(const TransferCategory& from);
  TransferCategory(TransferCategory&& from) noexcept
    : TransferCategory() {
    *this = ::std::move(from);
  }

  inline TransferCategory& operator=(const TransferCategory& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferCategory& operator=(TransferCategory&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransferCategory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferCategory* internal_default_instance() {
    return reinterpret_cast<const TransferCategory*>(
               &_TransferCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    169;

  friend void swap(TransferCategory& a, TransferCategory& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferCategory* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferCategory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransferCategory* New() const final {
    return CreateMaybeMessage<TransferCategory>(nullptr);
  }

  TransferCategory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferCategory>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransferCategory& from);
  void MergeFrom(const TransferCategory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferCategory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.TransferCategory";
  }
  protected:
  explicit TransferCategory(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.TransferCategory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class TransferType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.TransferType) */ {
 public:
  inline TransferType() : TransferType(nullptr) {}
  virtual ~TransferType();

  TransferType(const TransferType& from);
  TransferType(TransferType&& from) noexcept
    : TransferType() {
    *this = ::std::move(from);
  }

  inline TransferType& operator=(const TransferType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferType& operator=(TransferType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransferType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferType* internal_default_instance() {
    return reinterpret_cast<const TransferType*>(
               &_TransferType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    170;

  friend void swap(TransferType& a, TransferType& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransferType* New() const final {
    return CreateMaybeMessage<TransferType>(nullptr);
  }

  TransferType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransferType& from);
  void MergeFrom(const TransferType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.TransferType";
  }
  protected:
  explicit TransferType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.TransferType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class UnitOfBitRate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.UnitOfBitRate) */ {
 public:
  inline UnitOfBitRate() : UnitOfBitRate(nullptr) {}
  virtual ~UnitOfBitRate();

  UnitOfBitRate(const UnitOfBitRate& from);
  UnitOfBitRate(UnitOfBitRate&& from) noexcept
    : UnitOfBitRate() {
    *this = ::std::move(from);
  }

  inline UnitOfBitRate& operator=(const UnitOfBitRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOfBitRate& operator=(UnitOfBitRate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitOfBitRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOfBitRate* internal_default_instance() {
    return reinterpret_cast<const UnitOfBitRate*>(
               &_UnitOfBitRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    171;

  friend void swap(UnitOfBitRate& a, UnitOfBitRate& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOfBitRate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOfBitRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitOfBitRate* New() const final {
    return CreateMaybeMessage<UnitOfBitRate>(nullptr);
  }

  UnitOfBitRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitOfBitRate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitOfBitRate& from);
  void MergeFrom(const UnitOfBitRate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOfBitRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.UnitOfBitRate";
  }
  protected:
  explicit UnitOfBitRate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.UnitOfBitRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class UnitOfConditionValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.UnitOfConditionValue) */ {
 public:
  inline UnitOfConditionValue() : UnitOfConditionValue(nullptr) {}
  virtual ~UnitOfConditionValue();

  UnitOfConditionValue(const UnitOfConditionValue& from);
  UnitOfConditionValue(UnitOfConditionValue&& from) noexcept
    : UnitOfConditionValue() {
    *this = ::std::move(from);
  }

  inline UnitOfConditionValue& operator=(const UnitOfConditionValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOfConditionValue& operator=(UnitOfConditionValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitOfConditionValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOfConditionValue* internal_default_instance() {
    return reinterpret_cast<const UnitOfConditionValue*>(
               &_UnitOfConditionValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    172;

  friend void swap(UnitOfConditionValue& a, UnitOfConditionValue& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOfConditionValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOfConditionValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitOfConditionValue* New() const final {
    return CreateMaybeMessage<UnitOfConditionValue>(nullptr);
  }

  UnitOfConditionValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitOfConditionValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitOfConditionValue& from);
  void MergeFrom(const UnitOfConditionValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOfConditionValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.UnitOfConditionValue";
  }
  protected:
  explicit UnitOfConditionValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.UnitOfConditionValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class UnitOfCuePoints PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.UnitOfCuePoints) */ {
 public:
  inline UnitOfCuePoints() : UnitOfCuePoints(nullptr) {}
  virtual ~UnitOfCuePoints();

  UnitOfCuePoints(const UnitOfCuePoints& from);
  UnitOfCuePoints(UnitOfCuePoints&& from) noexcept
    : UnitOfCuePoints() {
    *this = ::std::move(from);
  }

  inline UnitOfCuePoints& operator=(const UnitOfCuePoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOfCuePoints& operator=(UnitOfCuePoints&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitOfCuePoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOfCuePoints* internal_default_instance() {
    return reinterpret_cast<const UnitOfCuePoints*>(
               &_UnitOfCuePoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    173;

  friend void swap(UnitOfCuePoints& a, UnitOfCuePoints& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOfCuePoints* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOfCuePoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitOfCuePoints* New() const final {
    return CreateMaybeMessage<UnitOfCuePoints>(nullptr);
  }

  UnitOfCuePoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitOfCuePoints>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitOfCuePoints& from);
  void MergeFrom(const UnitOfCuePoints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOfCuePoints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.UnitOfCuePoints";
  }
  protected:
  explicit UnitOfCuePoints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.UnitOfCuePoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class UnitOfDuration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.UnitOfDuration) */ {
 public:
  inline UnitOfDuration() : UnitOfDuration(nullptr) {}
  virtual ~UnitOfDuration();

  UnitOfDuration(const UnitOfDuration& from);
  UnitOfDuration(UnitOfDuration&& from) noexcept
    : UnitOfDuration() {
    *this = ::std::move(from);
  }

  inline UnitOfDuration& operator=(const UnitOfDuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOfDuration& operator=(UnitOfDuration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitOfDuration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOfDuration* internal_default_instance() {
    return reinterpret_cast<const UnitOfDuration*>(
               &_UnitOfDuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    174;

  friend void swap(UnitOfDuration& a, UnitOfDuration& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOfDuration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOfDuration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitOfDuration* New() const final {
    return CreateMaybeMessage<UnitOfDuration>(nullptr);
  }

  UnitOfDuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitOfDuration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitOfDuration& from);
  void MergeFrom(const UnitOfDuration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOfDuration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.UnitOfDuration";
  }
  protected:
  explicit UnitOfDuration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.UnitOfDuration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class UnitOfExtent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.UnitOfExtent) */ {
 public:
  inline UnitOfExtent() : UnitOfExtent(nullptr) {}
  virtual ~UnitOfExtent();

  UnitOfExtent(const UnitOfExtent& from);
  UnitOfExtent(UnitOfExtent&& from) noexcept
    : UnitOfExtent() {
    *this = ::std::move(from);
  }

  inline UnitOfExtent& operator=(const UnitOfExtent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOfExtent& operator=(UnitOfExtent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitOfExtent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOfExtent* internal_default_instance() {
    return reinterpret_cast<const UnitOfExtent*>(
               &_UnitOfExtent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    175;

  friend void swap(UnitOfExtent& a, UnitOfExtent& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOfExtent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOfExtent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitOfExtent* New() const final {
    return CreateMaybeMessage<UnitOfExtent>(nullptr);
  }

  UnitOfExtent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitOfExtent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitOfExtent& from);
  void MergeFrom(const UnitOfExtent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOfExtent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.UnitOfExtent";
  }
  protected:
  explicit UnitOfExtent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.UnitOfExtent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class UnitOfFrameRate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.UnitOfFrameRate) */ {
 public:
  inline UnitOfFrameRate() : UnitOfFrameRate(nullptr) {}
  virtual ~UnitOfFrameRate();

  UnitOfFrameRate(const UnitOfFrameRate& from);
  UnitOfFrameRate(UnitOfFrameRate&& from) noexcept
    : UnitOfFrameRate() {
    *this = ::std::move(from);
  }

  inline UnitOfFrameRate& operator=(const UnitOfFrameRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOfFrameRate& operator=(UnitOfFrameRate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitOfFrameRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOfFrameRate* internal_default_instance() {
    return reinterpret_cast<const UnitOfFrameRate*>(
               &_UnitOfFrameRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    176;

  friend void swap(UnitOfFrameRate& a, UnitOfFrameRate& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOfFrameRate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOfFrameRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitOfFrameRate* New() const final {
    return CreateMaybeMessage<UnitOfFrameRate>(nullptr);
  }

  UnitOfFrameRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitOfFrameRate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitOfFrameRate& from);
  void MergeFrom(const UnitOfFrameRate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOfFrameRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.UnitOfFrameRate";
  }
  protected:
  explicit UnitOfFrameRate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.UnitOfFrameRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class UnitOfFrequency PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.UnitOfFrequency) */ {
 public:
  inline UnitOfFrequency() : UnitOfFrequency(nullptr) {}
  virtual ~UnitOfFrequency();

  UnitOfFrequency(const UnitOfFrequency& from);
  UnitOfFrequency(UnitOfFrequency&& from) noexcept
    : UnitOfFrequency() {
    *this = ::std::move(from);
  }

  inline UnitOfFrequency& operator=(const UnitOfFrequency& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOfFrequency& operator=(UnitOfFrequency&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitOfFrequency& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitOfFrequency* internal_default_instance() {
    return reinterpret_cast<const UnitOfFrequency*>(
               &_UnitOfFrequency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    177;

  friend void swap(UnitOfFrequency& a, UnitOfFrequency& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOfFrequency* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOfFrequency* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitOfFrequency* New() const final {
    return CreateMaybeMessage<UnitOfFrequency>(nullptr);
  }

  UnitOfFrequency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitOfFrequency>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitOfFrequency& from);
  void MergeFrom(const UnitOfFrequency& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOfFrequency* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.UnitOfFrequency";
  }
  protected:
  explicit UnitOfFrequency(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.UnitOfFrequency)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class UseType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.UseType) */ {
 public:
  inline UseType() : UseType(nullptr) {}
  virtual ~UseType();

  UseType(const UseType& from);
  UseType(UseType&& from) noexcept
    : UseType() {
    *this = ::std::move(from);
  }

  inline UseType& operator=(const UseType& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseType& operator=(UseType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UseType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UseType* internal_default_instance() {
    return reinterpret_cast<const UseType*>(
               &_UseType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    178;

  friend void swap(UseType& a, UseType& b) {
    a.Swap(&b);
  }
  inline void Swap(UseType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UseType* New() const final {
    return CreateMaybeMessage<UseType>(nullptr);
  }

  UseType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UseType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UseType& from);
  void MergeFrom(const UseType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UseType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.UseType";
  }
  protected:
  explicit UseType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.UseType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class UseType_MLC PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.UseType_MLC) */ {
 public:
  inline UseType_MLC() : UseType_MLC(nullptr) {}
  virtual ~UseType_MLC();

  UseType_MLC(const UseType_MLC& from);
  UseType_MLC(UseType_MLC&& from) noexcept
    : UseType_MLC() {
    *this = ::std::move(from);
  }

  inline UseType_MLC& operator=(const UseType_MLC& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseType_MLC& operator=(UseType_MLC&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UseType_MLC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UseType_MLC* internal_default_instance() {
    return reinterpret_cast<const UseType_MLC*>(
               &_UseType_MLC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    179;

  friend void swap(UseType_MLC& a, UseType_MLC& b) {
    a.Swap(&b);
  }
  inline void Swap(UseType_MLC* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseType_MLC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UseType_MLC* New() const final {
    return CreateMaybeMessage<UseType_MLC>(nullptr);
  }

  UseType_MLC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UseType_MLC>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UseType_MLC& from);
  void MergeFrom(const UseType_MLC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UseType_MLC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.UseType_MLC";
  }
  protected:
  explicit UseType_MLC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.UseType_MLC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class UseType_MWNL PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.UseType_MWNL) */ {
 public:
  inline UseType_MWNL() : UseType_MWNL(nullptr) {}
  virtual ~UseType_MWNL();

  UseType_MWNL(const UseType_MWNL& from);
  UseType_MWNL(UseType_MWNL&& from) noexcept
    : UseType_MWNL() {
    *this = ::std::move(from);
  }

  inline UseType_MWNL& operator=(const UseType_MWNL& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseType_MWNL& operator=(UseType_MWNL&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UseType_MWNL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UseType_MWNL* internal_default_instance() {
    return reinterpret_cast<const UseType_MWNL*>(
               &_UseType_MWNL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    180;

  friend void swap(UseType_MWNL& a, UseType_MWNL& b) {
    a.Swap(&b);
  }
  inline void Swap(UseType_MWNL* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseType_MWNL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UseType_MWNL* New() const final {
    return CreateMaybeMessage<UseType_MWNL>(nullptr);
  }

  UseType_MWNL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UseType_MWNL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UseType_MWNL& from);
  void MergeFrom(const UseType_MWNL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UseType_MWNL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.UseType_MWNL";
  }
  protected:
  explicit UseType_MWNL(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.UseType_MWNL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class UserInterfaceType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.UserInterfaceType) */ {
 public:
  inline UserInterfaceType() : UserInterfaceType(nullptr) {}
  virtual ~UserInterfaceType();

  UserInterfaceType(const UserInterfaceType& from);
  UserInterfaceType(UserInterfaceType&& from) noexcept
    : UserInterfaceType() {
    *this = ::std::move(from);
  }

  inline UserInterfaceType& operator=(const UserInterfaceType& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInterfaceType& operator=(UserInterfaceType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserInterfaceType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserInterfaceType* internal_default_instance() {
    return reinterpret_cast<const UserInterfaceType*>(
               &_UserInterfaceType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    181;

  friend void swap(UserInterfaceType& a, UserInterfaceType& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInterfaceType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInterfaceType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserInterfaceType* New() const final {
    return CreateMaybeMessage<UserInterfaceType>(nullptr);
  }

  UserInterfaceType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserInterfaceType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserInterfaceType& from);
  void MergeFrom(const UserInterfaceType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInterfaceType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.UserInterfaceType";
  }
  protected:
  explicit UserInterfaceType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.UserInterfaceType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class VersionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.VersionType) */ {
 public:
  inline VersionType() : VersionType(nullptr) {}
  virtual ~VersionType();

  VersionType(const VersionType& from);
  VersionType(VersionType&& from) noexcept
    : VersionType() {
    *this = ::std::move(from);
  }

  inline VersionType& operator=(const VersionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionType& operator=(VersionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VersionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionType* internal_default_instance() {
    return reinterpret_cast<const VersionType*>(
               &_VersionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    182;

  friend void swap(VersionType& a, VersionType& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VersionType* New() const final {
    return CreateMaybeMessage<VersionType>(nullptr);
  }

  VersionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VersionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VersionType& from);
  void MergeFrom(const VersionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.VersionType";
  }
  protected:
  explicit VersionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.VersionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class VideoCodecType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.VideoCodecType) */ {
 public:
  inline VideoCodecType() : VideoCodecType(nullptr) {}
  virtual ~VideoCodecType();

  VideoCodecType(const VideoCodecType& from);
  VideoCodecType(VideoCodecType&& from) noexcept
    : VideoCodecType() {
    *this = ::std::move(from);
  }

  inline VideoCodecType& operator=(const VideoCodecType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoCodecType& operator=(VideoCodecType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoCodecType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoCodecType* internal_default_instance() {
    return reinterpret_cast<const VideoCodecType*>(
               &_VideoCodecType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    183;

  friend void swap(VideoCodecType& a, VideoCodecType& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoCodecType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoCodecType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoCodecType* New() const final {
    return CreateMaybeMessage<VideoCodecType>(nullptr);
  }

  VideoCodecType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoCodecType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoCodecType& from);
  void MergeFrom(const VideoCodecType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoCodecType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.VideoCodecType";
  }
  protected:
  explicit VideoCodecType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.VideoCodecType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class VideoDefinitionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.VideoDefinitionType) */ {
 public:
  inline VideoDefinitionType() : VideoDefinitionType(nullptr) {}
  virtual ~VideoDefinitionType();

  VideoDefinitionType(const VideoDefinitionType& from);
  VideoDefinitionType(VideoDefinitionType&& from) noexcept
    : VideoDefinitionType() {
    *this = ::std::move(from);
  }

  inline VideoDefinitionType& operator=(const VideoDefinitionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoDefinitionType& operator=(VideoDefinitionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoDefinitionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoDefinitionType* internal_default_instance() {
    return reinterpret_cast<const VideoDefinitionType*>(
               &_VideoDefinitionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    184;

  friend void swap(VideoDefinitionType& a, VideoDefinitionType& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoDefinitionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoDefinitionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoDefinitionType* New() const final {
    return CreateMaybeMessage<VideoDefinitionType>(nullptr);
  }

  VideoDefinitionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoDefinitionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoDefinitionType& from);
  void MergeFrom(const VideoDefinitionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoDefinitionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.VideoDefinitionType";
  }
  protected:
  explicit VideoDefinitionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.VideoDefinitionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class VideoType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.VideoType) */ {
 public:
  inline VideoType() : VideoType(nullptr) {}
  virtual ~VideoType();

  VideoType(const VideoType& from);
  VideoType(VideoType&& from) noexcept
    : VideoType() {
    *this = ::std::move(from);
  }

  inline VideoType& operator=(const VideoType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoType& operator=(VideoType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoType* internal_default_instance() {
    return reinterpret_cast<const VideoType*>(
               &_VideoType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    185;

  friend void swap(VideoType& a, VideoType& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoType* New() const final {
    return CreateMaybeMessage<VideoType>(nullptr);
  }

  VideoType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoType& from);
  void MergeFrom(const VideoType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.VideoType";
  }
  protected:
  explicit VideoType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.VideoType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class VideoType_DSRF PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.VideoType_DSRF) */ {
 public:
  inline VideoType_DSRF() : VideoType_DSRF(nullptr) {}
  virtual ~VideoType_DSRF();

  VideoType_DSRF(const VideoType_DSRF& from);
  VideoType_DSRF(VideoType_DSRF&& from) noexcept
    : VideoType_DSRF() {
    *this = ::std::move(from);
  }

  inline VideoType_DSRF& operator=(const VideoType_DSRF& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoType_DSRF& operator=(VideoType_DSRF&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoType_DSRF& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoType_DSRF* internal_default_instance() {
    return reinterpret_cast<const VideoType_DSRF*>(
               &_VideoType_DSRF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    186;

  friend void swap(VideoType_DSRF& a, VideoType_DSRF& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoType_DSRF* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoType_DSRF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoType_DSRF* New() const final {
    return CreateMaybeMessage<VideoType_DSRF>(nullptr);
  }

  VideoType_DSRF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoType_DSRF>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoType_DSRF& from);
  void MergeFrom(const VideoType_DSRF& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoType_DSRF* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.VideoType_DSRF";
  }
  protected:
  explicit VideoType_DSRF(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.VideoType_DSRF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class VisualPerceptionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.VisualPerceptionType) */ {
 public:
  inline VisualPerceptionType() : VisualPerceptionType(nullptr) {}
  virtual ~VisualPerceptionType();

  VisualPerceptionType(const VisualPerceptionType& from);
  VisualPerceptionType(VisualPerceptionType&& from) noexcept
    : VisualPerceptionType() {
    *this = ::std::move(from);
  }

  inline VisualPerceptionType& operator=(const VisualPerceptionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisualPerceptionType& operator=(VisualPerceptionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VisualPerceptionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VisualPerceptionType* internal_default_instance() {
    return reinterpret_cast<const VisualPerceptionType*>(
               &_VisualPerceptionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    187;

  friend void swap(VisualPerceptionType& a, VisualPerceptionType& b) {
    a.Swap(&b);
  }
  inline void Swap(VisualPerceptionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisualPerceptionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VisualPerceptionType* New() const final {
    return CreateMaybeMessage<VisualPerceptionType>(nullptr);
  }

  VisualPerceptionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VisualPerceptionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VisualPerceptionType& from);
  void MergeFrom(const VisualPerceptionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisualPerceptionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.VisualPerceptionType";
  }
  protected:
  explicit VisualPerceptionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.VisualPerceptionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class VocalRegister PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.VocalRegister) */ {
 public:
  inline VocalRegister() : VocalRegister(nullptr) {}
  virtual ~VocalRegister();

  VocalRegister(const VocalRegister& from);
  VocalRegister(VocalRegister&& from) noexcept
    : VocalRegister() {
    *this = ::std::move(from);
  }

  inline VocalRegister& operator=(const VocalRegister& from) {
    CopyFrom(from);
    return *this;
  }
  inline VocalRegister& operator=(VocalRegister&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VocalRegister& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VocalRegister* internal_default_instance() {
    return reinterpret_cast<const VocalRegister*>(
               &_VocalRegister_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    188;

  friend void swap(VocalRegister& a, VocalRegister& b) {
    a.Swap(&b);
  }
  inline void Swap(VocalRegister* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VocalRegister* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VocalRegister* New() const final {
    return CreateMaybeMessage<VocalRegister>(nullptr);
  }

  VocalRegister* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VocalRegister>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VocalRegister& from);
  void MergeFrom(const VocalRegister& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VocalRegister* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.VocalRegister";
  }
  protected:
  explicit VocalRegister(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.VocalRegister)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class VocalType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.VocalType) */ {
 public:
  inline VocalType() : VocalType(nullptr) {}
  virtual ~VocalType();

  VocalType(const VocalType& from);
  VocalType(VocalType&& from) noexcept
    : VocalType() {
    *this = ::std::move(from);
  }

  inline VocalType& operator=(const VocalType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VocalType& operator=(VocalType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VocalType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VocalType* internal_default_instance() {
    return reinterpret_cast<const VocalType*>(
               &_VocalType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    189;

  friend void swap(VocalType& a, VocalType& b) {
    a.Swap(&b);
  }
  inline void Swap(VocalType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VocalType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VocalType* New() const final {
    return CreateMaybeMessage<VocalType>(nullptr);
  }

  VocalType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VocalType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VocalType& from);
  void MergeFrom(const VocalType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VocalType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.VocalType";
  }
  protected:
  explicit VocalType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.VocalType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// -------------------------------------------------------------------

class WorkRelationshipType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mead101.avs.WorkRelationshipType) */ {
 public:
  inline WorkRelationshipType() : WorkRelationshipType(nullptr) {}
  virtual ~WorkRelationshipType();

  WorkRelationshipType(const WorkRelationshipType& from);
  WorkRelationshipType(WorkRelationshipType&& from) noexcept
    : WorkRelationshipType() {
    *this = ::std::move(from);
  }

  inline WorkRelationshipType& operator=(const WorkRelationshipType& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkRelationshipType& operator=(WorkRelationshipType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkRelationshipType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkRelationshipType* internal_default_instance() {
    return reinterpret_cast<const WorkRelationshipType*>(
               &_WorkRelationshipType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    190;

  friend void swap(WorkRelationshipType& a, WorkRelationshipType& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkRelationshipType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkRelationshipType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkRelationshipType* New() const final {
    return CreateMaybeMessage<WorkRelationshipType>(nullptr);
  }

  WorkRelationshipType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkRelationshipType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkRelationshipType& from);
  void MergeFrom(const WorkRelationshipType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkRelationshipType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mead101.avs.WorkRelationshipType";
  }
  protected:
  explicit WorkRelationshipType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto);
    return ::descriptor_table_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumValueFieldNumber = 1,
  };
  // optional string enum_value = 1;
  bool has_enum_value() const;
  private:
  bool _internal_has_enum_value() const;
  public:
  void clear_enum_value();
  const std::string& enum_value() const;
  void set_enum_value(const std::string& value);
  void set_enum_value(std::string&& value);
  void set_enum_value(const char* value);
  void set_enum_value(const char* value, size_t size);
  std::string* mutable_enum_value();
  std::string* release_enum_value();
  void set_allocated_enum_value(std::string* enum_value);
  private:
  const std::string& _internal_enum_value() const;
  void _internal_set_enum_value(const std::string& value);
  std::string* _internal_mutable_enum_value();
  public:

  // @@protoc_insertion_point(class_scope:mead101.avs.WorkRelationshipType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enum_value_;
  friend struct ::TableStruct_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AdditionalTitleType

// optional string enum_value = 1;
inline bool AdditionalTitleType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdditionalTitleType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AdditionalTitleType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdditionalTitleType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.AdditionalTitleType.enum_value)
  return _internal_enum_value();
}
inline void AdditionalTitleType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.AdditionalTitleType.enum_value)
}
inline std::string* AdditionalTitleType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.AdditionalTitleType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AdditionalTitleType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AdditionalTitleType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AdditionalTitleType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.AdditionalTitleType.enum_value)
}
inline void AdditionalTitleType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.AdditionalTitleType.enum_value)
}
inline void AdditionalTitleType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.AdditionalTitleType.enum_value)
}
inline std::string* AdditionalTitleType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AdditionalTitleType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.AdditionalTitleType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AdditionalTitleType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.AdditionalTitleType.enum_value)
}

// -------------------------------------------------------------------

// AdditionalUseType

// optional string enum_value = 1;
inline bool AdditionalUseType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdditionalUseType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AdditionalUseType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdditionalUseType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.AdditionalUseType.enum_value)
  return _internal_enum_value();
}
inline void AdditionalUseType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.AdditionalUseType.enum_value)
}
inline std::string* AdditionalUseType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.AdditionalUseType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AdditionalUseType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AdditionalUseType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AdditionalUseType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.AdditionalUseType.enum_value)
}
inline void AdditionalUseType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.AdditionalUseType.enum_value)
}
inline void AdditionalUseType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.AdditionalUseType.enum_value)
}
inline std::string* AdditionalUseType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AdditionalUseType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.AdditionalUseType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AdditionalUseType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.AdditionalUseType.enum_value)
}

// -------------------------------------------------------------------

// AdditionalVideoType

// optional string enum_value = 1;
inline bool AdditionalVideoType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdditionalVideoType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AdditionalVideoType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdditionalVideoType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.AdditionalVideoType.enum_value)
  return _internal_enum_value();
}
inline void AdditionalVideoType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.AdditionalVideoType.enum_value)
}
inline std::string* AdditionalVideoType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.AdditionalVideoType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AdditionalVideoType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AdditionalVideoType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AdditionalVideoType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.AdditionalVideoType.enum_value)
}
inline void AdditionalVideoType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.AdditionalVideoType.enum_value)
}
inline void AdditionalVideoType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.AdditionalVideoType.enum_value)
}
inline std::string* AdditionalVideoType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AdditionalVideoType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.AdditionalVideoType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AdditionalVideoType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.AdditionalVideoType.enum_value)
}

// -------------------------------------------------------------------

// AdministratingRecordCompanyRole

// optional string enum_value = 1;
inline bool AdministratingRecordCompanyRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdministratingRecordCompanyRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AdministratingRecordCompanyRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdministratingRecordCompanyRole::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.AdministratingRecordCompanyRole.enum_value)
  return _internal_enum_value();
}
inline void AdministratingRecordCompanyRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.AdministratingRecordCompanyRole.enum_value)
}
inline std::string* AdministratingRecordCompanyRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.AdministratingRecordCompanyRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AdministratingRecordCompanyRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AdministratingRecordCompanyRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AdministratingRecordCompanyRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.AdministratingRecordCompanyRole.enum_value)
}
inline void AdministratingRecordCompanyRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.AdministratingRecordCompanyRole.enum_value)
}
inline void AdministratingRecordCompanyRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.AdministratingRecordCompanyRole.enum_value)
}
inline std::string* AdministratingRecordCompanyRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AdministratingRecordCompanyRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.AdministratingRecordCompanyRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AdministratingRecordCompanyRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.AdministratingRecordCompanyRole.enum_value)
}

// -------------------------------------------------------------------

// AffiliationType

// optional string enum_value = 1;
inline bool AffiliationType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AffiliationType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AffiliationType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AffiliationType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.AffiliationType.enum_value)
  return _internal_enum_value();
}
inline void AffiliationType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.AffiliationType.enum_value)
}
inline std::string* AffiliationType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.AffiliationType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AffiliationType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AffiliationType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AffiliationType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.AffiliationType.enum_value)
}
inline void AffiliationType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.AffiliationType.enum_value)
}
inline void AffiliationType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.AffiliationType.enum_value)
}
inline std::string* AffiliationType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AffiliationType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.AffiliationType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AffiliationType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.AffiliationType.enum_value)
}

// -------------------------------------------------------------------

// AllTerritoryCode

// optional string enum_value = 1;
inline bool AllTerritoryCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllTerritoryCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AllTerritoryCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AllTerritoryCode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.AllTerritoryCode.enum_value)
  return _internal_enum_value();
}
inline void AllTerritoryCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.AllTerritoryCode.enum_value)
}
inline std::string* AllTerritoryCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.AllTerritoryCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AllTerritoryCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AllTerritoryCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AllTerritoryCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.AllTerritoryCode.enum_value)
}
inline void AllTerritoryCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.AllTerritoryCode.enum_value)
}
inline void AllTerritoryCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.AllTerritoryCode.enum_value)
}
inline std::string* AllTerritoryCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AllTerritoryCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.AllTerritoryCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AllTerritoryCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.AllTerritoryCode.enum_value)
}

// -------------------------------------------------------------------

// ArtistRole

// optional string enum_value = 1;
inline bool ArtistRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtistRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ArtistRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ArtistRole::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ArtistRole.enum_value)
  return _internal_enum_value();
}
inline void ArtistRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ArtistRole.enum_value)
}
inline std::string* ArtistRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ArtistRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ArtistRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ArtistRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ArtistRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ArtistRole.enum_value)
}
inline void ArtistRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ArtistRole.enum_value)
}
inline void ArtistRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ArtistRole.enum_value)
}
inline std::string* ArtistRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ArtistRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ArtistRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ArtistRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ArtistRole.enum_value)
}

// -------------------------------------------------------------------

// ArtistType

// optional string enum_value = 1;
inline bool ArtistType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtistType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ArtistType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ArtistType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ArtistType.enum_value)
  return _internal_enum_value();
}
inline void ArtistType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ArtistType.enum_value)
}
inline std::string* ArtistType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ArtistType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ArtistType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ArtistType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ArtistType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ArtistType.enum_value)
}
inline void ArtistType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ArtistType.enum_value)
}
inline void ArtistType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ArtistType.enum_value)
}
inline std::string* ArtistType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ArtistType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ArtistType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ArtistType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ArtistType.enum_value)
}

// -------------------------------------------------------------------

// AspectRatioType

// optional string enum_value = 1;
inline bool AspectRatioType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AspectRatioType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AspectRatioType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AspectRatioType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.AspectRatioType.enum_value)
  return _internal_enum_value();
}
inline void AspectRatioType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.AspectRatioType.enum_value)
}
inline std::string* AspectRatioType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.AspectRatioType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AspectRatioType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AspectRatioType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AspectRatioType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.AspectRatioType.enum_value)
}
inline void AspectRatioType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.AspectRatioType.enum_value)
}
inline void AspectRatioType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.AspectRatioType.enum_value)
}
inline std::string* AspectRatioType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AspectRatioType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.AspectRatioType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AspectRatioType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.AspectRatioType.enum_value)
}

// -------------------------------------------------------------------

// AsserterType

// optional string enum_value = 1;
inline bool AsserterType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AsserterType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AsserterType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AsserterType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.AsserterType.enum_value)
  return _internal_enum_value();
}
inline void AsserterType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.AsserterType.enum_value)
}
inline std::string* AsserterType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.AsserterType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AsserterType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AsserterType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AsserterType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.AsserterType.enum_value)
}
inline void AsserterType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.AsserterType.enum_value)
}
inline void AsserterType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.AsserterType.enum_value)
}
inline std::string* AsserterType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AsserterType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.AsserterType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AsserterType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.AsserterType.enum_value)
}

// -------------------------------------------------------------------

// AudioCodecType

// optional string enum_value = 1;
inline bool AudioCodecType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioCodecType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AudioCodecType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioCodecType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.AudioCodecType.enum_value)
  return _internal_enum_value();
}
inline void AudioCodecType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.AudioCodecType.enum_value)
}
inline std::string* AudioCodecType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.AudioCodecType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AudioCodecType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AudioCodecType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AudioCodecType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.AudioCodecType.enum_value)
}
inline void AudioCodecType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.AudioCodecType.enum_value)
}
inline void AudioCodecType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.AudioCodecType.enum_value)
}
inline std::string* AudioCodecType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AudioCodecType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.AudioCodecType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioCodecType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.AudioCodecType.enum_value)
}

// -------------------------------------------------------------------

// AvsVersionId

// optional string enum_value = 1;
inline bool AvsVersionId::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AvsVersionId::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void AvsVersionId::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AvsVersionId::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.AvsVersionId.enum_value)
  return _internal_enum_value();
}
inline void AvsVersionId::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.AvsVersionId.enum_value)
}
inline std::string* AvsVersionId::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.AvsVersionId.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& AvsVersionId::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void AvsVersionId::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AvsVersionId::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.AvsVersionId.enum_value)
}
inline void AvsVersionId::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.AvsVersionId.enum_value)
}
inline void AvsVersionId::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.AvsVersionId.enum_value)
}
inline std::string* AvsVersionId::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AvsVersionId::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.AvsVersionId.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AvsVersionId::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.AvsVersionId.enum_value)
}

// -------------------------------------------------------------------

// BinaryDataType

// optional string enum_value = 1;
inline bool BinaryDataType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BinaryDataType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void BinaryDataType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BinaryDataType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.BinaryDataType.enum_value)
  return _internal_enum_value();
}
inline void BinaryDataType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.BinaryDataType.enum_value)
}
inline std::string* BinaryDataType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.BinaryDataType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& BinaryDataType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void BinaryDataType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BinaryDataType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.BinaryDataType.enum_value)
}
inline void BinaryDataType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.BinaryDataType.enum_value)
}
inline void BinaryDataType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.BinaryDataType.enum_value)
}
inline std::string* BinaryDataType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BinaryDataType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.BinaryDataType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BinaryDataType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.BinaryDataType.enum_value)
}

// -------------------------------------------------------------------

// BusinessMusicalWorkContributorRole

// optional string enum_value = 1;
inline bool BusinessMusicalWorkContributorRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BusinessMusicalWorkContributorRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void BusinessMusicalWorkContributorRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BusinessMusicalWorkContributorRole::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.BusinessMusicalWorkContributorRole.enum_value)
  return _internal_enum_value();
}
inline void BusinessMusicalWorkContributorRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.BusinessMusicalWorkContributorRole.enum_value)
}
inline std::string* BusinessMusicalWorkContributorRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.BusinessMusicalWorkContributorRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& BusinessMusicalWorkContributorRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void BusinessMusicalWorkContributorRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BusinessMusicalWorkContributorRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.BusinessMusicalWorkContributorRole.enum_value)
}
inline void BusinessMusicalWorkContributorRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.BusinessMusicalWorkContributorRole.enum_value)
}
inline void BusinessMusicalWorkContributorRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.BusinessMusicalWorkContributorRole.enum_value)
}
inline std::string* BusinessMusicalWorkContributorRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BusinessMusicalWorkContributorRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.BusinessMusicalWorkContributorRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BusinessMusicalWorkContributorRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.BusinessMusicalWorkContributorRole.enum_value)
}

// -------------------------------------------------------------------

// CarrierType

// optional string enum_value = 1;
inline bool CarrierType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CarrierType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CarrierType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CarrierType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CarrierType.enum_value)
  return _internal_enum_value();
}
inline void CarrierType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CarrierType.enum_value)
}
inline std::string* CarrierType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CarrierType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CarrierType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CarrierType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CarrierType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CarrierType.enum_value)
}
inline void CarrierType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CarrierType.enum_value)
}
inline void CarrierType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CarrierType.enum_value)
}
inline std::string* CarrierType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CarrierType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CarrierType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CarrierType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CarrierType.enum_value)
}

// -------------------------------------------------------------------

// CatalogTransferType

// optional string enum_value = 1;
inline bool CatalogTransferType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CatalogTransferType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CatalogTransferType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CatalogTransferType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CatalogTransferType.enum_value)
  return _internal_enum_value();
}
inline void CatalogTransferType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CatalogTransferType.enum_value)
}
inline std::string* CatalogTransferType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CatalogTransferType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CatalogTransferType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CatalogTransferType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CatalogTransferType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CatalogTransferType.enum_value)
}
inline void CatalogTransferType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CatalogTransferType.enum_value)
}
inline void CatalogTransferType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CatalogTransferType.enum_value)
}
inline std::string* CatalogTransferType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CatalogTransferType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CatalogTransferType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CatalogTransferType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CatalogTransferType.enum_value)
}

// -------------------------------------------------------------------

// CdProtectionType

// optional string enum_value = 1;
inline bool CdProtectionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CdProtectionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CdProtectionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdProtectionType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CdProtectionType.enum_value)
  return _internal_enum_value();
}
inline void CdProtectionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CdProtectionType.enum_value)
}
inline std::string* CdProtectionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CdProtectionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CdProtectionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CdProtectionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CdProtectionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CdProtectionType.enum_value)
}
inline void CdProtectionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CdProtectionType.enum_value)
}
inline void CdProtectionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CdProtectionType.enum_value)
}
inline std::string* CdProtectionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CdProtectionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CdProtectionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CdProtectionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CdProtectionType.enum_value)
}

// -------------------------------------------------------------------

// CharacterType

// optional string enum_value = 1;
inline bool CharacterType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CharacterType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CharacterType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CharacterType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CharacterType.enum_value)
  return _internal_enum_value();
}
inline void CharacterType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CharacterType.enum_value)
}
inline std::string* CharacterType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CharacterType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CharacterType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CharacterType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CharacterType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CharacterType.enum_value)
}
inline void CharacterType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CharacterType.enum_value)
}
inline void CharacterType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CharacterType.enum_value)
}
inline std::string* CharacterType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CharacterType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CharacterType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CharacterType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CharacterType.enum_value)
}

// -------------------------------------------------------------------

// ClaimStatus

// optional string enum_value = 1;
inline bool ClaimStatus::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClaimStatus::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ClaimStatus::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClaimStatus::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ClaimStatus.enum_value)
  return _internal_enum_value();
}
inline void ClaimStatus::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ClaimStatus.enum_value)
}
inline std::string* ClaimStatus::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ClaimStatus.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ClaimStatus::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ClaimStatus::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClaimStatus::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ClaimStatus.enum_value)
}
inline void ClaimStatus::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ClaimStatus.enum_value)
}
inline void ClaimStatus::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ClaimStatus.enum_value)
}
inline std::string* ClaimStatus::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClaimStatus::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ClaimStatus.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClaimStatus::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ClaimStatus.enum_value)
}

// -------------------------------------------------------------------

// ClassifiedGenre

// optional string enum_value = 1;
inline bool ClassifiedGenre::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClassifiedGenre::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ClassifiedGenre::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClassifiedGenre::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ClassifiedGenre.enum_value)
  return _internal_enum_value();
}
inline void ClassifiedGenre::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ClassifiedGenre.enum_value)
}
inline std::string* ClassifiedGenre::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ClassifiedGenre.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ClassifiedGenre::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ClassifiedGenre::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClassifiedGenre::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ClassifiedGenre.enum_value)
}
inline void ClassifiedGenre::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ClassifiedGenre.enum_value)
}
inline void ClassifiedGenre::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ClassifiedGenre.enum_value)
}
inline std::string* ClassifiedGenre::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClassifiedGenre::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ClassifiedGenre.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClassifiedGenre::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ClassifiedGenre.enum_value)
}

// -------------------------------------------------------------------

// CodingType

// optional string enum_value = 1;
inline bool CodingType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CodingType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CodingType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CodingType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CodingType.enum_value)
  return _internal_enum_value();
}
inline void CodingType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CodingType.enum_value)
}
inline std::string* CodingType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CodingType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CodingType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CodingType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CodingType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CodingType.enum_value)
}
inline void CodingType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CodingType.enum_value)
}
inline void CodingType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CodingType.enum_value)
}
inline std::string* CodingType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CodingType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CodingType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CodingType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CodingType.enum_value)
}

// -------------------------------------------------------------------

// CommentaryNoteType

// optional string enum_value = 1;
inline bool CommentaryNoteType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommentaryNoteType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CommentaryNoteType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommentaryNoteType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CommentaryNoteType.enum_value)
  return _internal_enum_value();
}
inline void CommentaryNoteType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CommentaryNoteType.enum_value)
}
inline std::string* CommentaryNoteType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CommentaryNoteType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CommentaryNoteType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CommentaryNoteType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommentaryNoteType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CommentaryNoteType.enum_value)
}
inline void CommentaryNoteType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CommentaryNoteType.enum_value)
}
inline void CommentaryNoteType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CommentaryNoteType.enum_value)
}
inline std::string* CommentaryNoteType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommentaryNoteType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CommentaryNoteType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommentaryNoteType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CommentaryNoteType.enum_value)
}

// -------------------------------------------------------------------

// CommercialModelType

// optional string enum_value = 1;
inline bool CommercialModelType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommercialModelType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CommercialModelType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommercialModelType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CommercialModelType.enum_value)
  return _internal_enum_value();
}
inline void CommercialModelType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CommercialModelType.enum_value)
}
inline std::string* CommercialModelType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CommercialModelType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CommercialModelType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CommercialModelType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommercialModelType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CommercialModelType.enum_value)
}
inline void CommercialModelType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CommercialModelType.enum_value)
}
inline void CommercialModelType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CommercialModelType.enum_value)
}
inline std::string* CommercialModelType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommercialModelType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CommercialModelType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommercialModelType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CommercialModelType.enum_value)
}

// -------------------------------------------------------------------

// CommercialModelType_MWNL

// optional string enum_value = 1;
inline bool CommercialModelType_MWNL::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommercialModelType_MWNL::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CommercialModelType_MWNL::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommercialModelType_MWNL::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CommercialModelType_MWNL.enum_value)
  return _internal_enum_value();
}
inline void CommercialModelType_MWNL::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CommercialModelType_MWNL.enum_value)
}
inline std::string* CommercialModelType_MWNL::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CommercialModelType_MWNL.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CommercialModelType_MWNL::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CommercialModelType_MWNL::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommercialModelType_MWNL::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CommercialModelType_MWNL.enum_value)
}
inline void CommercialModelType_MWNL::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CommercialModelType_MWNL.enum_value)
}
inline void CommercialModelType_MWNL::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CommercialModelType_MWNL.enum_value)
}
inline std::string* CommercialModelType_MWNL::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommercialModelType_MWNL::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CommercialModelType_MWNL.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommercialModelType_MWNL::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CommercialModelType_MWNL.enum_value)
}

// -------------------------------------------------------------------

// CompilationType

// optional string enum_value = 1;
inline bool CompilationType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CompilationType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CompilationType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompilationType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CompilationType.enum_value)
  return _internal_enum_value();
}
inline void CompilationType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CompilationType.enum_value)
}
inline std::string* CompilationType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CompilationType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CompilationType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CompilationType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CompilationType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CompilationType.enum_value)
}
inline void CompilationType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CompilationType.enum_value)
}
inline void CompilationType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CompilationType.enum_value)
}
inline std::string* CompilationType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CompilationType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CompilationType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CompilationType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CompilationType.enum_value)
}

// -------------------------------------------------------------------

// CompositeMusicalWorkType

// optional string enum_value = 1;
inline bool CompositeMusicalWorkType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CompositeMusicalWorkType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CompositeMusicalWorkType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompositeMusicalWorkType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CompositeMusicalWorkType.enum_value)
  return _internal_enum_value();
}
inline void CompositeMusicalWorkType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CompositeMusicalWorkType.enum_value)
}
inline std::string* CompositeMusicalWorkType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CompositeMusicalWorkType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CompositeMusicalWorkType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CompositeMusicalWorkType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CompositeMusicalWorkType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CompositeMusicalWorkType.enum_value)
}
inline void CompositeMusicalWorkType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CompositeMusicalWorkType.enum_value)
}
inline void CompositeMusicalWorkType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CompositeMusicalWorkType.enum_value)
}
inline std::string* CompositeMusicalWorkType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CompositeMusicalWorkType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CompositeMusicalWorkType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CompositeMusicalWorkType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CompositeMusicalWorkType.enum_value)
}

// -------------------------------------------------------------------

// ContainerFormat

// optional string enum_value = 1;
inline bool ContainerFormat::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContainerFormat::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ContainerFormat::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContainerFormat::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ContainerFormat.enum_value)
  return _internal_enum_value();
}
inline void ContainerFormat::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ContainerFormat.enum_value)
}
inline std::string* ContainerFormat::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ContainerFormat.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ContainerFormat::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ContainerFormat::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ContainerFormat::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ContainerFormat.enum_value)
}
inline void ContainerFormat::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ContainerFormat.enum_value)
}
inline void ContainerFormat::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ContainerFormat.enum_value)
}
inline std::string* ContainerFormat::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ContainerFormat::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ContainerFormat.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ContainerFormat::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ContainerFormat.enum_value)
}

// -------------------------------------------------------------------

// ContributorRole

// optional string enum_value = 1;
inline bool ContributorRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContributorRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ContributorRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContributorRole::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ContributorRole.enum_value)
  return _internal_enum_value();
}
inline void ContributorRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ContributorRole.enum_value)
}
inline std::string* ContributorRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ContributorRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ContributorRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ContributorRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ContributorRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ContributorRole.enum_value)
}
inline void ContributorRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ContributorRole.enum_value)
}
inline void ContributorRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ContributorRole.enum_value)
}
inline std::string* ContributorRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ContributorRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ContributorRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ContributorRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ContributorRole.enum_value)
}

// -------------------------------------------------------------------

// CreativeMusicalWorkContributorRole

// optional string enum_value = 1;
inline bool CreativeMusicalWorkContributorRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreativeMusicalWorkContributorRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CreativeMusicalWorkContributorRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreativeMusicalWorkContributorRole::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CreativeMusicalWorkContributorRole.enum_value)
  return _internal_enum_value();
}
inline void CreativeMusicalWorkContributorRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CreativeMusicalWorkContributorRole.enum_value)
}
inline std::string* CreativeMusicalWorkContributorRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CreativeMusicalWorkContributorRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CreativeMusicalWorkContributorRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CreativeMusicalWorkContributorRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CreativeMusicalWorkContributorRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CreativeMusicalWorkContributorRole.enum_value)
}
inline void CreativeMusicalWorkContributorRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CreativeMusicalWorkContributorRole.enum_value)
}
inline void CreativeMusicalWorkContributorRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CreativeMusicalWorkContributorRole.enum_value)
}
inline std::string* CreativeMusicalWorkContributorRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CreativeMusicalWorkContributorRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CreativeMusicalWorkContributorRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreativeMusicalWorkContributorRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CreativeMusicalWorkContributorRole.enum_value)
}

// -------------------------------------------------------------------

// CueOrigin

// optional string enum_value = 1;
inline bool CueOrigin::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CueOrigin::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CueOrigin::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CueOrigin::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CueOrigin.enum_value)
  return _internal_enum_value();
}
inline void CueOrigin::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CueOrigin.enum_value)
}
inline std::string* CueOrigin::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CueOrigin.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CueOrigin::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CueOrigin::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CueOrigin::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CueOrigin.enum_value)
}
inline void CueOrigin::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CueOrigin.enum_value)
}
inline void CueOrigin::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CueOrigin.enum_value)
}
inline std::string* CueOrigin::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CueOrigin::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CueOrigin.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CueOrigin::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CueOrigin.enum_value)
}

// -------------------------------------------------------------------

// CueSheetType

// optional string enum_value = 1;
inline bool CueSheetType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CueSheetType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CueSheetType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CueSheetType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CueSheetType.enum_value)
  return _internal_enum_value();
}
inline void CueSheetType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CueSheetType.enum_value)
}
inline std::string* CueSheetType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CueSheetType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CueSheetType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CueSheetType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CueSheetType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CueSheetType.enum_value)
}
inline void CueSheetType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CueSheetType.enum_value)
}
inline void CueSheetType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CueSheetType.enum_value)
}
inline std::string* CueSheetType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CueSheetType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CueSheetType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CueSheetType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CueSheetType.enum_value)
}

// -------------------------------------------------------------------

// CueUseType

// optional string enum_value = 1;
inline bool CueUseType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CueUseType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CueUseType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CueUseType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CueUseType.enum_value)
  return _internal_enum_value();
}
inline void CueUseType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CueUseType.enum_value)
}
inline std::string* CueUseType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CueUseType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CueUseType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CueUseType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CueUseType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CueUseType.enum_value)
}
inline void CueUseType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CueUseType.enum_value)
}
inline void CueUseType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CueUseType.enum_value)
}
inline std::string* CueUseType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CueUseType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CueUseType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CueUseType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CueUseType.enum_value)
}

// -------------------------------------------------------------------

// CurrencyCode

// optional string enum_value = 1;
inline bool CurrencyCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CurrencyCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CurrencyCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CurrencyCode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CurrencyCode.enum_value)
  return _internal_enum_value();
}
inline void CurrencyCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CurrencyCode.enum_value)
}
inline std::string* CurrencyCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CurrencyCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CurrencyCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CurrencyCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CurrencyCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CurrencyCode.enum_value)
}
inline void CurrencyCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CurrencyCode.enum_value)
}
inline void CurrencyCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CurrencyCode.enum_value)
}
inline std::string* CurrencyCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CurrencyCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CurrencyCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CurrencyCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CurrencyCode.enum_value)
}

// -------------------------------------------------------------------

// CurrentTerritoryCode

// optional string enum_value = 1;
inline bool CurrentTerritoryCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CurrentTerritoryCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void CurrentTerritoryCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CurrentTerritoryCode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.CurrentTerritoryCode.enum_value)
  return _internal_enum_value();
}
inline void CurrentTerritoryCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.CurrentTerritoryCode.enum_value)
}
inline std::string* CurrentTerritoryCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.CurrentTerritoryCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& CurrentTerritoryCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void CurrentTerritoryCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CurrentTerritoryCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.CurrentTerritoryCode.enum_value)
}
inline void CurrentTerritoryCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.CurrentTerritoryCode.enum_value)
}
inline void CurrentTerritoryCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.CurrentTerritoryCode.enum_value)
}
inline std::string* CurrentTerritoryCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CurrentTerritoryCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.CurrentTerritoryCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CurrentTerritoryCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.CurrentTerritoryCode.enum_value)
}

// -------------------------------------------------------------------

// DanceAndRhythmStyle

// optional string enum_value = 1;
inline bool DanceAndRhythmStyle::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DanceAndRhythmStyle::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DanceAndRhythmStyle::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DanceAndRhythmStyle::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DanceAndRhythmStyle.enum_value)
  return _internal_enum_value();
}
inline void DanceAndRhythmStyle::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DanceAndRhythmStyle.enum_value)
}
inline std::string* DanceAndRhythmStyle::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DanceAndRhythmStyle.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DanceAndRhythmStyle::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DanceAndRhythmStyle::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DanceAndRhythmStyle::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DanceAndRhythmStyle.enum_value)
}
inline void DanceAndRhythmStyle::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DanceAndRhythmStyle.enum_value)
}
inline void DanceAndRhythmStyle::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DanceAndRhythmStyle.enum_value)
}
inline std::string* DanceAndRhythmStyle::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DanceAndRhythmStyle::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DanceAndRhythmStyle.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DanceAndRhythmStyle::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DanceAndRhythmStyle.enum_value)
}

// -------------------------------------------------------------------

// DataCarrierFormat

// optional string enum_value = 1;
inline bool DataCarrierFormat::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataCarrierFormat::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DataCarrierFormat::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataCarrierFormat::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DataCarrierFormat.enum_value)
  return _internal_enum_value();
}
inline void DataCarrierFormat::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DataCarrierFormat.enum_value)
}
inline std::string* DataCarrierFormat::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DataCarrierFormat.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DataCarrierFormat::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DataCarrierFormat::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DataCarrierFormat::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DataCarrierFormat.enum_value)
}
inline void DataCarrierFormat::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DataCarrierFormat.enum_value)
}
inline void DataCarrierFormat::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DataCarrierFormat.enum_value)
}
inline std::string* DataCarrierFormat::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DataCarrierFormat::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DataCarrierFormat.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataCarrierFormat::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DataCarrierFormat.enum_value)
}

// -------------------------------------------------------------------

// DataCarrierType

// optional string enum_value = 1;
inline bool DataCarrierType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataCarrierType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DataCarrierType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataCarrierType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DataCarrierType.enum_value)
  return _internal_enum_value();
}
inline void DataCarrierType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DataCarrierType.enum_value)
}
inline std::string* DataCarrierType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DataCarrierType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DataCarrierType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DataCarrierType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DataCarrierType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DataCarrierType.enum_value)
}
inline void DataCarrierType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DataCarrierType.enum_value)
}
inline void DataCarrierType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DataCarrierType.enum_value)
}
inline std::string* DataCarrierType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DataCarrierType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DataCarrierType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataCarrierType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DataCarrierType.enum_value)
}

// -------------------------------------------------------------------

// DdexTerritoryCode

// optional string enum_value = 1;
inline bool DdexTerritoryCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DdexTerritoryCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DdexTerritoryCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DdexTerritoryCode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DdexTerritoryCode.enum_value)
  return _internal_enum_value();
}
inline void DdexTerritoryCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DdexTerritoryCode.enum_value)
}
inline std::string* DdexTerritoryCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DdexTerritoryCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DdexTerritoryCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DdexTerritoryCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DdexTerritoryCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DdexTerritoryCode.enum_value)
}
inline void DdexTerritoryCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DdexTerritoryCode.enum_value)
}
inline void DdexTerritoryCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DdexTerritoryCode.enum_value)
}
inline std::string* DdexTerritoryCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DdexTerritoryCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DdexTerritoryCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DdexTerritoryCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DdexTerritoryCode.enum_value)
}

// -------------------------------------------------------------------

// DeprecatedCurrencyCode

// optional string enum_value = 1;
inline bool DeprecatedCurrencyCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeprecatedCurrencyCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DeprecatedCurrencyCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeprecatedCurrencyCode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DeprecatedCurrencyCode.enum_value)
  return _internal_enum_value();
}
inline void DeprecatedCurrencyCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DeprecatedCurrencyCode.enum_value)
}
inline std::string* DeprecatedCurrencyCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DeprecatedCurrencyCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DeprecatedCurrencyCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DeprecatedCurrencyCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DeprecatedCurrencyCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DeprecatedCurrencyCode.enum_value)
}
inline void DeprecatedCurrencyCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DeprecatedCurrencyCode.enum_value)
}
inline void DeprecatedCurrencyCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DeprecatedCurrencyCode.enum_value)
}
inline std::string* DeprecatedCurrencyCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DeprecatedCurrencyCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DeprecatedCurrencyCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeprecatedCurrencyCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DeprecatedCurrencyCode.enum_value)
}

// -------------------------------------------------------------------

// DeprecatedIsoTerritoryCode

// optional string enum_value = 1;
inline bool DeprecatedIsoTerritoryCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeprecatedIsoTerritoryCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DeprecatedIsoTerritoryCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeprecatedIsoTerritoryCode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DeprecatedIsoTerritoryCode.enum_value)
  return _internal_enum_value();
}
inline void DeprecatedIsoTerritoryCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DeprecatedIsoTerritoryCode.enum_value)
}
inline std::string* DeprecatedIsoTerritoryCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DeprecatedIsoTerritoryCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DeprecatedIsoTerritoryCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DeprecatedIsoTerritoryCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DeprecatedIsoTerritoryCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DeprecatedIsoTerritoryCode.enum_value)
}
inline void DeprecatedIsoTerritoryCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DeprecatedIsoTerritoryCode.enum_value)
}
inline void DeprecatedIsoTerritoryCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DeprecatedIsoTerritoryCode.enum_value)
}
inline std::string* DeprecatedIsoTerritoryCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DeprecatedIsoTerritoryCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DeprecatedIsoTerritoryCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeprecatedIsoTerritoryCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DeprecatedIsoTerritoryCode.enum_value)
}

// -------------------------------------------------------------------

// DeprecatedReleaseType

// optional string enum_value = 1;
inline bool DeprecatedReleaseType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeprecatedReleaseType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DeprecatedReleaseType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeprecatedReleaseType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DeprecatedReleaseType.enum_value)
  return _internal_enum_value();
}
inline void DeprecatedReleaseType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DeprecatedReleaseType.enum_value)
}
inline std::string* DeprecatedReleaseType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DeprecatedReleaseType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DeprecatedReleaseType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DeprecatedReleaseType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DeprecatedReleaseType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DeprecatedReleaseType.enum_value)
}
inline void DeprecatedReleaseType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DeprecatedReleaseType.enum_value)
}
inline void DeprecatedReleaseType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DeprecatedReleaseType.enum_value)
}
inline std::string* DeprecatedReleaseType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DeprecatedReleaseType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DeprecatedReleaseType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeprecatedReleaseType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DeprecatedReleaseType.enum_value)
}

// -------------------------------------------------------------------

// DigitizationMode

// optional string enum_value = 1;
inline bool DigitizationMode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DigitizationMode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DigitizationMode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DigitizationMode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DigitizationMode.enum_value)
  return _internal_enum_value();
}
inline void DigitizationMode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DigitizationMode.enum_value)
}
inline std::string* DigitizationMode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DigitizationMode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DigitizationMode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DigitizationMode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DigitizationMode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DigitizationMode.enum_value)
}
inline void DigitizationMode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DigitizationMode.enum_value)
}
inline void DigitizationMode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DigitizationMode.enum_value)
}
inline std::string* DigitizationMode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DigitizationMode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DigitizationMode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DigitizationMode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DigitizationMode.enum_value)
}

// -------------------------------------------------------------------

// DisplayArtistRole

// optional string enum_value = 1;
inline bool DisplayArtistRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DisplayArtistRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DisplayArtistRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DisplayArtistRole::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DisplayArtistRole.enum_value)
  return _internal_enum_value();
}
inline void DisplayArtistRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DisplayArtistRole.enum_value)
}
inline std::string* DisplayArtistRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DisplayArtistRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DisplayArtistRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DisplayArtistRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DisplayArtistRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DisplayArtistRole.enum_value)
}
inline void DisplayArtistRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DisplayArtistRole.enum_value)
}
inline void DisplayArtistRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DisplayArtistRole.enum_value)
}
inline std::string* DisplayArtistRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DisplayArtistRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DisplayArtistRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DisplayArtistRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DisplayArtistRole.enum_value)
}

// -------------------------------------------------------------------

// DistributionChannelType

// optional string enum_value = 1;
inline bool DistributionChannelType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DistributionChannelType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DistributionChannelType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DistributionChannelType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DistributionChannelType.enum_value)
  return _internal_enum_value();
}
inline void DistributionChannelType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DistributionChannelType.enum_value)
}
inline std::string* DistributionChannelType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DistributionChannelType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DistributionChannelType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DistributionChannelType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DistributionChannelType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DistributionChannelType.enum_value)
}
inline void DistributionChannelType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DistributionChannelType.enum_value)
}
inline void DistributionChannelType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DistributionChannelType.enum_value)
}
inline std::string* DistributionChannelType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DistributionChannelType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DistributionChannelType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DistributionChannelType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DistributionChannelType.enum_value)
}

// -------------------------------------------------------------------

// DocumentType_LoD

// optional string enum_value = 1;
inline bool DocumentType_LoD::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DocumentType_LoD::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DocumentType_LoD::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DocumentType_LoD::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DocumentType_LoD.enum_value)
  return _internal_enum_value();
}
inline void DocumentType_LoD::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DocumentType_LoD.enum_value)
}
inline std::string* DocumentType_LoD::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DocumentType_LoD.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DocumentType_LoD::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DocumentType_LoD::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DocumentType_LoD::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DocumentType_LoD.enum_value)
}
inline void DocumentType_LoD::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DocumentType_LoD.enum_value)
}
inline void DocumentType_LoD::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DocumentType_LoD.enum_value)
}
inline std::string* DocumentType_LoD::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DocumentType_LoD::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DocumentType_LoD.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DocumentType_LoD::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DocumentType_LoD.enum_value)
}

// -------------------------------------------------------------------

// DocumentType_MWL

// optional string enum_value = 1;
inline bool DocumentType_MWL::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DocumentType_MWL::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DocumentType_MWL::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DocumentType_MWL::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DocumentType_MWL.enum_value)
  return _internal_enum_value();
}
inline void DocumentType_MWL::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DocumentType_MWL.enum_value)
}
inline std::string* DocumentType_MWL::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DocumentType_MWL.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DocumentType_MWL::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DocumentType_MWL::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DocumentType_MWL::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DocumentType_MWL.enum_value)
}
inline void DocumentType_MWL::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DocumentType_MWL.enum_value)
}
inline void DocumentType_MWL::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DocumentType_MWL.enum_value)
}
inline std::string* DocumentType_MWL::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DocumentType_MWL::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DocumentType_MWL.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DocumentType_MWL::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DocumentType_MWL.enum_value)
}

// -------------------------------------------------------------------

// DpidStatus

// optional string enum_value = 1;
inline bool DpidStatus::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DpidStatus::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DpidStatus::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DpidStatus::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DpidStatus.enum_value)
  return _internal_enum_value();
}
inline void DpidStatus::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DpidStatus.enum_value)
}
inline std::string* DpidStatus::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DpidStatus.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DpidStatus::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DpidStatus::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DpidStatus::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DpidStatus.enum_value)
}
inline void DpidStatus::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DpidStatus.enum_value)
}
inline void DpidStatus::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DpidStatus.enum_value)
}
inline std::string* DpidStatus::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DpidStatus::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DpidStatus.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DpidStatus::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DpidStatus.enum_value)
}

// -------------------------------------------------------------------

// DrmEnforcementType

// optional string enum_value = 1;
inline bool DrmEnforcementType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DrmEnforcementType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void DrmEnforcementType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DrmEnforcementType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.DrmEnforcementType.enum_value)
  return _internal_enum_value();
}
inline void DrmEnforcementType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.DrmEnforcementType.enum_value)
}
inline std::string* DrmEnforcementType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.DrmEnforcementType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& DrmEnforcementType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void DrmEnforcementType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DrmEnforcementType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.DrmEnforcementType.enum_value)
}
inline void DrmEnforcementType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.DrmEnforcementType.enum_value)
}
inline void DrmEnforcementType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.DrmEnforcementType.enum_value)
}
inline std::string* DrmEnforcementType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DrmEnforcementType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.DrmEnforcementType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DrmEnforcementType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.DrmEnforcementType.enum_value)
}

// -------------------------------------------------------------------

// ElementConfiguration

// optional string enum_value = 1;
inline bool ElementConfiguration::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ElementConfiguration::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ElementConfiguration::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ElementConfiguration::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ElementConfiguration.enum_value)
  return _internal_enum_value();
}
inline void ElementConfiguration::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ElementConfiguration.enum_value)
}
inline std::string* ElementConfiguration::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ElementConfiguration.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ElementConfiguration::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ElementConfiguration::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ElementConfiguration::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ElementConfiguration.enum_value)
}
inline void ElementConfiguration::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ElementConfiguration.enum_value)
}
inline void ElementConfiguration::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ElementConfiguration.enum_value)
}
inline std::string* ElementConfiguration::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ElementConfiguration::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ElementConfiguration.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ElementConfiguration::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ElementConfiguration.enum_value)
}

// -------------------------------------------------------------------

// ElementDesignation

// optional string enum_value = 1;
inline bool ElementDesignation::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ElementDesignation::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ElementDesignation::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ElementDesignation::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ElementDesignation.enum_value)
  return _internal_enum_value();
}
inline void ElementDesignation::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ElementDesignation.enum_value)
}
inline std::string* ElementDesignation::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ElementDesignation.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ElementDesignation::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ElementDesignation::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ElementDesignation::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ElementDesignation.enum_value)
}
inline void ElementDesignation::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ElementDesignation.enum_value)
}
inline void ElementDesignation::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ElementDesignation.enum_value)
}
inline std::string* ElementDesignation::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ElementDesignation::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ElementDesignation.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ElementDesignation::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ElementDesignation.enum_value)
}

// -------------------------------------------------------------------

// EncodingType

// optional string enum_value = 1;
inline bool EncodingType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EncodingType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void EncodingType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EncodingType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.EncodingType.enum_value)
  return _internal_enum_value();
}
inline void EncodingType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.EncodingType.enum_value)
}
inline std::string* EncodingType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.EncodingType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& EncodingType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void EncodingType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EncodingType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.EncodingType.enum_value)
}
inline void EncodingType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.EncodingType.enum_value)
}
inline void EncodingType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.EncodingType.enum_value)
}
inline std::string* EncodingType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EncodingType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.EncodingType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EncodingType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.EncodingType.enum_value)
}

// -------------------------------------------------------------------

// EquipmentType

// optional string enum_value = 1;
inline bool EquipmentType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EquipmentType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void EquipmentType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EquipmentType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.EquipmentType.enum_value)
  return _internal_enum_value();
}
inline void EquipmentType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.EquipmentType.enum_value)
}
inline std::string* EquipmentType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.EquipmentType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& EquipmentType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void EquipmentType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EquipmentType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.EquipmentType.enum_value)
}
inline void EquipmentType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.EquipmentType.enum_value)
}
inline void EquipmentType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.EquipmentType.enum_value)
}
inline std::string* EquipmentType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EquipmentType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.EquipmentType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EquipmentType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.EquipmentType.enum_value)
}

// -------------------------------------------------------------------

// ErnMessageType

// optional string enum_value = 1;
inline bool ErnMessageType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErnMessageType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ErnMessageType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErnMessageType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ErnMessageType.enum_value)
  return _internal_enum_value();
}
inline void ErnMessageType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ErnMessageType.enum_value)
}
inline std::string* ErnMessageType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ErnMessageType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ErnMessageType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ErnMessageType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ErnMessageType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ErnMessageType.enum_value)
}
inline void ErnMessageType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ErnMessageType.enum_value)
}
inline void ErnMessageType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ErnMessageType.enum_value)
}
inline std::string* ErnMessageType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ErnMessageType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ErnMessageType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErnMessageType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ErnMessageType.enum_value)
}

// -------------------------------------------------------------------

// ErnTestMessageType

// optional string enum_value = 1;
inline bool ErnTestMessageType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErnTestMessageType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ErnTestMessageType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErnTestMessageType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ErnTestMessageType.enum_value)
  return _internal_enum_value();
}
inline void ErnTestMessageType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ErnTestMessageType.enum_value)
}
inline std::string* ErnTestMessageType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ErnTestMessageType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ErnTestMessageType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ErnTestMessageType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ErnTestMessageType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ErnTestMessageType.enum_value)
}
inline void ErnTestMessageType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ErnTestMessageType.enum_value)
}
inline void ErnTestMessageType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ErnTestMessageType.enum_value)
}
inline std::string* ErnTestMessageType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ErnTestMessageType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ErnTestMessageType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErnTestMessageType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ErnTestMessageType.enum_value)
}

// -------------------------------------------------------------------

// ErncFileStatus

// optional string enum_value = 1;
inline bool ErncFileStatus::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErncFileStatus::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ErncFileStatus::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErncFileStatus::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ErncFileStatus.enum_value)
  return _internal_enum_value();
}
inline void ErncFileStatus::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ErncFileStatus.enum_value)
}
inline std::string* ErncFileStatus::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ErncFileStatus.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ErncFileStatus::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ErncFileStatus::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ErncFileStatus::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ErncFileStatus.enum_value)
}
inline void ErncFileStatus::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ErncFileStatus.enum_value)
}
inline void ErncFileStatus::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ErncFileStatus.enum_value)
}
inline std::string* ErncFileStatus::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ErncFileStatus::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ErncFileStatus.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErncFileStatus::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ErncFileStatus.enum_value)
}

// -------------------------------------------------------------------

// ErncProposedActionType

// optional string enum_value = 1;
inline bool ErncProposedActionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErncProposedActionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ErncProposedActionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErncProposedActionType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ErncProposedActionType.enum_value)
  return _internal_enum_value();
}
inline void ErncProposedActionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ErncProposedActionType.enum_value)
}
inline std::string* ErncProposedActionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ErncProposedActionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ErncProposedActionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ErncProposedActionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ErncProposedActionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ErncProposedActionType.enum_value)
}
inline void ErncProposedActionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ErncProposedActionType.enum_value)
}
inline void ErncProposedActionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ErncProposedActionType.enum_value)
}
inline std::string* ErncProposedActionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ErncProposedActionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ErncProposedActionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErncProposedActionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ErncProposedActionType.enum_value)
}

// -------------------------------------------------------------------

// ErrorSeverity

// optional string enum_value = 1;
inline bool ErrorSeverity::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErrorSeverity::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ErrorSeverity::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErrorSeverity::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ErrorSeverity.enum_value)
  return _internal_enum_value();
}
inline void ErrorSeverity::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ErrorSeverity.enum_value)
}
inline std::string* ErrorSeverity::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ErrorSeverity.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ErrorSeverity::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ErrorSeverity::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ErrorSeverity::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ErrorSeverity.enum_value)
}
inline void ErrorSeverity::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ErrorSeverity.enum_value)
}
inline void ErrorSeverity::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ErrorSeverity.enum_value)
}
inline std::string* ErrorSeverity::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ErrorSeverity::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ErrorSeverity.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErrorSeverity::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ErrorSeverity.enum_value)
}

// -------------------------------------------------------------------

// ErrorType

// optional string enum_value = 1;
inline bool ErrorType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErrorType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ErrorType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErrorType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ErrorType.enum_value)
  return _internal_enum_value();
}
inline void ErrorType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ErrorType.enum_value)
}
inline std::string* ErrorType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ErrorType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ErrorType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ErrorType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ErrorType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ErrorType.enum_value)
}
inline void ErrorType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ErrorType.enum_value)
}
inline void ErrorType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ErrorType.enum_value)
}
inline std::string* ErrorType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ErrorType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ErrorType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErrorType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ErrorType.enum_value)
}

// -------------------------------------------------------------------

// ExceptionReason

// optional string enum_value = 1;
inline bool ExceptionReason::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExceptionReason::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ExceptionReason::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExceptionReason::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ExceptionReason.enum_value)
  return _internal_enum_value();
}
inline void ExceptionReason::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ExceptionReason.enum_value)
}
inline std::string* ExceptionReason::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ExceptionReason.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ExceptionReason::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ExceptionReason::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ExceptionReason::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ExceptionReason.enum_value)
}
inline void ExceptionReason::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ExceptionReason.enum_value)
}
inline void ExceptionReason::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ExceptionReason.enum_value)
}
inline std::string* ExceptionReason::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ExceptionReason::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ExceptionReason.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ExceptionReason::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ExceptionReason.enum_value)
}

// -------------------------------------------------------------------

// ExpressionType

// optional string enum_value = 1;
inline bool ExpressionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExpressionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ExpressionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExpressionType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ExpressionType.enum_value)
  return _internal_enum_value();
}
inline void ExpressionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ExpressionType.enum_value)
}
inline std::string* ExpressionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ExpressionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ExpressionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ExpressionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ExpressionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ExpressionType.enum_value)
}
inline void ExpressionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ExpressionType.enum_value)
}
inline void ExpressionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ExpressionType.enum_value)
}
inline std::string* ExpressionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ExpressionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ExpressionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ExpressionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ExpressionType.enum_value)
}

// -------------------------------------------------------------------

// ExternallyLinkedResourceType

// optional string enum_value = 1;
inline bool ExternallyLinkedResourceType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExternallyLinkedResourceType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ExternallyLinkedResourceType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExternallyLinkedResourceType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ExternallyLinkedResourceType.enum_value)
  return _internal_enum_value();
}
inline void ExternallyLinkedResourceType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ExternallyLinkedResourceType.enum_value)
}
inline std::string* ExternallyLinkedResourceType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ExternallyLinkedResourceType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ExternallyLinkedResourceType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ExternallyLinkedResourceType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ExternallyLinkedResourceType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ExternallyLinkedResourceType.enum_value)
}
inline void ExternallyLinkedResourceType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ExternallyLinkedResourceType.enum_value)
}
inline void ExternallyLinkedResourceType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ExternallyLinkedResourceType.enum_value)
}
inline std::string* ExternallyLinkedResourceType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ExternallyLinkedResourceType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ExternallyLinkedResourceType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ExternallyLinkedResourceType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ExternallyLinkedResourceType.enum_value)
}

// -------------------------------------------------------------------

// FileType

// optional string enum_value = 1;
inline bool FileType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FileType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void FileType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.FileType.enum_value)
  return _internal_enum_value();
}
inline void FileType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.FileType.enum_value)
}
inline std::string* FileType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.FileType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& FileType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void FileType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FileType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.FileType.enum_value)
}
inline void FileType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.FileType.enum_value)
}
inline void FileType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.FileType.enum_value)
}
inline std::string* FileType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FileType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.FileType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.FileType.enum_value)
}

// -------------------------------------------------------------------

// FingerprintAlgorithmType

// optional string enum_value = 1;
inline bool FingerprintAlgorithmType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FingerprintAlgorithmType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void FingerprintAlgorithmType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FingerprintAlgorithmType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.FingerprintAlgorithmType.enum_value)
  return _internal_enum_value();
}
inline void FingerprintAlgorithmType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.FingerprintAlgorithmType.enum_value)
}
inline std::string* FingerprintAlgorithmType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.FingerprintAlgorithmType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& FingerprintAlgorithmType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void FingerprintAlgorithmType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FingerprintAlgorithmType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.FingerprintAlgorithmType.enum_value)
}
inline void FingerprintAlgorithmType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.FingerprintAlgorithmType.enum_value)
}
inline void FingerprintAlgorithmType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.FingerprintAlgorithmType.enum_value)
}
inline std::string* FingerprintAlgorithmType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FingerprintAlgorithmType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.FingerprintAlgorithmType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FingerprintAlgorithmType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.FingerprintAlgorithmType.enum_value)
}

// -------------------------------------------------------------------

// Form

// optional string enum_value = 1;
inline bool Form::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Form::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void Form::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Form::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.Form.enum_value)
  return _internal_enum_value();
}
inline void Form::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.Form.enum_value)
}
inline std::string* Form::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.Form.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& Form::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void Form::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Form::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.Form.enum_value)
}
inline void Form::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.Form.enum_value)
}
inline void Form::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.Form.enum_value)
}
inline std::string* Form::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Form::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.Form.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Form::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.Form.enum_value)
}

// -------------------------------------------------------------------

// FrameRate

// optional string enum_value = 1;
inline bool FrameRate::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FrameRate::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void FrameRate::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FrameRate::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.FrameRate.enum_value)
  return _internal_enum_value();
}
inline void FrameRate::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.FrameRate.enum_value)
}
inline std::string* FrameRate::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.FrameRate.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& FrameRate::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void FrameRate::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FrameRate::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.FrameRate.enum_value)
}
inline void FrameRate::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.FrameRate.enum_value)
}
inline void FrameRate::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.FrameRate.enum_value)
}
inline std::string* FrameRate::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FrameRate::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.FrameRate.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FrameRate::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.FrameRate.enum_value)
}

// -------------------------------------------------------------------

// Gender

// optional string enum_value = 1;
inline bool Gender::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Gender::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void Gender::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Gender::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.Gender.enum_value)
  return _internal_enum_value();
}
inline void Gender::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.Gender.enum_value)
}
inline std::string* Gender::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.Gender.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& Gender::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void Gender::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Gender::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.Gender.enum_value)
}
inline void Gender::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.Gender.enum_value)
}
inline void Gender::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.Gender.enum_value)
}
inline std::string* Gender::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Gender::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.Gender.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Gender::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.Gender.enum_value)
}

// -------------------------------------------------------------------

// GoverningAgreementType

// optional string enum_value = 1;
inline bool GoverningAgreementType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GoverningAgreementType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void GoverningAgreementType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GoverningAgreementType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.GoverningAgreementType.enum_value)
  return _internal_enum_value();
}
inline void GoverningAgreementType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.GoverningAgreementType.enum_value)
}
inline std::string* GoverningAgreementType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.GoverningAgreementType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& GoverningAgreementType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void GoverningAgreementType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GoverningAgreementType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.GoverningAgreementType.enum_value)
}
inline void GoverningAgreementType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.GoverningAgreementType.enum_value)
}
inline void GoverningAgreementType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.GoverningAgreementType.enum_value)
}
inline std::string* GoverningAgreementType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GoverningAgreementType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.GoverningAgreementType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GoverningAgreementType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.GoverningAgreementType.enum_value)
}

// -------------------------------------------------------------------

// HashSumAlgorithmType

// optional string enum_value = 1;
inline bool HashSumAlgorithmType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HashSumAlgorithmType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void HashSumAlgorithmType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HashSumAlgorithmType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.HashSumAlgorithmType.enum_value)
  return _internal_enum_value();
}
inline void HashSumAlgorithmType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.HashSumAlgorithmType.enum_value)
}
inline std::string* HashSumAlgorithmType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.HashSumAlgorithmType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& HashSumAlgorithmType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void HashSumAlgorithmType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HashSumAlgorithmType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.HashSumAlgorithmType.enum_value)
}
inline void HashSumAlgorithmType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.HashSumAlgorithmType.enum_value)
}
inline void HashSumAlgorithmType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.HashSumAlgorithmType.enum_value)
}
inline std::string* HashSumAlgorithmType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HashSumAlgorithmType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.HashSumAlgorithmType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HashSumAlgorithmType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.HashSumAlgorithmType.enum_value)
}

// -------------------------------------------------------------------

// ImageCodecType

// optional string enum_value = 1;
inline bool ImageCodecType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImageCodecType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ImageCodecType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImageCodecType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ImageCodecType.enum_value)
  return _internal_enum_value();
}
inline void ImageCodecType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ImageCodecType.enum_value)
}
inline std::string* ImageCodecType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ImageCodecType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ImageCodecType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ImageCodecType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageCodecType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ImageCodecType.enum_value)
}
inline void ImageCodecType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ImageCodecType.enum_value)
}
inline void ImageCodecType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ImageCodecType.enum_value)
}
inline std::string* ImageCodecType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageCodecType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ImageCodecType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageCodecType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ImageCodecType.enum_value)
}

// -------------------------------------------------------------------

// ImageType

// optional string enum_value = 1;
inline bool ImageType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImageType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ImageType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImageType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ImageType.enum_value)
  return _internal_enum_value();
}
inline void ImageType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ImageType.enum_value)
}
inline std::string* ImageType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ImageType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ImageType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ImageType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ImageType.enum_value)
}
inline void ImageType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ImageType.enum_value)
}
inline void ImageType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ImageType.enum_value)
}
inline std::string* ImageType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ImageType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ImageType.enum_value)
}

// -------------------------------------------------------------------

// InstrumentType

// optional string enum_value = 1;
inline bool InstrumentType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstrumentType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void InstrumentType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstrumentType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.InstrumentType.enum_value)
  return _internal_enum_value();
}
inline void InstrumentType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.InstrumentType.enum_value)
}
inline std::string* InstrumentType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.InstrumentType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& InstrumentType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void InstrumentType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InstrumentType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.InstrumentType.enum_value)
}
inline void InstrumentType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.InstrumentType.enum_value)
}
inline void InstrumentType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.InstrumentType.enum_value)
}
inline std::string* InstrumentType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InstrumentType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.InstrumentType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InstrumentType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.InstrumentType.enum_value)
}

// -------------------------------------------------------------------

// Iso639Part12LanguageCode

// optional string enum_value = 1;
inline bool Iso639Part12LanguageCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Iso639Part12LanguageCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void Iso639Part12LanguageCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Iso639Part12LanguageCode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.Iso639Part12LanguageCode.enum_value)
  return _internal_enum_value();
}
inline void Iso639Part12LanguageCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.Iso639Part12LanguageCode.enum_value)
}
inline std::string* Iso639Part12LanguageCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.Iso639Part12LanguageCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& Iso639Part12LanguageCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void Iso639Part12LanguageCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Iso639Part12LanguageCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.Iso639Part12LanguageCode.enum_value)
}
inline void Iso639Part12LanguageCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.Iso639Part12LanguageCode.enum_value)
}
inline void Iso639Part12LanguageCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.Iso639Part12LanguageCode.enum_value)
}
inline std::string* Iso639Part12LanguageCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Iso639Part12LanguageCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.Iso639Part12LanguageCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Iso639Part12LanguageCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.Iso639Part12LanguageCode.enum_value)
}

// -------------------------------------------------------------------

// Iso639Part3LanguageCode

// optional string enum_value = 1;
inline bool Iso639Part3LanguageCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Iso639Part3LanguageCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void Iso639Part3LanguageCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Iso639Part3LanguageCode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.Iso639Part3LanguageCode.enum_value)
  return _internal_enum_value();
}
inline void Iso639Part3LanguageCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.Iso639Part3LanguageCode.enum_value)
}
inline std::string* Iso639Part3LanguageCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.Iso639Part3LanguageCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& Iso639Part3LanguageCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void Iso639Part3LanguageCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Iso639Part3LanguageCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.Iso639Part3LanguageCode.enum_value)
}
inline void Iso639Part3LanguageCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.Iso639Part3LanguageCode.enum_value)
}
inline void Iso639Part3LanguageCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.Iso639Part3LanguageCode.enum_value)
}
inline std::string* Iso639Part3LanguageCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Iso639Part3LanguageCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.Iso639Part3LanguageCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Iso639Part3LanguageCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.Iso639Part3LanguageCode.enum_value)
}

// -------------------------------------------------------------------

// IsoCurrencyCode

// optional string enum_value = 1;
inline bool IsoCurrencyCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IsoCurrencyCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void IsoCurrencyCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IsoCurrencyCode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.IsoCurrencyCode.enum_value)
  return _internal_enum_value();
}
inline void IsoCurrencyCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.IsoCurrencyCode.enum_value)
}
inline std::string* IsoCurrencyCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.IsoCurrencyCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& IsoCurrencyCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void IsoCurrencyCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void IsoCurrencyCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.IsoCurrencyCode.enum_value)
}
inline void IsoCurrencyCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.IsoCurrencyCode.enum_value)
}
inline void IsoCurrencyCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.IsoCurrencyCode.enum_value)
}
inline std::string* IsoCurrencyCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* IsoCurrencyCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.IsoCurrencyCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IsoCurrencyCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.IsoCurrencyCode.enum_value)
}

// -------------------------------------------------------------------

// IsoLanguageCode

// optional string enum_value = 1;
inline bool IsoLanguageCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IsoLanguageCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void IsoLanguageCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IsoLanguageCode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.IsoLanguageCode.enum_value)
  return _internal_enum_value();
}
inline void IsoLanguageCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.IsoLanguageCode.enum_value)
}
inline std::string* IsoLanguageCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.IsoLanguageCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& IsoLanguageCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void IsoLanguageCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void IsoLanguageCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.IsoLanguageCode.enum_value)
}
inline void IsoLanguageCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.IsoLanguageCode.enum_value)
}
inline void IsoLanguageCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.IsoLanguageCode.enum_value)
}
inline std::string* IsoLanguageCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* IsoLanguageCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.IsoLanguageCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IsoLanguageCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.IsoLanguageCode.enum_value)
}

// -------------------------------------------------------------------

// IsoTerritoryCode

// optional string enum_value = 1;
inline bool IsoTerritoryCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IsoTerritoryCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void IsoTerritoryCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IsoTerritoryCode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.IsoTerritoryCode.enum_value)
  return _internal_enum_value();
}
inline void IsoTerritoryCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.IsoTerritoryCode.enum_value)
}
inline std::string* IsoTerritoryCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.IsoTerritoryCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& IsoTerritoryCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void IsoTerritoryCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void IsoTerritoryCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.IsoTerritoryCode.enum_value)
}
inline void IsoTerritoryCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.IsoTerritoryCode.enum_value)
}
inline void IsoTerritoryCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.IsoTerritoryCode.enum_value)
}
inline std::string* IsoTerritoryCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* IsoTerritoryCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.IsoTerritoryCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IsoTerritoryCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.IsoTerritoryCode.enum_value)
}

// -------------------------------------------------------------------

// LabelNameType

// optional string enum_value = 1;
inline bool LabelNameType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LabelNameType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void LabelNameType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LabelNameType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.LabelNameType.enum_value)
  return _internal_enum_value();
}
inline void LabelNameType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.LabelNameType.enum_value)
}
inline std::string* LabelNameType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.LabelNameType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& LabelNameType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void LabelNameType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LabelNameType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.LabelNameType.enum_value)
}
inline void LabelNameType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.LabelNameType.enum_value)
}
inline void LabelNameType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.LabelNameType.enum_value)
}
inline std::string* LabelNameType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LabelNameType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.LabelNameType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LabelNameType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.LabelNameType.enum_value)
}

// -------------------------------------------------------------------

// LabelType

// optional string enum_value = 1;
inline bool LabelType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LabelType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void LabelType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LabelType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.LabelType.enum_value)
  return _internal_enum_value();
}
inline void LabelType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.LabelType.enum_value)
}
inline std::string* LabelType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.LabelType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& LabelType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void LabelType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LabelType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.LabelType.enum_value)
}
inline void LabelType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.LabelType.enum_value)
}
inline void LabelType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.LabelType.enum_value)
}
inline std::string* LabelType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LabelType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.LabelType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LabelType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.LabelType.enum_value)
}

// -------------------------------------------------------------------

// LanguageLocalizationType

// optional string enum_value = 1;
inline bool LanguageLocalizationType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LanguageLocalizationType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void LanguageLocalizationType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LanguageLocalizationType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.LanguageLocalizationType.enum_value)
  return _internal_enum_value();
}
inline void LanguageLocalizationType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.LanguageLocalizationType.enum_value)
}
inline std::string* LanguageLocalizationType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.LanguageLocalizationType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& LanguageLocalizationType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void LanguageLocalizationType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LanguageLocalizationType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.LanguageLocalizationType.enum_value)
}
inline void LanguageLocalizationType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.LanguageLocalizationType.enum_value)
}
inline void LanguageLocalizationType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.LanguageLocalizationType.enum_value)
}
inline std::string* LanguageLocalizationType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LanguageLocalizationType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.LanguageLocalizationType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LanguageLocalizationType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.LanguageLocalizationType.enum_value)
}

// -------------------------------------------------------------------

// LicenseRecord

// optional string enum_value = 1;
inline bool LicenseRecord::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LicenseRecord::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void LicenseRecord::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LicenseRecord::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.LicenseRecord.enum_value)
  return _internal_enum_value();
}
inline void LicenseRecord::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.LicenseRecord.enum_value)
}
inline std::string* LicenseRecord::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.LicenseRecord.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& LicenseRecord::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void LicenseRecord::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LicenseRecord::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.LicenseRecord.enum_value)
}
inline void LicenseRecord::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.LicenseRecord.enum_value)
}
inline void LicenseRecord::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.LicenseRecord.enum_value)
}
inline std::string* LicenseRecord::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LicenseRecord::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.LicenseRecord.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LicenseRecord::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.LicenseRecord.enum_value)
}

// -------------------------------------------------------------------

// LicenseRefusalReason

// optional string enum_value = 1;
inline bool LicenseRefusalReason::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LicenseRefusalReason::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void LicenseRefusalReason::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LicenseRefusalReason::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.LicenseRefusalReason.enum_value)
  return _internal_enum_value();
}
inline void LicenseRefusalReason::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.LicenseRefusalReason.enum_value)
}
inline std::string* LicenseRefusalReason::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.LicenseRefusalReason.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& LicenseRefusalReason::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void LicenseRefusalReason::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LicenseRefusalReason::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.LicenseRefusalReason.enum_value)
}
inline void LicenseRefusalReason::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.LicenseRefusalReason.enum_value)
}
inline void LicenseRefusalReason::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.LicenseRefusalReason.enum_value)
}
inline std::string* LicenseRefusalReason::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LicenseRefusalReason::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.LicenseRefusalReason.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LicenseRefusalReason::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.LicenseRefusalReason.enum_value)
}

// -------------------------------------------------------------------

// LicenseRejectionReason

// optional string enum_value = 1;
inline bool LicenseRejectionReason::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LicenseRejectionReason::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void LicenseRejectionReason::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LicenseRejectionReason::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.LicenseRejectionReason.enum_value)
  return _internal_enum_value();
}
inline void LicenseRejectionReason::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.LicenseRejectionReason.enum_value)
}
inline std::string* LicenseRejectionReason::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.LicenseRejectionReason.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& LicenseRejectionReason::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void LicenseRejectionReason::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LicenseRejectionReason::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.LicenseRejectionReason.enum_value)
}
inline void LicenseRejectionReason::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.LicenseRejectionReason.enum_value)
}
inline void LicenseRejectionReason::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.LicenseRejectionReason.enum_value)
}
inline std::string* LicenseRejectionReason::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LicenseRejectionReason::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.LicenseRejectionReason.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LicenseRejectionReason::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.LicenseRejectionReason.enum_value)
}

// -------------------------------------------------------------------

// LinkAcknowledgementStatus

// optional string enum_value = 1;
inline bool LinkAcknowledgementStatus::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LinkAcknowledgementStatus::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void LinkAcknowledgementStatus::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LinkAcknowledgementStatus::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.LinkAcknowledgementStatus.enum_value)
  return _internal_enum_value();
}
inline void LinkAcknowledgementStatus::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.LinkAcknowledgementStatus.enum_value)
}
inline std::string* LinkAcknowledgementStatus::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.LinkAcknowledgementStatus.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& LinkAcknowledgementStatus::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void LinkAcknowledgementStatus::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LinkAcknowledgementStatus::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.LinkAcknowledgementStatus.enum_value)
}
inline void LinkAcknowledgementStatus::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.LinkAcknowledgementStatus.enum_value)
}
inline void LinkAcknowledgementStatus::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.LinkAcknowledgementStatus.enum_value)
}
inline std::string* LinkAcknowledgementStatus::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LinkAcknowledgementStatus::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.LinkAcknowledgementStatus.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LinkAcknowledgementStatus::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.LinkAcknowledgementStatus.enum_value)
}

// -------------------------------------------------------------------

// LinkDescription

// optional string enum_value = 1;
inline bool LinkDescription::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LinkDescription::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void LinkDescription::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LinkDescription::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.LinkDescription.enum_value)
  return _internal_enum_value();
}
inline void LinkDescription::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.LinkDescription.enum_value)
}
inline std::string* LinkDescription::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.LinkDescription.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& LinkDescription::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void LinkDescription::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LinkDescription::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.LinkDescription.enum_value)
}
inline void LinkDescription::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.LinkDescription.enum_value)
}
inline void LinkDescription::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.LinkDescription.enum_value)
}
inline std::string* LinkDescription::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LinkDescription::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.LinkDescription.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LinkDescription::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.LinkDescription.enum_value)
}

// -------------------------------------------------------------------

// LyricsType

// optional string enum_value = 1;
inline bool LyricsType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LyricsType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void LyricsType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LyricsType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.LyricsType.enum_value)
  return _internal_enum_value();
}
inline void LyricsType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.LyricsType.enum_value)
}
inline std::string* LyricsType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.LyricsType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& LyricsType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void LyricsType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LyricsType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.LyricsType.enum_value)
}
inline void LyricsType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.LyricsType.enum_value)
}
inline void LyricsType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.LyricsType.enum_value)
}
inline std::string* LyricsType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LyricsType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.LyricsType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LyricsType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.LyricsType.enum_value)
}

// -------------------------------------------------------------------

// MembershipType

// optional string enum_value = 1;
inline bool MembershipType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MembershipType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MembershipType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MembershipType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MembershipType.enum_value)
  return _internal_enum_value();
}
inline void MembershipType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MembershipType.enum_value)
}
inline std::string* MembershipType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MembershipType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MembershipType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MembershipType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MembershipType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MembershipType.enum_value)
}
inline void MembershipType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MembershipType.enum_value)
}
inline void MembershipType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MembershipType.enum_value)
}
inline std::string* MembershipType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MembershipType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MembershipType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MembershipType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MembershipType.enum_value)
}

// -------------------------------------------------------------------

// MessageActionType

// optional string enum_value = 1;
inline bool MessageActionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessageActionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MessageActionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessageActionType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MessageActionType.enum_value)
  return _internal_enum_value();
}
inline void MessageActionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MessageActionType.enum_value)
}
inline std::string* MessageActionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MessageActionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MessageActionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MessageActionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MessageActionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MessageActionType.enum_value)
}
inline void MessageActionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MessageActionType.enum_value)
}
inline void MessageActionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MessageActionType.enum_value)
}
inline std::string* MessageActionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MessageActionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MessageActionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessageActionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MessageActionType.enum_value)
}

// -------------------------------------------------------------------

// MessageControlType

// optional string enum_value = 1;
inline bool MessageControlType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessageControlType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MessageControlType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessageControlType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MessageControlType.enum_value)
  return _internal_enum_value();
}
inline void MessageControlType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MessageControlType.enum_value)
}
inline std::string* MessageControlType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MessageControlType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MessageControlType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MessageControlType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MessageControlType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MessageControlType.enum_value)
}
inline void MessageControlType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MessageControlType.enum_value)
}
inline void MessageControlType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MessageControlType.enum_value)
}
inline std::string* MessageControlType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MessageControlType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MessageControlType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessageControlType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MessageControlType.enum_value)
}

// -------------------------------------------------------------------

// MessagePurpose

// optional string enum_value = 1;
inline bool MessagePurpose::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessagePurpose::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MessagePurpose::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessagePurpose::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MessagePurpose.enum_value)
  return _internal_enum_value();
}
inline void MessagePurpose::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MessagePurpose.enum_value)
}
inline std::string* MessagePurpose::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MessagePurpose.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MessagePurpose::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MessagePurpose::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MessagePurpose::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MessagePurpose.enum_value)
}
inline void MessagePurpose::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MessagePurpose.enum_value)
}
inline void MessagePurpose::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MessagePurpose.enum_value)
}
inline std::string* MessagePurpose::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MessagePurpose::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MessagePurpose.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessagePurpose::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MessagePurpose.enum_value)
}

// -------------------------------------------------------------------

// MessageType

// optional string enum_value = 1;
inline bool MessageType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessageType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MessageType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessageType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MessageType.enum_value)
  return _internal_enum_value();
}
inline void MessageType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MessageType.enum_value)
}
inline std::string* MessageType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MessageType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MessageType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MessageType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MessageType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MessageType.enum_value)
}
inline void MessageType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MessageType.enum_value)
}
inline void MessageType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MessageType.enum_value)
}
inline std::string* MessageType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MessageType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MessageType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessageType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MessageType.enum_value)
}

// -------------------------------------------------------------------

// MetadataSourceType

// optional string enum_value = 1;
inline bool MetadataSourceType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MetadataSourceType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MetadataSourceType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MetadataSourceType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MetadataSourceType.enum_value)
  return _internal_enum_value();
}
inline void MetadataSourceType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MetadataSourceType.enum_value)
}
inline std::string* MetadataSourceType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MetadataSourceType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MetadataSourceType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MetadataSourceType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MetadataSourceType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MetadataSourceType.enum_value)
}
inline void MetadataSourceType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MetadataSourceType.enum_value)
}
inline void MetadataSourceType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MetadataSourceType.enum_value)
}
inline std::string* MetadataSourceType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MetadataSourceType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MetadataSourceType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MetadataSourceType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MetadataSourceType.enum_value)
}

// -------------------------------------------------------------------

// MissingLinkReason

// optional string enum_value = 1;
inline bool MissingLinkReason::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MissingLinkReason::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MissingLinkReason::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MissingLinkReason::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MissingLinkReason.enum_value)
  return _internal_enum_value();
}
inline void MissingLinkReason::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MissingLinkReason.enum_value)
}
inline std::string* MissingLinkReason::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MissingLinkReason.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MissingLinkReason::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MissingLinkReason::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MissingLinkReason::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MissingLinkReason.enum_value)
}
inline void MissingLinkReason::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MissingLinkReason.enum_value)
}
inline void MissingLinkReason::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MissingLinkReason.enum_value)
}
inline std::string* MissingLinkReason::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MissingLinkReason::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MissingLinkReason.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MissingLinkReason::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MissingLinkReason.enum_value)
}

// -------------------------------------------------------------------

// MlcMessageType

// optional string enum_value = 1;
inline bool MlcMessageType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MlcMessageType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MlcMessageType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MlcMessageType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MlcMessageType.enum_value)
  return _internal_enum_value();
}
inline void MlcMessageType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MlcMessageType.enum_value)
}
inline std::string* MlcMessageType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MlcMessageType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MlcMessageType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MlcMessageType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MlcMessageType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MlcMessageType.enum_value)
}
inline void MlcMessageType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MlcMessageType.enum_value)
}
inline void MlcMessageType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MlcMessageType.enum_value)
}
inline std::string* MlcMessageType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MlcMessageType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MlcMessageType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MlcMessageType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MlcMessageType.enum_value)
}

// -------------------------------------------------------------------

// Mode

// optional string enum_value = 1;
inline bool Mode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Mode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void Mode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Mode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.Mode.enum_value)
  return _internal_enum_value();
}
inline void Mode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.Mode.enum_value)
}
inline std::string* Mode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.Mode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& Mode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void Mode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Mode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.Mode.enum_value)
}
inline void Mode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.Mode.enum_value)
}
inline void Mode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.Mode.enum_value)
}
inline std::string* Mode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Mode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.Mode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Mode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.Mode.enum_value)
}

// -------------------------------------------------------------------

// MoodType

// optional string enum_value = 1;
inline bool MoodType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoodType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MoodType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoodType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MoodType.enum_value)
  return _internal_enum_value();
}
inline void MoodType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MoodType.enum_value)
}
inline std::string* MoodType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MoodType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MoodType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MoodType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MoodType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MoodType.enum_value)
}
inline void MoodType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MoodType.enum_value)
}
inline void MoodType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MoodType.enum_value)
}
inline std::string* MoodType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MoodType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MoodType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MoodType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MoodType.enum_value)
}

// -------------------------------------------------------------------

// MusicalWorkContributorRole

// optional string enum_value = 1;
inline bool MusicalWorkContributorRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MusicalWorkContributorRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MusicalWorkContributorRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MusicalWorkContributorRole::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MusicalWorkContributorRole.enum_value)
  return _internal_enum_value();
}
inline void MusicalWorkContributorRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MusicalWorkContributorRole.enum_value)
}
inline std::string* MusicalWorkContributorRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MusicalWorkContributorRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MusicalWorkContributorRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MusicalWorkContributorRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MusicalWorkContributorRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MusicalWorkContributorRole.enum_value)
}
inline void MusicalWorkContributorRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MusicalWorkContributorRole.enum_value)
}
inline void MusicalWorkContributorRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MusicalWorkContributorRole.enum_value)
}
inline std::string* MusicalWorkContributorRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MusicalWorkContributorRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MusicalWorkContributorRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MusicalWorkContributorRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MusicalWorkContributorRole.enum_value)
}

// -------------------------------------------------------------------

// MusicalWorkType

// optional string enum_value = 1;
inline bool MusicalWorkType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MusicalWorkType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MusicalWorkType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MusicalWorkType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MusicalWorkType.enum_value)
  return _internal_enum_value();
}
inline void MusicalWorkType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MusicalWorkType.enum_value)
}
inline std::string* MusicalWorkType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MusicalWorkType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MusicalWorkType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MusicalWorkType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MusicalWorkType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MusicalWorkType.enum_value)
}
inline void MusicalWorkType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MusicalWorkType.enum_value)
}
inline void MusicalWorkType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MusicalWorkType.enum_value)
}
inline std::string* MusicalWorkType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MusicalWorkType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MusicalWorkType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MusicalWorkType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MusicalWorkType.enum_value)
}

// -------------------------------------------------------------------

// MwnlFileStatus

// optional string enum_value = 1;
inline bool MwnlFileStatus::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MwnlFileStatus::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MwnlFileStatus::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MwnlFileStatus::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MwnlFileStatus.enum_value)
  return _internal_enum_value();
}
inline void MwnlFileStatus::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MwnlFileStatus.enum_value)
}
inline std::string* MwnlFileStatus::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MwnlFileStatus.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MwnlFileStatus::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MwnlFileStatus::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MwnlFileStatus::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MwnlFileStatus.enum_value)
}
inline void MwnlFileStatus::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MwnlFileStatus.enum_value)
}
inline void MwnlFileStatus::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MwnlFileStatus.enum_value)
}
inline std::string* MwnlFileStatus::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MwnlFileStatus::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MwnlFileStatus.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MwnlFileStatus::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MwnlFileStatus.enum_value)
}

// -------------------------------------------------------------------

// MwnlProposedActionType

// optional string enum_value = 1;
inline bool MwnlProposedActionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MwnlProposedActionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void MwnlProposedActionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MwnlProposedActionType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.MwnlProposedActionType.enum_value)
  return _internal_enum_value();
}
inline void MwnlProposedActionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.MwnlProposedActionType.enum_value)
}
inline std::string* MwnlProposedActionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.MwnlProposedActionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& MwnlProposedActionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void MwnlProposedActionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MwnlProposedActionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.MwnlProposedActionType.enum_value)
}
inline void MwnlProposedActionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.MwnlProposedActionType.enum_value)
}
inline void MwnlProposedActionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.MwnlProposedActionType.enum_value)
}
inline std::string* MwnlProposedActionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MwnlProposedActionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.MwnlProposedActionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MwnlProposedActionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.MwnlProposedActionType.enum_value)
}

// -------------------------------------------------------------------

// NewStudioRole

// optional string enum_value = 1;
inline bool NewStudioRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NewStudioRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void NewStudioRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NewStudioRole::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.NewStudioRole.enum_value)
  return _internal_enum_value();
}
inline void NewStudioRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.NewStudioRole.enum_value)
}
inline std::string* NewStudioRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.NewStudioRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& NewStudioRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void NewStudioRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NewStudioRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.NewStudioRole.enum_value)
}
inline void NewStudioRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.NewStudioRole.enum_value)
}
inline void NewStudioRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.NewStudioRole.enum_value)
}
inline std::string* NewStudioRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NewStudioRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.NewStudioRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NewStudioRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.NewStudioRole.enum_value)
}

// -------------------------------------------------------------------

// OperatingSystemType

// optional string enum_value = 1;
inline bool OperatingSystemType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OperatingSystemType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void OperatingSystemType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OperatingSystemType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.OperatingSystemType.enum_value)
  return _internal_enum_value();
}
inline void OperatingSystemType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.OperatingSystemType.enum_value)
}
inline std::string* OperatingSystemType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.OperatingSystemType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& OperatingSystemType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void OperatingSystemType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void OperatingSystemType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.OperatingSystemType.enum_value)
}
inline void OperatingSystemType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.OperatingSystemType.enum_value)
}
inline void OperatingSystemType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.OperatingSystemType.enum_value)
}
inline std::string* OperatingSystemType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* OperatingSystemType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.OperatingSystemType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void OperatingSystemType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.OperatingSystemType.enum_value)
}

// -------------------------------------------------------------------

// PLineType

// optional string enum_value = 1;
inline bool PLineType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PLineType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void PLineType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PLineType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.PLineType.enum_value)
  return _internal_enum_value();
}
inline void PLineType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.PLineType.enum_value)
}
inline std::string* PLineType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.PLineType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& PLineType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void PLineType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PLineType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.PLineType.enum_value)
}
inline void PLineType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.PLineType.enum_value)
}
inline void PLineType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.PLineType.enum_value)
}
inline std::string* PLineType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PLineType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.PLineType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PLineType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.PLineType.enum_value)
}

// -------------------------------------------------------------------

// ParentalWarningType

// optional string enum_value = 1;
inline bool ParentalWarningType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ParentalWarningType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ParentalWarningType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ParentalWarningType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ParentalWarningType.enum_value)
  return _internal_enum_value();
}
inline void ParentalWarningType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ParentalWarningType.enum_value)
}
inline std::string* ParentalWarningType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ParentalWarningType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ParentalWarningType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ParentalWarningType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ParentalWarningType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ParentalWarningType.enum_value)
}
inline void ParentalWarningType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ParentalWarningType.enum_value)
}
inline void ParentalWarningType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ParentalWarningType.enum_value)
}
inline std::string* ParentalWarningType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ParentalWarningType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ParentalWarningType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ParentalWarningType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ParentalWarningType.enum_value)
}

// -------------------------------------------------------------------

// PartyRelationshipType

// optional string enum_value = 1;
inline bool PartyRelationshipType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PartyRelationshipType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void PartyRelationshipType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartyRelationshipType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.PartyRelationshipType.enum_value)
  return _internal_enum_value();
}
inline void PartyRelationshipType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.PartyRelationshipType.enum_value)
}
inline std::string* PartyRelationshipType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.PartyRelationshipType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& PartyRelationshipType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void PartyRelationshipType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PartyRelationshipType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.PartyRelationshipType.enum_value)
}
inline void PartyRelationshipType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.PartyRelationshipType.enum_value)
}
inline void PartyRelationshipType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.PartyRelationshipType.enum_value)
}
inline std::string* PartyRelationshipType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PartyRelationshipType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.PartyRelationshipType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PartyRelationshipType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.PartyRelationshipType.enum_value)
}

// -------------------------------------------------------------------

// PercentageType

// optional string enum_value = 1;
inline bool PercentageType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PercentageType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void PercentageType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PercentageType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.PercentageType.enum_value)
  return _internal_enum_value();
}
inline void PercentageType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.PercentageType.enum_value)
}
inline std::string* PercentageType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.PercentageType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& PercentageType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void PercentageType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PercentageType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.PercentageType.enum_value)
}
inline void PercentageType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.PercentageType.enum_value)
}
inline void PercentageType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.PercentageType.enum_value)
}
inline std::string* PercentageType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PercentageType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.PercentageType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PercentageType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.PercentageType.enum_value)
}

// -------------------------------------------------------------------

// Period

// optional string enum_value = 1;
inline bool Period::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Period::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void Period::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Period::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.Period.enum_value)
  return _internal_enum_value();
}
inline void Period::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.Period.enum_value)
}
inline std::string* Period::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.Period.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& Period::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void Period::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Period::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.Period.enum_value)
}
inline void Period::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.Period.enum_value)
}
inline void Period::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.Period.enum_value)
}
inline std::string* Period::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Period::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.Period.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Period::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.Period.enum_value)
}

// -------------------------------------------------------------------

// PhysicalCarrierType

// optional string enum_value = 1;
inline bool PhysicalCarrierType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PhysicalCarrierType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void PhysicalCarrierType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PhysicalCarrierType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.PhysicalCarrierType.enum_value)
  return _internal_enum_value();
}
inline void PhysicalCarrierType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.PhysicalCarrierType.enum_value)
}
inline std::string* PhysicalCarrierType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.PhysicalCarrierType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& PhysicalCarrierType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void PhysicalCarrierType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PhysicalCarrierType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.PhysicalCarrierType.enum_value)
}
inline void PhysicalCarrierType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.PhysicalCarrierType.enum_value)
}
inline void PhysicalCarrierType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.PhysicalCarrierType.enum_value)
}
inline std::string* PhysicalCarrierType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PhysicalCarrierType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.PhysicalCarrierType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PhysicalCarrierType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.PhysicalCarrierType.enum_value)
}

// -------------------------------------------------------------------

// PriceInformationType

// optional string enum_value = 1;
inline bool PriceInformationType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PriceInformationType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void PriceInformationType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PriceInformationType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.PriceInformationType.enum_value)
  return _internal_enum_value();
}
inline void PriceInformationType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.PriceInformationType.enum_value)
}
inline std::string* PriceInformationType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.PriceInformationType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& PriceInformationType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void PriceInformationType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PriceInformationType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.PriceInformationType.enum_value)
}
inline void PriceInformationType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.PriceInformationType.enum_value)
}
inline void PriceInformationType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.PriceInformationType.enum_value)
}
inline std::string* PriceInformationType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PriceInformationType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.PriceInformationType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PriceInformationType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.PriceInformationType.enum_value)
}

// -------------------------------------------------------------------

// ProductType

// optional string enum_value = 1;
inline bool ProductType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProductType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ProductType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProductType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ProductType.enum_value)
  return _internal_enum_value();
}
inline void ProductType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ProductType.enum_value)
}
inline std::string* ProductType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ProductType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ProductType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ProductType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProductType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ProductType.enum_value)
}
inline void ProductType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ProductType.enum_value)
}
inline void ProductType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ProductType.enum_value)
}
inline std::string* ProductType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProductType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ProductType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProductType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ProductType.enum_value)
}

// -------------------------------------------------------------------

// ProfileId

// optional string enum_value = 1;
inline bool ProfileId::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProfileId::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ProfileId::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProfileId::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ProfileId.enum_value)
  return _internal_enum_value();
}
inline void ProfileId::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ProfileId.enum_value)
}
inline std::string* ProfileId::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ProfileId.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ProfileId::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ProfileId::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProfileId::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ProfileId.enum_value)
}
inline void ProfileId::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ProfileId.enum_value)
}
inline void ProfileId::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ProfileId.enum_value)
}
inline std::string* ProfileId::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProfileId::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ProfileId.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProfileId::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ProfileId.enum_value)
}

// -------------------------------------------------------------------

// Purpose

// optional string enum_value = 1;
inline bool Purpose::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Purpose::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void Purpose::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Purpose::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.Purpose.enum_value)
  return _internal_enum_value();
}
inline void Purpose::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.Purpose.enum_value)
}
inline std::string* Purpose::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.Purpose.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& Purpose::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void Purpose::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Purpose::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.Purpose.enum_value)
}
inline void Purpose::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.Purpose.enum_value)
}
inline void Purpose::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.Purpose.enum_value)
}
inline std::string* Purpose::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Purpose::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.Purpose.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Purpose::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.Purpose.enum_value)
}

// -------------------------------------------------------------------

// RatingAgency

// optional string enum_value = 1;
inline bool RatingAgency::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RatingAgency::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RatingAgency::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RatingAgency::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RatingAgency.enum_value)
  return _internal_enum_value();
}
inline void RatingAgency::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RatingAgency.enum_value)
}
inline std::string* RatingAgency::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RatingAgency.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RatingAgency::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RatingAgency::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RatingAgency::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RatingAgency.enum_value)
}
inline void RatingAgency::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RatingAgency.enum_value)
}
inline void RatingAgency::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RatingAgency.enum_value)
}
inline std::string* RatingAgency::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RatingAgency::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RatingAgency.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RatingAgency::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RatingAgency.enum_value)
}

// -------------------------------------------------------------------

// RatingReason

// optional string enum_value = 1;
inline bool RatingReason::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RatingReason::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RatingReason::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RatingReason::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RatingReason.enum_value)
  return _internal_enum_value();
}
inline void RatingReason::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RatingReason.enum_value)
}
inline std::string* RatingReason::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RatingReason.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RatingReason::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RatingReason::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RatingReason::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RatingReason.enum_value)
}
inline void RatingReason::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RatingReason.enum_value)
}
inline void RatingReason::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RatingReason.enum_value)
}
inline std::string* RatingReason::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RatingReason::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RatingReason.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RatingReason::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RatingReason.enum_value)
}

// -------------------------------------------------------------------

// RecipientRevenueType

// optional string enum_value = 1;
inline bool RecipientRevenueType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RecipientRevenueType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RecipientRevenueType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecipientRevenueType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RecipientRevenueType.enum_value)
  return _internal_enum_value();
}
inline void RecipientRevenueType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RecipientRevenueType.enum_value)
}
inline std::string* RecipientRevenueType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RecipientRevenueType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RecipientRevenueType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RecipientRevenueType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RecipientRevenueType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RecipientRevenueType.enum_value)
}
inline void RecipientRevenueType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RecipientRevenueType.enum_value)
}
inline void RecipientRevenueType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RecipientRevenueType.enum_value)
}
inline std::string* RecipientRevenueType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RecipientRevenueType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RecipientRevenueType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RecipientRevenueType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RecipientRevenueType.enum_value)
}

// -------------------------------------------------------------------

// RecordingMode

// optional string enum_value = 1;
inline bool RecordingMode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RecordingMode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RecordingMode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordingMode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RecordingMode.enum_value)
  return _internal_enum_value();
}
inline void RecordingMode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RecordingMode.enum_value)
}
inline std::string* RecordingMode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RecordingMode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RecordingMode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RecordingMode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RecordingMode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RecordingMode.enum_value)
}
inline void RecordingMode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RecordingMode.enum_value)
}
inline void RecordingMode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RecordingMode.enum_value)
}
inline std::string* RecordingMode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RecordingMode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RecordingMode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RecordingMode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RecordingMode.enum_value)
}

// -------------------------------------------------------------------

// RecordingPartType

// optional string enum_value = 1;
inline bool RecordingPartType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RecordingPartType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RecordingPartType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordingPartType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RecordingPartType.enum_value)
  return _internal_enum_value();
}
inline void RecordingPartType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RecordingPartType.enum_value)
}
inline std::string* RecordingPartType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RecordingPartType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RecordingPartType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RecordingPartType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RecordingPartType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RecordingPartType.enum_value)
}
inline void RecordingPartType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RecordingPartType.enum_value)
}
inline void RecordingPartType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RecordingPartType.enum_value)
}
inline std::string* RecordingPartType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RecordingPartType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RecordingPartType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RecordingPartType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RecordingPartType.enum_value)
}

// -------------------------------------------------------------------

// ReferenceCreation

// optional string enum_value = 1;
inline bool ReferenceCreation::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReferenceCreation::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReferenceCreation::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReferenceCreation::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ReferenceCreation.enum_value)
  return _internal_enum_value();
}
inline void ReferenceCreation::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ReferenceCreation.enum_value)
}
inline std::string* ReferenceCreation::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ReferenceCreation.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReferenceCreation::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReferenceCreation::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReferenceCreation::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ReferenceCreation.enum_value)
}
inline void ReferenceCreation::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ReferenceCreation.enum_value)
}
inline void ReferenceCreation::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ReferenceCreation.enum_value)
}
inline std::string* ReferenceCreation::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReferenceCreation::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ReferenceCreation.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReferenceCreation::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ReferenceCreation.enum_value)
}

// -------------------------------------------------------------------

// ReferenceUnit

// optional string enum_value = 1;
inline bool ReferenceUnit::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReferenceUnit::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReferenceUnit::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReferenceUnit::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ReferenceUnit.enum_value)
  return _internal_enum_value();
}
inline void ReferenceUnit::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ReferenceUnit.enum_value)
}
inline std::string* ReferenceUnit::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ReferenceUnit.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReferenceUnit::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReferenceUnit::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReferenceUnit::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ReferenceUnit.enum_value)
}
inline void ReferenceUnit::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ReferenceUnit.enum_value)
}
inline void ReferenceUnit::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ReferenceUnit.enum_value)
}
inline std::string* ReferenceUnit::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReferenceUnit::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ReferenceUnit.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReferenceUnit::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ReferenceUnit.enum_value)
}

// -------------------------------------------------------------------

// RegistrationStatus

// optional string enum_value = 1;
inline bool RegistrationStatus::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegistrationStatus::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RegistrationStatus::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegistrationStatus::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RegistrationStatus.enum_value)
  return _internal_enum_value();
}
inline void RegistrationStatus::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RegistrationStatus.enum_value)
}
inline std::string* RegistrationStatus::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RegistrationStatus.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RegistrationStatus::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RegistrationStatus::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RegistrationStatus::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RegistrationStatus.enum_value)
}
inline void RegistrationStatus::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RegistrationStatus.enum_value)
}
inline void RegistrationStatus::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RegistrationStatus.enum_value)
}
inline std::string* RegistrationStatus::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RegistrationStatus::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RegistrationStatus.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RegistrationStatus::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RegistrationStatus.enum_value)
}

// -------------------------------------------------------------------

// RelatedResourceType

// optional string enum_value = 1;
inline bool RelatedResourceType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RelatedResourceType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RelatedResourceType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RelatedResourceType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RelatedResourceType.enum_value)
  return _internal_enum_value();
}
inline void RelatedResourceType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RelatedResourceType.enum_value)
}
inline std::string* RelatedResourceType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RelatedResourceType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RelatedResourceType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RelatedResourceType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RelatedResourceType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RelatedResourceType.enum_value)
}
inline void RelatedResourceType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RelatedResourceType.enum_value)
}
inline void RelatedResourceType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RelatedResourceType.enum_value)
}
inline std::string* RelatedResourceType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RelatedResourceType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RelatedResourceType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RelatedResourceType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RelatedResourceType.enum_value)
}

// -------------------------------------------------------------------

// RelationalRelator

// optional string enum_value = 1;
inline bool RelationalRelator::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RelationalRelator::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RelationalRelator::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RelationalRelator::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RelationalRelator.enum_value)
  return _internal_enum_value();
}
inline void RelationalRelator::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RelationalRelator.enum_value)
}
inline std::string* RelationalRelator::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RelationalRelator.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RelationalRelator::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RelationalRelator::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RelationalRelator::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RelationalRelator.enum_value)
}
inline void RelationalRelator::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RelationalRelator.enum_value)
}
inline void RelationalRelator::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RelationalRelator.enum_value)
}
inline std::string* RelationalRelator::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RelationalRelator::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RelationalRelator.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RelationalRelator::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RelationalRelator.enum_value)
}

// -------------------------------------------------------------------

// ReleaseProfileVariantVersionId

// optional string enum_value = 1;
inline bool ReleaseProfileVariantVersionId::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReleaseProfileVariantVersionId::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReleaseProfileVariantVersionId::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReleaseProfileVariantVersionId::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ReleaseProfileVariantVersionId.enum_value)
  return _internal_enum_value();
}
inline void ReleaseProfileVariantVersionId::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ReleaseProfileVariantVersionId.enum_value)
}
inline std::string* ReleaseProfileVariantVersionId::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ReleaseProfileVariantVersionId.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReleaseProfileVariantVersionId::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReleaseProfileVariantVersionId::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReleaseProfileVariantVersionId::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ReleaseProfileVariantVersionId.enum_value)
}
inline void ReleaseProfileVariantVersionId::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ReleaseProfileVariantVersionId.enum_value)
}
inline void ReleaseProfileVariantVersionId::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ReleaseProfileVariantVersionId.enum_value)
}
inline std::string* ReleaseProfileVariantVersionId::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReleaseProfileVariantVersionId::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ReleaseProfileVariantVersionId.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReleaseProfileVariantVersionId::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ReleaseProfileVariantVersionId.enum_value)
}

// -------------------------------------------------------------------

// ReleaseProfileVersionId

// optional string enum_value = 1;
inline bool ReleaseProfileVersionId::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReleaseProfileVersionId::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReleaseProfileVersionId::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReleaseProfileVersionId::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ReleaseProfileVersionId.enum_value)
  return _internal_enum_value();
}
inline void ReleaseProfileVersionId::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ReleaseProfileVersionId.enum_value)
}
inline std::string* ReleaseProfileVersionId::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ReleaseProfileVersionId.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReleaseProfileVersionId::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReleaseProfileVersionId::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReleaseProfileVersionId::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ReleaseProfileVersionId.enum_value)
}
inline void ReleaseProfileVersionId::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ReleaseProfileVersionId.enum_value)
}
inline void ReleaseProfileVersionId::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ReleaseProfileVersionId.enum_value)
}
inline std::string* ReleaseProfileVersionId::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReleaseProfileVersionId::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ReleaseProfileVersionId.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReleaseProfileVersionId::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ReleaseProfileVersionId.enum_value)
}

// -------------------------------------------------------------------

// ReleaseRelationshipType

// optional string enum_value = 1;
inline bool ReleaseRelationshipType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReleaseRelationshipType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReleaseRelationshipType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReleaseRelationshipType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ReleaseRelationshipType.enum_value)
  return _internal_enum_value();
}
inline void ReleaseRelationshipType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ReleaseRelationshipType.enum_value)
}
inline std::string* ReleaseRelationshipType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ReleaseRelationshipType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReleaseRelationshipType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReleaseRelationshipType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReleaseRelationshipType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ReleaseRelationshipType.enum_value)
}
inline void ReleaseRelationshipType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ReleaseRelationshipType.enum_value)
}
inline void ReleaseRelationshipType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ReleaseRelationshipType.enum_value)
}
inline std::string* ReleaseRelationshipType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReleaseRelationshipType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ReleaseRelationshipType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReleaseRelationshipType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ReleaseRelationshipType.enum_value)
}

// -------------------------------------------------------------------

// ReleaseResourceType

// optional string enum_value = 1;
inline bool ReleaseResourceType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReleaseResourceType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReleaseResourceType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReleaseResourceType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ReleaseResourceType.enum_value)
  return _internal_enum_value();
}
inline void ReleaseResourceType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ReleaseResourceType.enum_value)
}
inline std::string* ReleaseResourceType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ReleaseResourceType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReleaseResourceType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReleaseResourceType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReleaseResourceType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ReleaseResourceType.enum_value)
}
inline void ReleaseResourceType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ReleaseResourceType.enum_value)
}
inline void ReleaseResourceType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ReleaseResourceType.enum_value)
}
inline std::string* ReleaseResourceType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReleaseResourceType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ReleaseResourceType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReleaseResourceType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ReleaseResourceType.enum_value)
}

// -------------------------------------------------------------------

// ReleaseType

// optional string enum_value = 1;
inline bool ReleaseType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReleaseType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReleaseType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReleaseType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ReleaseType.enum_value)
  return _internal_enum_value();
}
inline void ReleaseType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ReleaseType.enum_value)
}
inline std::string* ReleaseType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ReleaseType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReleaseType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReleaseType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReleaseType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ReleaseType.enum_value)
}
inline void ReleaseType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ReleaseType.enum_value)
}
inline void ReleaseType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ReleaseType.enum_value)
}
inline std::string* ReleaseType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReleaseType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ReleaseType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReleaseType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ReleaseType.enum_value)
}

// -------------------------------------------------------------------

// ReleaseType_ERN4

// optional string enum_value = 1;
inline bool ReleaseType_ERN4::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReleaseType_ERN4::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReleaseType_ERN4::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReleaseType_ERN4::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ReleaseType_ERN4.enum_value)
  return _internal_enum_value();
}
inline void ReleaseType_ERN4::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ReleaseType_ERN4.enum_value)
}
inline std::string* ReleaseType_ERN4::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ReleaseType_ERN4.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReleaseType_ERN4::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReleaseType_ERN4::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReleaseType_ERN4::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ReleaseType_ERN4.enum_value)
}
inline void ReleaseType_ERN4::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ReleaseType_ERN4.enum_value)
}
inline void ReleaseType_ERN4::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ReleaseType_ERN4.enum_value)
}
inline std::string* ReleaseType_ERN4::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReleaseType_ERN4::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ReleaseType_ERN4.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReleaseType_ERN4::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ReleaseType_ERN4.enum_value)
}

// -------------------------------------------------------------------

// ReleaseType_MCNOTIF

// optional string enum_value = 1;
inline bool ReleaseType_MCNOTIF::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReleaseType_MCNOTIF::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ReleaseType_MCNOTIF::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReleaseType_MCNOTIF::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ReleaseType_MCNOTIF.enum_value)
  return _internal_enum_value();
}
inline void ReleaseType_MCNOTIF::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ReleaseType_MCNOTIF.enum_value)
}
inline std::string* ReleaseType_MCNOTIF::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ReleaseType_MCNOTIF.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ReleaseType_MCNOTIF::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ReleaseType_MCNOTIF::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReleaseType_MCNOTIF::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ReleaseType_MCNOTIF.enum_value)
}
inline void ReleaseType_MCNOTIF::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ReleaseType_MCNOTIF.enum_value)
}
inline void ReleaseType_MCNOTIF::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ReleaseType_MCNOTIF.enum_value)
}
inline std::string* ReleaseType_MCNOTIF::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReleaseType_MCNOTIF::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ReleaseType_MCNOTIF.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReleaseType_MCNOTIF::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ReleaseType_MCNOTIF.enum_value)
}

// -------------------------------------------------------------------

// RequestMessagePurpose

// optional string enum_value = 1;
inline bool RequestMessagePurpose::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestMessagePurpose::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RequestMessagePurpose::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestMessagePurpose::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RequestMessagePurpose.enum_value)
  return _internal_enum_value();
}
inline void RequestMessagePurpose::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RequestMessagePurpose.enum_value)
}
inline std::string* RequestMessagePurpose::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RequestMessagePurpose.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RequestMessagePurpose::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RequestMessagePurpose::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RequestMessagePurpose::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RequestMessagePurpose.enum_value)
}
inline void RequestMessagePurpose::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RequestMessagePurpose.enum_value)
}
inline void RequestMessagePurpose::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RequestMessagePurpose.enum_value)
}
inline std::string* RequestMessagePurpose::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RequestMessagePurpose::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RequestMessagePurpose.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RequestMessagePurpose::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RequestMessagePurpose.enum_value)
}

// -------------------------------------------------------------------

// RequestReason

// optional string enum_value = 1;
inline bool RequestReason::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestReason::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RequestReason::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestReason::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RequestReason.enum_value)
  return _internal_enum_value();
}
inline void RequestReason::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RequestReason.enum_value)
}
inline std::string* RequestReason::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RequestReason.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RequestReason::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RequestReason::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RequestReason::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RequestReason.enum_value)
}
inline void RequestReason::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RequestReason.enum_value)
}
inline void RequestReason::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RequestReason.enum_value)
}
inline std::string* RequestReason::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RequestReason::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RequestReason.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RequestReason::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RequestReason.enum_value)
}

// -------------------------------------------------------------------

// ResourceContributorRole

// optional string enum_value = 1;
inline bool ResourceContributorRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResourceContributorRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ResourceContributorRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceContributorRole::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ResourceContributorRole.enum_value)
  return _internal_enum_value();
}
inline void ResourceContributorRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ResourceContributorRole.enum_value)
}
inline std::string* ResourceContributorRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ResourceContributorRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ResourceContributorRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ResourceContributorRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ResourceContributorRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ResourceContributorRole.enum_value)
}
inline void ResourceContributorRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ResourceContributorRole.enum_value)
}
inline void ResourceContributorRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ResourceContributorRole.enum_value)
}
inline std::string* ResourceContributorRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ResourceContributorRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ResourceContributorRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ResourceContributorRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ResourceContributorRole.enum_value)
}

// -------------------------------------------------------------------

// ResourceGroupType

// optional string enum_value = 1;
inline bool ResourceGroupType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResourceGroupType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ResourceGroupType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceGroupType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ResourceGroupType.enum_value)
  return _internal_enum_value();
}
inline void ResourceGroupType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ResourceGroupType.enum_value)
}
inline std::string* ResourceGroupType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ResourceGroupType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ResourceGroupType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ResourceGroupType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ResourceGroupType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ResourceGroupType.enum_value)
}
inline void ResourceGroupType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ResourceGroupType.enum_value)
}
inline void ResourceGroupType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ResourceGroupType.enum_value)
}
inline std::string* ResourceGroupType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ResourceGroupType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ResourceGroupType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ResourceGroupType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ResourceGroupType.enum_value)
}

// -------------------------------------------------------------------

// ResourceRelationshipType

// optional string enum_value = 1;
inline bool ResourceRelationshipType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResourceRelationshipType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ResourceRelationshipType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceRelationshipType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ResourceRelationshipType.enum_value)
  return _internal_enum_value();
}
inline void ResourceRelationshipType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ResourceRelationshipType.enum_value)
}
inline std::string* ResourceRelationshipType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ResourceRelationshipType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ResourceRelationshipType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ResourceRelationshipType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ResourceRelationshipType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ResourceRelationshipType.enum_value)
}
inline void ResourceRelationshipType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ResourceRelationshipType.enum_value)
}
inline void ResourceRelationshipType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ResourceRelationshipType.enum_value)
}
inline std::string* ResourceRelationshipType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ResourceRelationshipType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ResourceRelationshipType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ResourceRelationshipType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ResourceRelationshipType.enum_value)
}

// -------------------------------------------------------------------

// ResourceType

// optional string enum_value = 1;
inline bool ResourceType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResourceType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ResourceType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ResourceType.enum_value)
  return _internal_enum_value();
}
inline void ResourceType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ResourceType.enum_value)
}
inline std::string* ResourceType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ResourceType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ResourceType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ResourceType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ResourceType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ResourceType.enum_value)
}
inline void ResourceType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ResourceType.enum_value)
}
inline void ResourceType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ResourceType.enum_value)
}
inline std::string* ResourceType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ResourceType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ResourceType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ResourceType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ResourceType.enum_value)
}

// -------------------------------------------------------------------

// ResourceType_MCNOTIF

// optional string enum_value = 1;
inline bool ResourceType_MCNOTIF::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResourceType_MCNOTIF::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ResourceType_MCNOTIF::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceType_MCNOTIF::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ResourceType_MCNOTIF.enum_value)
  return _internal_enum_value();
}
inline void ResourceType_MCNOTIF::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ResourceType_MCNOTIF.enum_value)
}
inline std::string* ResourceType_MCNOTIF::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ResourceType_MCNOTIF.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ResourceType_MCNOTIF::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ResourceType_MCNOTIF::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ResourceType_MCNOTIF::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ResourceType_MCNOTIF.enum_value)
}
inline void ResourceType_MCNOTIF::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ResourceType_MCNOTIF.enum_value)
}
inline void ResourceType_MCNOTIF::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ResourceType_MCNOTIF.enum_value)
}
inline std::string* ResourceType_MCNOTIF::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ResourceType_MCNOTIF::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ResourceType_MCNOTIF.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ResourceType_MCNOTIF::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ResourceType_MCNOTIF.enum_value)
}

// -------------------------------------------------------------------

// ResourceWorkRelationshipType

// optional string enum_value = 1;
inline bool ResourceWorkRelationshipType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResourceWorkRelationshipType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ResourceWorkRelationshipType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceWorkRelationshipType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ResourceWorkRelationshipType.enum_value)
  return _internal_enum_value();
}
inline void ResourceWorkRelationshipType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ResourceWorkRelationshipType.enum_value)
}
inline std::string* ResourceWorkRelationshipType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ResourceWorkRelationshipType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ResourceWorkRelationshipType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ResourceWorkRelationshipType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ResourceWorkRelationshipType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ResourceWorkRelationshipType.enum_value)
}
inline void ResourceWorkRelationshipType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ResourceWorkRelationshipType.enum_value)
}
inline void ResourceWorkRelationshipType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ResourceWorkRelationshipType.enum_value)
}
inline std::string* ResourceWorkRelationshipType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ResourceWorkRelationshipType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ResourceWorkRelationshipType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ResourceWorkRelationshipType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ResourceWorkRelationshipType.enum_value)
}

// -------------------------------------------------------------------

// RevenueSourceType

// optional string enum_value = 1;
inline bool RevenueSourceType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RevenueSourceType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RevenueSourceType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RevenueSourceType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RevenueSourceType.enum_value)
  return _internal_enum_value();
}
inline void RevenueSourceType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RevenueSourceType.enum_value)
}
inline std::string* RevenueSourceType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RevenueSourceType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RevenueSourceType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RevenueSourceType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RevenueSourceType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RevenueSourceType.enum_value)
}
inline void RevenueSourceType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RevenueSourceType.enum_value)
}
inline void RevenueSourceType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RevenueSourceType.enum_value)
}
inline std::string* RevenueSourceType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RevenueSourceType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RevenueSourceType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RevenueSourceType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RevenueSourceType.enum_value)
}

// -------------------------------------------------------------------

// RightShareType

// optional string enum_value = 1;
inline bool RightShareType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RightShareType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RightShareType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RightShareType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RightShareType.enum_value)
  return _internal_enum_value();
}
inline void RightShareType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RightShareType.enum_value)
}
inline std::string* RightShareType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RightShareType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RightShareType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RightShareType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RightShareType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RightShareType.enum_value)
}
inline void RightShareType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RightShareType.enum_value)
}
inline void RightShareType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RightShareType.enum_value)
}
inline std::string* RightShareType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RightShareType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RightShareType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RightShareType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RightShareType.enum_value)
}

// -------------------------------------------------------------------

// RightsClaimPolicyType

// optional string enum_value = 1;
inline bool RightsClaimPolicyType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RightsClaimPolicyType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RightsClaimPolicyType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RightsClaimPolicyType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RightsClaimPolicyType.enum_value)
  return _internal_enum_value();
}
inline void RightsClaimPolicyType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RightsClaimPolicyType.enum_value)
}
inline std::string* RightsClaimPolicyType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RightsClaimPolicyType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RightsClaimPolicyType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RightsClaimPolicyType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RightsClaimPolicyType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RightsClaimPolicyType.enum_value)
}
inline void RightsClaimPolicyType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RightsClaimPolicyType.enum_value)
}
inline void RightsClaimPolicyType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RightsClaimPolicyType.enum_value)
}
inline std::string* RightsClaimPolicyType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RightsClaimPolicyType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RightsClaimPolicyType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RightsClaimPolicyType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RightsClaimPolicyType.enum_value)
}

// -------------------------------------------------------------------

// RightsClaimStatus

// optional string enum_value = 1;
inline bool RightsClaimStatus::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RightsClaimStatus::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RightsClaimStatus::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RightsClaimStatus::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RightsClaimStatus.enum_value)
  return _internal_enum_value();
}
inline void RightsClaimStatus::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RightsClaimStatus.enum_value)
}
inline std::string* RightsClaimStatus::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RightsClaimStatus.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RightsClaimStatus::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RightsClaimStatus::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RightsClaimStatus::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RightsClaimStatus.enum_value)
}
inline void RightsClaimStatus::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RightsClaimStatus.enum_value)
}
inline void RightsClaimStatus::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RightsClaimStatus.enum_value)
}
inline std::string* RightsClaimStatus::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RightsClaimStatus::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RightsClaimStatus.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RightsClaimStatus::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RightsClaimStatus.enum_value)
}

// -------------------------------------------------------------------

// RightsControllerRole

// optional string enum_value = 1;
inline bool RightsControllerRole::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RightsControllerRole::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RightsControllerRole::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RightsControllerRole::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RightsControllerRole.enum_value)
  return _internal_enum_value();
}
inline void RightsControllerRole::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RightsControllerRole.enum_value)
}
inline std::string* RightsControllerRole::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RightsControllerRole.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RightsControllerRole::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RightsControllerRole::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RightsControllerRole::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RightsControllerRole.enum_value)
}
inline void RightsControllerRole::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RightsControllerRole.enum_value)
}
inline void RightsControllerRole::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RightsControllerRole.enum_value)
}
inline std::string* RightsControllerRole::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RightsControllerRole::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RightsControllerRole.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RightsControllerRole::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RightsControllerRole.enum_value)
}

// -------------------------------------------------------------------

// RightsControllerType

// optional string enum_value = 1;
inline bool RightsControllerType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RightsControllerType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RightsControllerType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RightsControllerType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RightsControllerType.enum_value)
  return _internal_enum_value();
}
inline void RightsControllerType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RightsControllerType.enum_value)
}
inline std::string* RightsControllerType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RightsControllerType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RightsControllerType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RightsControllerType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RightsControllerType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RightsControllerType.enum_value)
}
inline void RightsControllerType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RightsControllerType.enum_value)
}
inline void RightsControllerType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RightsControllerType.enum_value)
}
inline std::string* RightsControllerType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RightsControllerType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RightsControllerType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RightsControllerType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RightsControllerType.enum_value)
}

// -------------------------------------------------------------------

// RightsCoverage

// optional string enum_value = 1;
inline bool RightsCoverage::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RightsCoverage::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RightsCoverage::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RightsCoverage::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RightsCoverage.enum_value)
  return _internal_enum_value();
}
inline void RightsCoverage::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RightsCoverage.enum_value)
}
inline std::string* RightsCoverage::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RightsCoverage.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RightsCoverage::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RightsCoverage::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RightsCoverage::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RightsCoverage.enum_value)
}
inline void RightsCoverage::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RightsCoverage.enum_value)
}
inline void RightsCoverage::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RightsCoverage.enum_value)
}
inline std::string* RightsCoverage::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RightsCoverage::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RightsCoverage.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RightsCoverage::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RightsCoverage.enum_value)
}

// -------------------------------------------------------------------

// RightsCoverage_MWNL

// optional string enum_value = 1;
inline bool RightsCoverage_MWNL::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RightsCoverage_MWNL::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RightsCoverage_MWNL::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RightsCoverage_MWNL::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RightsCoverage_MWNL.enum_value)
  return _internal_enum_value();
}
inline void RightsCoverage_MWNL::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RightsCoverage_MWNL.enum_value)
}
inline std::string* RightsCoverage_MWNL::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RightsCoverage_MWNL.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RightsCoverage_MWNL::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RightsCoverage_MWNL::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RightsCoverage_MWNL::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RightsCoverage_MWNL.enum_value)
}
inline void RightsCoverage_MWNL::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RightsCoverage_MWNL.enum_value)
}
inline void RightsCoverage_MWNL::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RightsCoverage_MWNL.enum_value)
}
inline std::string* RightsCoverage_MWNL::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RightsCoverage_MWNL::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RightsCoverage_MWNL.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RightsCoverage_MWNL::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RightsCoverage_MWNL.enum_value)
}

// -------------------------------------------------------------------

// RightsStatementProfile

// optional string enum_value = 1;
inline bool RightsStatementProfile::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RightsStatementProfile::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RightsStatementProfile::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RightsStatementProfile::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RightsStatementProfile.enum_value)
  return _internal_enum_value();
}
inline void RightsStatementProfile::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RightsStatementProfile.enum_value)
}
inline std::string* RightsStatementProfile::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RightsStatementProfile.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RightsStatementProfile::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RightsStatementProfile::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RightsStatementProfile::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RightsStatementProfile.enum_value)
}
inline void RightsStatementProfile::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RightsStatementProfile.enum_value)
}
inline void RightsStatementProfile::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RightsStatementProfile.enum_value)
}
inline std::string* RightsStatementProfile::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RightsStatementProfile::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RightsStatementProfile.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RightsStatementProfile::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RightsStatementProfile.enum_value)
}

// -------------------------------------------------------------------

// RootChordNote

// optional string enum_value = 1;
inline bool RootChordNote::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RootChordNote::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RootChordNote::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RootChordNote::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RootChordNote.enum_value)
  return _internal_enum_value();
}
inline void RootChordNote::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RootChordNote.enum_value)
}
inline std::string* RootChordNote::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RootChordNote.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RootChordNote::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RootChordNote::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RootChordNote::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RootChordNote.enum_value)
}
inline void RootChordNote::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RootChordNote.enum_value)
}
inline void RootChordNote::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RootChordNote.enum_value)
}
inline std::string* RootChordNote::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RootChordNote::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RootChordNote.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RootChordNote::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RootChordNote.enum_value)
}

// -------------------------------------------------------------------

// RootChordQuality

// optional string enum_value = 1;
inline bool RootChordQuality::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RootChordQuality::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RootChordQuality::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RootChordQuality::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RootChordQuality.enum_value)
  return _internal_enum_value();
}
inline void RootChordQuality::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RootChordQuality.enum_value)
}
inline std::string* RootChordQuality::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RootChordQuality.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RootChordQuality::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RootChordQuality::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RootChordQuality::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RootChordQuality.enum_value)
}
inline void RootChordQuality::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RootChordQuality.enum_value)
}
inline void RootChordQuality::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RootChordQuality.enum_value)
}
inline std::string* RootChordQuality::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RootChordQuality::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RootChordQuality.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RootChordQuality::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RootChordQuality.enum_value)
}

// -------------------------------------------------------------------

// RoyaltyRateCalculationType

// optional string enum_value = 1;
inline bool RoyaltyRateCalculationType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoyaltyRateCalculationType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RoyaltyRateCalculationType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoyaltyRateCalculationType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RoyaltyRateCalculationType.enum_value)
  return _internal_enum_value();
}
inline void RoyaltyRateCalculationType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RoyaltyRateCalculationType.enum_value)
}
inline std::string* RoyaltyRateCalculationType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RoyaltyRateCalculationType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RoyaltyRateCalculationType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RoyaltyRateCalculationType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RoyaltyRateCalculationType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RoyaltyRateCalculationType.enum_value)
}
inline void RoyaltyRateCalculationType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RoyaltyRateCalculationType.enum_value)
}
inline void RoyaltyRateCalculationType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RoyaltyRateCalculationType.enum_value)
}
inline std::string* RoyaltyRateCalculationType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RoyaltyRateCalculationType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RoyaltyRateCalculationType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RoyaltyRateCalculationType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RoyaltyRateCalculationType.enum_value)
}

// -------------------------------------------------------------------

// RoyaltyRateType

// optional string enum_value = 1;
inline bool RoyaltyRateType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoyaltyRateType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void RoyaltyRateType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoyaltyRateType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.RoyaltyRateType.enum_value)
  return _internal_enum_value();
}
inline void RoyaltyRateType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.RoyaltyRateType.enum_value)
}
inline std::string* RoyaltyRateType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.RoyaltyRateType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& RoyaltyRateType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void RoyaltyRateType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RoyaltyRateType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.RoyaltyRateType.enum_value)
}
inline void RoyaltyRateType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.RoyaltyRateType.enum_value)
}
inline void RoyaltyRateType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.RoyaltyRateType.enum_value)
}
inline std::string* RoyaltyRateType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RoyaltyRateType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.RoyaltyRateType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RoyaltyRateType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.RoyaltyRateType.enum_value)
}

// -------------------------------------------------------------------

// SessionType

// optional string enum_value = 1;
inline bool SessionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SessionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void SessionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.SessionType.enum_value)
  return _internal_enum_value();
}
inline void SessionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.SessionType.enum_value)
}
inline std::string* SessionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.SessionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& SessionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void SessionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SessionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.SessionType.enum_value)
}
inline void SessionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.SessionType.enum_value)
}
inline void SessionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.SessionType.enum_value)
}
inline std::string* SessionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SessionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.SessionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SessionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.SessionType.enum_value)
}

// -------------------------------------------------------------------

// SheetMusicCodecType

// optional string enum_value = 1;
inline bool SheetMusicCodecType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SheetMusicCodecType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void SheetMusicCodecType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SheetMusicCodecType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.SheetMusicCodecType.enum_value)
  return _internal_enum_value();
}
inline void SheetMusicCodecType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.SheetMusicCodecType.enum_value)
}
inline std::string* SheetMusicCodecType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.SheetMusicCodecType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& SheetMusicCodecType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void SheetMusicCodecType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SheetMusicCodecType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.SheetMusicCodecType.enum_value)
}
inline void SheetMusicCodecType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.SheetMusicCodecType.enum_value)
}
inline void SheetMusicCodecType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.SheetMusicCodecType.enum_value)
}
inline std::string* SheetMusicCodecType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SheetMusicCodecType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.SheetMusicCodecType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SheetMusicCodecType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.SheetMusicCodecType.enum_value)
}

// -------------------------------------------------------------------

// SheetMusicType

// optional string enum_value = 1;
inline bool SheetMusicType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SheetMusicType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void SheetMusicType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SheetMusicType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.SheetMusicType.enum_value)
  return _internal_enum_value();
}
inline void SheetMusicType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.SheetMusicType.enum_value)
}
inline std::string* SheetMusicType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.SheetMusicType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& SheetMusicType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void SheetMusicType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SheetMusicType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.SheetMusicType.enum_value)
}
inline void SheetMusicType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.SheetMusicType.enum_value)
}
inline void SheetMusicType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.SheetMusicType.enum_value)
}
inline std::string* SheetMusicType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SheetMusicType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.SheetMusicType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SheetMusicType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.SheetMusicType.enum_value)
}

// -------------------------------------------------------------------

// SoftwareType

// optional string enum_value = 1;
inline bool SoftwareType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SoftwareType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void SoftwareType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SoftwareType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.SoftwareType.enum_value)
  return _internal_enum_value();
}
inline void SoftwareType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.SoftwareType.enum_value)
}
inline std::string* SoftwareType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.SoftwareType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& SoftwareType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void SoftwareType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SoftwareType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.SoftwareType.enum_value)
}
inline void SoftwareType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.SoftwareType.enum_value)
}
inline void SoftwareType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.SoftwareType.enum_value)
}
inline std::string* SoftwareType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SoftwareType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.SoftwareType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SoftwareType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.SoftwareType.enum_value)
}

// -------------------------------------------------------------------

// SoundRecordingType

// optional string enum_value = 1;
inline bool SoundRecordingType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SoundRecordingType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void SoundRecordingType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SoundRecordingType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.SoundRecordingType.enum_value)
  return _internal_enum_value();
}
inline void SoundRecordingType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.SoundRecordingType.enum_value)
}
inline std::string* SoundRecordingType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.SoundRecordingType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& SoundRecordingType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void SoundRecordingType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SoundRecordingType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.SoundRecordingType.enum_value)
}
inline void SoundRecordingType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.SoundRecordingType.enum_value)
}
inline void SoundRecordingType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.SoundRecordingType.enum_value)
}
inline std::string* SoundRecordingType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SoundRecordingType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.SoundRecordingType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SoundRecordingType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.SoundRecordingType.enum_value)
}

// -------------------------------------------------------------------

// Status

// optional string enum_value = 1;
inline bool Status::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Status::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void Status::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Status::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.Status.enum_value)
  return _internal_enum_value();
}
inline void Status::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.Status.enum_value)
}
inline std::string* Status::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.Status.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& Status::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void Status::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Status::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.Status.enum_value)
}
inline void Status::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.Status.enum_value)
}
inline void Status::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.Status.enum_value)
}
inline std::string* Status::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Status::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.Status.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Status::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.Status.enum_value)
}

// -------------------------------------------------------------------

// SubGenre

// optional string enum_value = 1;
inline bool SubGenre::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubGenre::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void SubGenre::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubGenre::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.SubGenre.enum_value)
  return _internal_enum_value();
}
inline void SubGenre::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.SubGenre.enum_value)
}
inline std::string* SubGenre::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.SubGenre.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& SubGenre::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void SubGenre::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubGenre::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.SubGenre.enum_value)
}
inline void SubGenre::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.SubGenre.enum_value)
}
inline void SubGenre::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.SubGenre.enum_value)
}
inline std::string* SubGenre::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubGenre::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.SubGenre.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubGenre::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.SubGenre.enum_value)
}

// -------------------------------------------------------------------

// SubTitleType

// optional string enum_value = 1;
inline bool SubTitleType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubTitleType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void SubTitleType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubTitleType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.SubTitleType.enum_value)
  return _internal_enum_value();
}
inline void SubTitleType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.SubTitleType.enum_value)
}
inline std::string* SubTitleType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.SubTitleType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& SubTitleType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void SubTitleType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubTitleType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.SubTitleType.enum_value)
}
inline void SubTitleType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.SubTitleType.enum_value)
}
inline void SubTitleType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.SubTitleType.enum_value)
}
inline std::string* SubTitleType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubTitleType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.SubTitleType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubTitleType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.SubTitleType.enum_value)
}

// -------------------------------------------------------------------

// SupplyChainStatus

// optional string enum_value = 1;
inline bool SupplyChainStatus::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SupplyChainStatus::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void SupplyChainStatus::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SupplyChainStatus::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.SupplyChainStatus.enum_value)
  return _internal_enum_value();
}
inline void SupplyChainStatus::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.SupplyChainStatus.enum_value)
}
inline std::string* SupplyChainStatus::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.SupplyChainStatus.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& SupplyChainStatus::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void SupplyChainStatus::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SupplyChainStatus::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.SupplyChainStatus.enum_value)
}
inline void SupplyChainStatus::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.SupplyChainStatus.enum_value)
}
inline void SupplyChainStatus::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.SupplyChainStatus.enum_value)
}
inline std::string* SupplyChainStatus::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SupplyChainStatus::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.SupplyChainStatus.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SupplyChainStatus::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.SupplyChainStatus.enum_value)
}

// -------------------------------------------------------------------

// Tempo

// optional string enum_value = 1;
inline bool Tempo::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Tempo::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void Tempo::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Tempo::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.Tempo.enum_value)
  return _internal_enum_value();
}
inline void Tempo::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.Tempo.enum_value)
}
inline std::string* Tempo::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.Tempo.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& Tempo::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void Tempo::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Tempo::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.Tempo.enum_value)
}
inline void Tempo::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.Tempo.enum_value)
}
inline void Tempo::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.Tempo.enum_value)
}
inline std::string* Tempo::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Tempo::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.Tempo.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Tempo::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.Tempo.enum_value)
}

// -------------------------------------------------------------------

// TerritoryCodeType

// optional string enum_value = 1;
inline bool TerritoryCodeType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TerritoryCodeType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TerritoryCodeType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TerritoryCodeType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.TerritoryCodeType.enum_value)
  return _internal_enum_value();
}
inline void TerritoryCodeType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.TerritoryCodeType.enum_value)
}
inline std::string* TerritoryCodeType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.TerritoryCodeType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TerritoryCodeType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TerritoryCodeType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TerritoryCodeType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.TerritoryCodeType.enum_value)
}
inline void TerritoryCodeType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.TerritoryCodeType.enum_value)
}
inline void TerritoryCodeType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.TerritoryCodeType.enum_value)
}
inline std::string* TerritoryCodeType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TerritoryCodeType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.TerritoryCodeType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TerritoryCodeType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.TerritoryCodeType.enum_value)
}

// -------------------------------------------------------------------

// TerritoryCodeTypeIncludingDeprecatedCodes

// optional string enum_value = 1;
inline bool TerritoryCodeTypeIncludingDeprecatedCodes::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TerritoryCodeTypeIncludingDeprecatedCodes::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TerritoryCodeTypeIncludingDeprecatedCodes::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
  return _internal_enum_value();
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
}
inline std::string* TerritoryCodeTypeIncludingDeprecatedCodes::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TerritoryCodeTypeIncludingDeprecatedCodes::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
}
inline std::string* TerritoryCodeTypeIncludingDeprecatedCodes::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TerritoryCodeTypeIncludingDeprecatedCodes::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TerritoryCodeTypeIncludingDeprecatedCodes::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.TerritoryCodeTypeIncludingDeprecatedCodes.enum_value)
}

// -------------------------------------------------------------------

// TextCodecType

// optional string enum_value = 1;
inline bool TextCodecType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TextCodecType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TextCodecType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextCodecType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.TextCodecType.enum_value)
  return _internal_enum_value();
}
inline void TextCodecType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.TextCodecType.enum_value)
}
inline std::string* TextCodecType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.TextCodecType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TextCodecType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TextCodecType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TextCodecType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.TextCodecType.enum_value)
}
inline void TextCodecType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.TextCodecType.enum_value)
}
inline void TextCodecType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.TextCodecType.enum_value)
}
inline std::string* TextCodecType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TextCodecType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.TextCodecType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextCodecType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.TextCodecType.enum_value)
}

// -------------------------------------------------------------------

// TextType

// optional string enum_value = 1;
inline bool TextType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TextType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TextType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.TextType.enum_value)
  return _internal_enum_value();
}
inline void TextType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.TextType.enum_value)
}
inline std::string* TextType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.TextType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TextType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TextType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TextType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.TextType.enum_value)
}
inline void TextType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.TextType.enum_value)
}
inline void TextType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.TextType.enum_value)
}
inline std::string* TextType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TextType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.TextType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.TextType.enum_value)
}

// -------------------------------------------------------------------

// TextType_ATOM

// optional string enum_value = 1;
inline bool TextType_ATOM::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TextType_ATOM::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TextType_ATOM::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextType_ATOM::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.TextType_ATOM.enum_value)
  return _internal_enum_value();
}
inline void TextType_ATOM::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.TextType_ATOM.enum_value)
}
inline std::string* TextType_ATOM::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.TextType_ATOM.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TextType_ATOM::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TextType_ATOM::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TextType_ATOM::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.TextType_ATOM.enum_value)
}
inline void TextType_ATOM::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.TextType_ATOM.enum_value)
}
inline void TextType_ATOM::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.TextType_ATOM.enum_value)
}
inline std::string* TextType_ATOM::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TextType_ATOM::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.TextType_ATOM.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextType_ATOM::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.TextType_ATOM.enum_value)
}

// -------------------------------------------------------------------

// Theme

// optional string enum_value = 1;
inline bool Theme::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Theme::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void Theme::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Theme::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.Theme.enum_value)
  return _internal_enum_value();
}
inline void Theme::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.Theme.enum_value)
}
inline std::string* Theme::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.Theme.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& Theme::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void Theme::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Theme::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.Theme.enum_value)
}
inline void Theme::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.Theme.enum_value)
}
inline void Theme::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.Theme.enum_value)
}
inline std::string* Theme::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Theme::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.Theme.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Theme::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.Theme.enum_value)
}

// -------------------------------------------------------------------

// ThemeType

// optional string enum_value = 1;
inline bool ThemeType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ThemeType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void ThemeType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ThemeType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.ThemeType.enum_value)
  return _internal_enum_value();
}
inline void ThemeType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.ThemeType.enum_value)
}
inline std::string* ThemeType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.ThemeType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& ThemeType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void ThemeType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ThemeType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.ThemeType.enum_value)
}
inline void ThemeType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.ThemeType.enum_value)
}
inline void ThemeType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.ThemeType.enum_value)
}
inline std::string* ThemeType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ThemeType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.ThemeType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ThemeType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.ThemeType.enum_value)
}

// -------------------------------------------------------------------

// TimecodeType

// optional string enum_value = 1;
inline bool TimecodeType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimecodeType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TimecodeType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TimecodeType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.TimecodeType.enum_value)
  return _internal_enum_value();
}
inline void TimecodeType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.TimecodeType.enum_value)
}
inline std::string* TimecodeType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.TimecodeType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TimecodeType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TimecodeType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TimecodeType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.TimecodeType.enum_value)
}
inline void TimecodeType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.TimecodeType.enum_value)
}
inline void TimecodeType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.TimecodeType.enum_value)
}
inline std::string* TimecodeType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TimecodeType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.TimecodeType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TimecodeType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.TimecodeType.enum_value)
}

// -------------------------------------------------------------------

// TisTerritoryCode

// optional string enum_value = 1;
inline bool TisTerritoryCode::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TisTerritoryCode::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TisTerritoryCode::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TisTerritoryCode::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.TisTerritoryCode.enum_value)
  return _internal_enum_value();
}
inline void TisTerritoryCode::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.TisTerritoryCode.enum_value)
}
inline std::string* TisTerritoryCode::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.TisTerritoryCode.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TisTerritoryCode::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TisTerritoryCode::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TisTerritoryCode::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.TisTerritoryCode.enum_value)
}
inline void TisTerritoryCode::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.TisTerritoryCode.enum_value)
}
inline void TisTerritoryCode::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.TisTerritoryCode.enum_value)
}
inline std::string* TisTerritoryCode::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TisTerritoryCode::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.TisTerritoryCode.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TisTerritoryCode::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.TisTerritoryCode.enum_value)
}

// -------------------------------------------------------------------

// TitleType

// optional string enum_value = 1;
inline bool TitleType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TitleType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TitleType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TitleType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.TitleType.enum_value)
  return _internal_enum_value();
}
inline void TitleType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.TitleType.enum_value)
}
inline std::string* TitleType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.TitleType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TitleType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TitleType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TitleType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.TitleType.enum_value)
}
inline void TitleType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.TitleType.enum_value)
}
inline void TitleType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.TitleType.enum_value)
}
inline std::string* TitleType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TitleType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.TitleType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TitleType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.TitleType.enum_value)
}

// -------------------------------------------------------------------

// TransferCategory

// optional string enum_value = 1;
inline bool TransferCategory::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransferCategory::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TransferCategory::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransferCategory::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.TransferCategory.enum_value)
  return _internal_enum_value();
}
inline void TransferCategory::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.TransferCategory.enum_value)
}
inline std::string* TransferCategory::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.TransferCategory.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TransferCategory::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TransferCategory::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TransferCategory::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.TransferCategory.enum_value)
}
inline void TransferCategory::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.TransferCategory.enum_value)
}
inline void TransferCategory::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.TransferCategory.enum_value)
}
inline std::string* TransferCategory::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TransferCategory::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.TransferCategory.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TransferCategory::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.TransferCategory.enum_value)
}

// -------------------------------------------------------------------

// TransferType

// optional string enum_value = 1;
inline bool TransferType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransferType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void TransferType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransferType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.TransferType.enum_value)
  return _internal_enum_value();
}
inline void TransferType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.TransferType.enum_value)
}
inline std::string* TransferType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.TransferType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& TransferType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void TransferType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TransferType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.TransferType.enum_value)
}
inline void TransferType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.TransferType.enum_value)
}
inline void TransferType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.TransferType.enum_value)
}
inline std::string* TransferType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TransferType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.TransferType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TransferType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.TransferType.enum_value)
}

// -------------------------------------------------------------------

// UnitOfBitRate

// optional string enum_value = 1;
inline bool UnitOfBitRate::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOfBitRate::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UnitOfBitRate::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitOfBitRate::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.UnitOfBitRate.enum_value)
  return _internal_enum_value();
}
inline void UnitOfBitRate::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.UnitOfBitRate.enum_value)
}
inline std::string* UnitOfBitRate::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.UnitOfBitRate.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UnitOfBitRate::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UnitOfBitRate::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitOfBitRate::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.UnitOfBitRate.enum_value)
}
inline void UnitOfBitRate::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.UnitOfBitRate.enum_value)
}
inline void UnitOfBitRate::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.UnitOfBitRate.enum_value)
}
inline std::string* UnitOfBitRate::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitOfBitRate::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.UnitOfBitRate.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitOfBitRate::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.UnitOfBitRate.enum_value)
}

// -------------------------------------------------------------------

// UnitOfConditionValue

// optional string enum_value = 1;
inline bool UnitOfConditionValue::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOfConditionValue::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UnitOfConditionValue::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitOfConditionValue::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.UnitOfConditionValue.enum_value)
  return _internal_enum_value();
}
inline void UnitOfConditionValue::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.UnitOfConditionValue.enum_value)
}
inline std::string* UnitOfConditionValue::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.UnitOfConditionValue.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UnitOfConditionValue::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UnitOfConditionValue::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitOfConditionValue::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.UnitOfConditionValue.enum_value)
}
inline void UnitOfConditionValue::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.UnitOfConditionValue.enum_value)
}
inline void UnitOfConditionValue::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.UnitOfConditionValue.enum_value)
}
inline std::string* UnitOfConditionValue::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitOfConditionValue::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.UnitOfConditionValue.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitOfConditionValue::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.UnitOfConditionValue.enum_value)
}

// -------------------------------------------------------------------

// UnitOfCuePoints

// optional string enum_value = 1;
inline bool UnitOfCuePoints::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOfCuePoints::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UnitOfCuePoints::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitOfCuePoints::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.UnitOfCuePoints.enum_value)
  return _internal_enum_value();
}
inline void UnitOfCuePoints::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.UnitOfCuePoints.enum_value)
}
inline std::string* UnitOfCuePoints::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.UnitOfCuePoints.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UnitOfCuePoints::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UnitOfCuePoints::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitOfCuePoints::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.UnitOfCuePoints.enum_value)
}
inline void UnitOfCuePoints::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.UnitOfCuePoints.enum_value)
}
inline void UnitOfCuePoints::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.UnitOfCuePoints.enum_value)
}
inline std::string* UnitOfCuePoints::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitOfCuePoints::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.UnitOfCuePoints.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitOfCuePoints::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.UnitOfCuePoints.enum_value)
}

// -------------------------------------------------------------------

// UnitOfDuration

// optional string enum_value = 1;
inline bool UnitOfDuration::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOfDuration::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UnitOfDuration::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitOfDuration::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.UnitOfDuration.enum_value)
  return _internal_enum_value();
}
inline void UnitOfDuration::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.UnitOfDuration.enum_value)
}
inline std::string* UnitOfDuration::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.UnitOfDuration.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UnitOfDuration::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UnitOfDuration::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitOfDuration::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.UnitOfDuration.enum_value)
}
inline void UnitOfDuration::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.UnitOfDuration.enum_value)
}
inline void UnitOfDuration::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.UnitOfDuration.enum_value)
}
inline std::string* UnitOfDuration::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitOfDuration::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.UnitOfDuration.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitOfDuration::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.UnitOfDuration.enum_value)
}

// -------------------------------------------------------------------

// UnitOfExtent

// optional string enum_value = 1;
inline bool UnitOfExtent::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOfExtent::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UnitOfExtent::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitOfExtent::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.UnitOfExtent.enum_value)
  return _internal_enum_value();
}
inline void UnitOfExtent::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.UnitOfExtent.enum_value)
}
inline std::string* UnitOfExtent::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.UnitOfExtent.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UnitOfExtent::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UnitOfExtent::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitOfExtent::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.UnitOfExtent.enum_value)
}
inline void UnitOfExtent::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.UnitOfExtent.enum_value)
}
inline void UnitOfExtent::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.UnitOfExtent.enum_value)
}
inline std::string* UnitOfExtent::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitOfExtent::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.UnitOfExtent.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitOfExtent::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.UnitOfExtent.enum_value)
}

// -------------------------------------------------------------------

// UnitOfFrameRate

// optional string enum_value = 1;
inline bool UnitOfFrameRate::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOfFrameRate::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UnitOfFrameRate::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitOfFrameRate::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.UnitOfFrameRate.enum_value)
  return _internal_enum_value();
}
inline void UnitOfFrameRate::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.UnitOfFrameRate.enum_value)
}
inline std::string* UnitOfFrameRate::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.UnitOfFrameRate.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UnitOfFrameRate::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UnitOfFrameRate::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitOfFrameRate::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.UnitOfFrameRate.enum_value)
}
inline void UnitOfFrameRate::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.UnitOfFrameRate.enum_value)
}
inline void UnitOfFrameRate::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.UnitOfFrameRate.enum_value)
}
inline std::string* UnitOfFrameRate::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitOfFrameRate::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.UnitOfFrameRate.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitOfFrameRate::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.UnitOfFrameRate.enum_value)
}

// -------------------------------------------------------------------

// UnitOfFrequency

// optional string enum_value = 1;
inline bool UnitOfFrequency::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOfFrequency::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UnitOfFrequency::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitOfFrequency::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.UnitOfFrequency.enum_value)
  return _internal_enum_value();
}
inline void UnitOfFrequency::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.UnitOfFrequency.enum_value)
}
inline std::string* UnitOfFrequency::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.UnitOfFrequency.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UnitOfFrequency::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UnitOfFrequency::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnitOfFrequency::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.UnitOfFrequency.enum_value)
}
inline void UnitOfFrequency::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.UnitOfFrequency.enum_value)
}
inline void UnitOfFrequency::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.UnitOfFrequency.enum_value)
}
inline std::string* UnitOfFrequency::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnitOfFrequency::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.UnitOfFrequency.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnitOfFrequency::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.UnitOfFrequency.enum_value)
}

// -------------------------------------------------------------------

// UseType

// optional string enum_value = 1;
inline bool UseType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UseType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UseType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UseType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.UseType.enum_value)
  return _internal_enum_value();
}
inline void UseType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.UseType.enum_value)
}
inline std::string* UseType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.UseType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UseType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UseType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UseType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.UseType.enum_value)
}
inline void UseType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.UseType.enum_value)
}
inline void UseType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.UseType.enum_value)
}
inline std::string* UseType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UseType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.UseType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UseType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.UseType.enum_value)
}

// -------------------------------------------------------------------

// UseType_MLC

// optional string enum_value = 1;
inline bool UseType_MLC::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UseType_MLC::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UseType_MLC::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UseType_MLC::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.UseType_MLC.enum_value)
  return _internal_enum_value();
}
inline void UseType_MLC::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.UseType_MLC.enum_value)
}
inline std::string* UseType_MLC::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.UseType_MLC.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UseType_MLC::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UseType_MLC::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UseType_MLC::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.UseType_MLC.enum_value)
}
inline void UseType_MLC::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.UseType_MLC.enum_value)
}
inline void UseType_MLC::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.UseType_MLC.enum_value)
}
inline std::string* UseType_MLC::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UseType_MLC::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.UseType_MLC.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UseType_MLC::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.UseType_MLC.enum_value)
}

// -------------------------------------------------------------------

// UseType_MWNL

// optional string enum_value = 1;
inline bool UseType_MWNL::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UseType_MWNL::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UseType_MWNL::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UseType_MWNL::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.UseType_MWNL.enum_value)
  return _internal_enum_value();
}
inline void UseType_MWNL::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.UseType_MWNL.enum_value)
}
inline std::string* UseType_MWNL::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.UseType_MWNL.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UseType_MWNL::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UseType_MWNL::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UseType_MWNL::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.UseType_MWNL.enum_value)
}
inline void UseType_MWNL::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.UseType_MWNL.enum_value)
}
inline void UseType_MWNL::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.UseType_MWNL.enum_value)
}
inline std::string* UseType_MWNL::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UseType_MWNL::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.UseType_MWNL.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UseType_MWNL::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.UseType_MWNL.enum_value)
}

// -------------------------------------------------------------------

// UserInterfaceType

// optional string enum_value = 1;
inline bool UserInterfaceType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserInterfaceType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void UserInterfaceType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserInterfaceType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.UserInterfaceType.enum_value)
  return _internal_enum_value();
}
inline void UserInterfaceType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.UserInterfaceType.enum_value)
}
inline std::string* UserInterfaceType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.UserInterfaceType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& UserInterfaceType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void UserInterfaceType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserInterfaceType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.UserInterfaceType.enum_value)
}
inline void UserInterfaceType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.UserInterfaceType.enum_value)
}
inline void UserInterfaceType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.UserInterfaceType.enum_value)
}
inline std::string* UserInterfaceType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserInterfaceType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.UserInterfaceType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserInterfaceType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.UserInterfaceType.enum_value)
}

// -------------------------------------------------------------------

// VersionType

// optional string enum_value = 1;
inline bool VersionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VersionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VersionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VersionType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.VersionType.enum_value)
  return _internal_enum_value();
}
inline void VersionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.VersionType.enum_value)
}
inline std::string* VersionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.VersionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VersionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VersionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VersionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.VersionType.enum_value)
}
inline void VersionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.VersionType.enum_value)
}
inline void VersionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.VersionType.enum_value)
}
inline std::string* VersionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VersionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.VersionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VersionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.VersionType.enum_value)
}

// -------------------------------------------------------------------

// VideoCodecType

// optional string enum_value = 1;
inline bool VideoCodecType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoCodecType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VideoCodecType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoCodecType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.VideoCodecType.enum_value)
  return _internal_enum_value();
}
inline void VideoCodecType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.VideoCodecType.enum_value)
}
inline std::string* VideoCodecType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.VideoCodecType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VideoCodecType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VideoCodecType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoCodecType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.VideoCodecType.enum_value)
}
inline void VideoCodecType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.VideoCodecType.enum_value)
}
inline void VideoCodecType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.VideoCodecType.enum_value)
}
inline std::string* VideoCodecType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoCodecType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.VideoCodecType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoCodecType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.VideoCodecType.enum_value)
}

// -------------------------------------------------------------------

// VideoDefinitionType

// optional string enum_value = 1;
inline bool VideoDefinitionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoDefinitionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VideoDefinitionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoDefinitionType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.VideoDefinitionType.enum_value)
  return _internal_enum_value();
}
inline void VideoDefinitionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.VideoDefinitionType.enum_value)
}
inline std::string* VideoDefinitionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.VideoDefinitionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VideoDefinitionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VideoDefinitionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoDefinitionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.VideoDefinitionType.enum_value)
}
inline void VideoDefinitionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.VideoDefinitionType.enum_value)
}
inline void VideoDefinitionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.VideoDefinitionType.enum_value)
}
inline std::string* VideoDefinitionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoDefinitionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.VideoDefinitionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoDefinitionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.VideoDefinitionType.enum_value)
}

// -------------------------------------------------------------------

// VideoType

// optional string enum_value = 1;
inline bool VideoType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VideoType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.VideoType.enum_value)
  return _internal_enum_value();
}
inline void VideoType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.VideoType.enum_value)
}
inline std::string* VideoType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.VideoType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VideoType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VideoType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.VideoType.enum_value)
}
inline void VideoType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.VideoType.enum_value)
}
inline void VideoType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.VideoType.enum_value)
}
inline std::string* VideoType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.VideoType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.VideoType.enum_value)
}

// -------------------------------------------------------------------

// VideoType_DSRF

// optional string enum_value = 1;
inline bool VideoType_DSRF::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoType_DSRF::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VideoType_DSRF::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoType_DSRF::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.VideoType_DSRF.enum_value)
  return _internal_enum_value();
}
inline void VideoType_DSRF::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.VideoType_DSRF.enum_value)
}
inline std::string* VideoType_DSRF::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.VideoType_DSRF.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VideoType_DSRF::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VideoType_DSRF::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoType_DSRF::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.VideoType_DSRF.enum_value)
}
inline void VideoType_DSRF::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.VideoType_DSRF.enum_value)
}
inline void VideoType_DSRF::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.VideoType_DSRF.enum_value)
}
inline std::string* VideoType_DSRF::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoType_DSRF::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.VideoType_DSRF.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoType_DSRF::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.VideoType_DSRF.enum_value)
}

// -------------------------------------------------------------------

// VisualPerceptionType

// optional string enum_value = 1;
inline bool VisualPerceptionType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VisualPerceptionType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VisualPerceptionType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VisualPerceptionType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.VisualPerceptionType.enum_value)
  return _internal_enum_value();
}
inline void VisualPerceptionType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.VisualPerceptionType.enum_value)
}
inline std::string* VisualPerceptionType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.VisualPerceptionType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VisualPerceptionType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VisualPerceptionType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VisualPerceptionType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.VisualPerceptionType.enum_value)
}
inline void VisualPerceptionType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.VisualPerceptionType.enum_value)
}
inline void VisualPerceptionType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.VisualPerceptionType.enum_value)
}
inline std::string* VisualPerceptionType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VisualPerceptionType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.VisualPerceptionType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VisualPerceptionType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.VisualPerceptionType.enum_value)
}

// -------------------------------------------------------------------

// VocalRegister

// optional string enum_value = 1;
inline bool VocalRegister::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VocalRegister::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VocalRegister::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VocalRegister::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.VocalRegister.enum_value)
  return _internal_enum_value();
}
inline void VocalRegister::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.VocalRegister.enum_value)
}
inline std::string* VocalRegister::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.VocalRegister.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VocalRegister::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VocalRegister::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VocalRegister::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.VocalRegister.enum_value)
}
inline void VocalRegister::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.VocalRegister.enum_value)
}
inline void VocalRegister::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.VocalRegister.enum_value)
}
inline std::string* VocalRegister::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VocalRegister::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.VocalRegister.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VocalRegister::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.VocalRegister.enum_value)
}

// -------------------------------------------------------------------

// VocalType

// optional string enum_value = 1;
inline bool VocalType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VocalType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void VocalType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VocalType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.VocalType.enum_value)
  return _internal_enum_value();
}
inline void VocalType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.VocalType.enum_value)
}
inline std::string* VocalType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.VocalType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& VocalType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void VocalType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VocalType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.VocalType.enum_value)
}
inline void VocalType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.VocalType.enum_value)
}
inline void VocalType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.VocalType.enum_value)
}
inline std::string* VocalType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VocalType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.VocalType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VocalType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.VocalType.enum_value)
}

// -------------------------------------------------------------------

// WorkRelationshipType

// optional string enum_value = 1;
inline bool WorkRelationshipType::_internal_has_enum_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WorkRelationshipType::has_enum_value() const {
  return _internal_has_enum_value();
}
inline void WorkRelationshipType::clear_enum_value() {
  enum_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WorkRelationshipType::enum_value() const {
  // @@protoc_insertion_point(field_get:mead101.avs.WorkRelationshipType.enum_value)
  return _internal_enum_value();
}
inline void WorkRelationshipType::set_enum_value(const std::string& value) {
  _internal_set_enum_value(value);
  // @@protoc_insertion_point(field_set:mead101.avs.WorkRelationshipType.enum_value)
}
inline std::string* WorkRelationshipType::mutable_enum_value() {
  // @@protoc_insertion_point(field_mutable:mead101.avs.WorkRelationshipType.enum_value)
  return _internal_mutable_enum_value();
}
inline const std::string& WorkRelationshipType::_internal_enum_value() const {
  return enum_value_.Get();
}
inline void WorkRelationshipType::_internal_set_enum_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void WorkRelationshipType::set_enum_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mead101.avs.WorkRelationshipType.enum_value)
}
inline void WorkRelationshipType::set_enum_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mead101.avs.WorkRelationshipType.enum_value)
}
inline void WorkRelationshipType::set_enum_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enum_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mead101.avs.WorkRelationshipType.enum_value)
}
inline std::string* WorkRelationshipType::_internal_mutable_enum_value() {
  _has_bits_[0] |= 0x00000001u;
  return enum_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* WorkRelationshipType::release_enum_value() {
  // @@protoc_insertion_point(field_release:mead101.avs.WorkRelationshipType.enum_value)
  if (!_internal_has_enum_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enum_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void WorkRelationshipType::set_allocated_enum_value(std::string* enum_value) {
  if (enum_value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enum_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enum_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mead101.avs.WorkRelationshipType.enum_value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace avs
}  // namespace mead101

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ddex_2dxmltoproto_2fgenerated_2fmead101_2favs_2eproto
